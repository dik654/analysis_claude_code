# Kode-CLI 핵심 아키텍처 분석

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [전체 프로젝트 구조](#2-전체-프로젝트-구조)
3. [진입점과 초기화 프로세스](#3-진입점과-초기화-프로세스)
4. [핵심 Query 시스템](#4-핵심-query-시스템)
5. [Context 관리 시스템](#5-context-관리-시스템)
6. [도구 등록 및 관리 메커니즘](#6-도구-등록-및-관리-메커니즘)
7. [메시지 시스템과 히스토리 관리](#7-메시지-시스템과-히스토리-관리)
8. [의존성 구조와 모듈 관계](#8-의존성-구조와-모듈-관계)
9. [아키텍처 다이어그램](#9-아키텍처-다이어그램)

---

## 1. 프로젝트 개요

### 1.1 프로젝트 정보
- **프로젝트명**: @shareai-lab/kode
- **버전**: 1.1.23
- **설명**: AI 기반 터미널 어시스턴트로 코드베이스를 이해하고, 파일 편집, 명령 실행 및 개발 워크플로우를 자동화
- **라이선스**: Apache-2.0
- **실행 환경**: Node.js >= 20.18.1
- **주요 기술 스택**: TypeScript, React (Ink), Anthropic SDK, Zod

### 1.2 CLI 바이너리
- `kode`: 메인 CLI 명령어
- `kwa`: 별칭 (Kode With AI)
- `kd`: 단축 명령어

### 1.3 핵심 목표
코드베이스를 이해하고 AI를 활용하여 개발자의 워크플로우를 자동화하는 터미널 기반 AI 어시스턴트입니다.

---

## 2. 전체 프로젝트 구조

### 2.1 디렉토리 레이아웃
```
kode-cli-analysis/
├── src/
│   ├── index.ts                 # 경량 CLI 진입점
│   ├── entrypoints/
│   │   └── cli.tsx              # 메인 애플리케이션 진입점
│   ├── screens/
│   │   └── REPL.tsx             # 사용자 인터랙션 레이어
│   ├── tools/                   # 도구 실행 레이어
│   │   ├── TaskTool/            # 에이전트 오케스트레이션
│   │   ├── BashTool/            # 쉘 명령 실행
│   │   ├── FileReadTool/        # 파일 읽기
│   │   ├── FileEditTool/        # 파일 편집
│   │   └── ...                  # 기타 도구들
│   ├── services/
│   │   ├── claude.ts            # Anthropic API 통합
│   │   ├── openai.ts            # OpenAI 호환 모델
│   │   ├── mcpClient.ts         # Model Context Protocol
│   │   └── modelAdapterFactory.ts # 통합 모델 인터페이스
│   ├── utils/
│   │   ├── config.ts            # 설정 관리
│   │   ├── model.ts             # 모델 매니저
│   │   ├── agentLoader.ts       # 동적 에이전트 로딩
│   │   └── messageContextManager.ts # 컨텍스트 윈도우 관리
│   ├── query.ts                 # 핵심 AI 대화 루프
│   ├── context.ts               # 프로젝트 컨텍스트 관리
│   ├── Tool.ts                  # 도구 인터페이스 정의
│   ├── tools.ts                 # 도구 레지스트리
│   ├── messages.ts              # 메시지 상태 관리
│   └── history.ts               # 명령 히스토리
├── package.json                 # 프로젝트 메타데이터
├── cli.js                       # 크로스 플랫폼 래퍼
└── dist/                        # 빌드 출력 (ESM 모듈)
```

### 2.2 3계층 병렬 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                  사용자 인터랙션 레이어                       │
│              (src/screens/REPL.tsx)                          │
│  - Ink 기반 터미널 UI (React for CLI)                       │
│  - 명령 파싱 및 사용자 입력 처리                              │
│  - 실시간 UI 업데이트 및 문법 강조                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  오케스트레이션 레이어                        │
│              (src/query.ts, src/tools/TaskTool/)             │
│  - 동적 에이전트 시스템 (작업 위임)                           │
│  - 멀티 모델 협업 및 전환                                     │
│  - 컨텍스트 관리 및 대화 연속성                               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  도구 실행 레이어                             │
│                   (src/tools/)                               │
│  - 파일 I/O, Bash, Grep 등 전문 도구                         │
│  - 권한 시스템을 통한 안전한 도구 접근                         │
│  - MCP (Model Context Protocol) 통합                        │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 진입점과 초기화 프로세스

### 3.1 경량 CLI 진입점 (index.ts)

**파일 위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/index.ts`

#### 3.1.1 진입점 설계 철학
```typescript
// 경량 진입점 - 무거운 UI 모듈 로딩 없이 빠른 응답
// - 개발: bun run src/entrypoints/cli.tsx
// - 프로덕션: dist/index.js로 빌드되어 bin/main에서 사용
```

#### 3.1.2 초기화 흐름

```
사용자 명령 실행
     ↓
┌─────────────────┐
│  index.ts       │ ← 경량 진입점
└─────────────────┘
     ↓
     ├─ --version/-v ?  → package.json 읽고 버전 출력 후 종료
     ├─ --help-lite ?   → 간단한 도움말 출력 후 종료
     └─ 기타           → entrypoints/cli.js 전체 로드
          ↓
     ┌─────────────────┐
     │  cli.tsx        │ ← 메인 애플리케이션
     └─────────────────┘
          ↓
     REPL 시작 (사용자 인터랙션)
```

#### 3.1.3 핵심 코드 분석

```typescript
import { createRequire } from 'module'
const require = createRequire(import.meta.url)

// 플래그 체크 유틸리티
function hasFlag(...flags: string[]): boolean {
  return process.argv.some(arg => flags.includes(arg))
}

// 1단계: 버전 체크 (즉시 종료)
if (hasFlag('--version', '-v')) {
  try {
    const pkg = require('../package.json')
    console.log(pkg.version || '')
  } catch {
    console.log('')
  }
  process.exit(0)
}

// 2단계: 간단한 도움말 (즉시 종료)
if (hasFlag('--help-lite')) {
  console.log(`Usage: kode [options] [command] [prompt]\n\n` +
    `Common options:\n` +
    `  -h, --help           Show full help\n` +
    `  -v, --version        Show version\n` +
    `  -p, --print          Print response and exit (non-interactive)\n` +
    `  -c, --cwd <cwd>      Set working directory`)
  process.exit(0)
}

// 3단계: 전체 CLI 로드 (호환성을 위해 --help도 전체 로드)
await import('./entrypoints/cli.js')
```

**설계 포인트**:
- **성능 최적화**: 버전/도움말 요청 시 무거운 모듈 로딩 회피
- **지연 로딩**: 실제 필요할 때만 전체 CLI 로드
- **CommonJS 호환성**: `createRequire`로 ESM에서 package.json 읽기

---

## 4. 핵심 Query 시스템

### 4.1 Query 시스템 개요

**파일 위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/query.ts`

Query 시스템은 Kode-CLI의 심장부로, AI와의 대화 루프를 관리하고 도구 실행을 조율합니다.

### 4.2 핵심 데이터 타입

#### 4.2.1 메시지 타입 계층

```typescript
// 사용자 메시지
export type UserMessage = {
  message: MessageParam
  type: 'user'
  uuid: UUID
  toolUseResult?: FullToolUseResult
  options?: {
    isKodingRequest?: boolean
    kodingContext?: string
    isCustomCommand?: boolean
    commandName?: string
    commandArgs?: string
  }
}

// AI 어시스턴트 메시지
export type AssistantMessage = {
  costUSD: number        // 비용 추적
  durationMs: number     // 응답 시간
  message: APIAssistantMessage
  type: 'assistant'
  uuid: UUID
  isApiErrorMessage?: boolean
  responseId?: string    // GPT-5 Responses API용
}

// 진행 상황 메시지
export type ProgressMessage = {
  content: AssistantMessage
  normalizedMessages: NormalizedMessage[]
  siblingToolUseIDs: Set<string>
  tools: Tool[]
  toolUseID: string
  type: 'progress'
  uuid: UUID
}

// 통합 메시지 타입
export type Message = UserMessage | AssistantMessage | ProgressMessage
```

#### 4.2.2 확장된 도구 사용 컨텍스트

```typescript
interface ExtendedToolUseContext extends ToolUseContext {
  abortController: AbortController   // 취소 제어
  options: {
    commands: any[]
    forkNumber: number
    messageLogName: string
    tools: Tool[]
    verbose: boolean
    safeMode: boolean
    maxThinkingTokens: number
    isKodingRequest?: boolean
    model?: string | ModelPointerType
  }
  readFileTimestamps: { [filename: string]: number }
  setToolJSX: (jsx: any) => void
  requestId?: string
}
```

### 4.3 Query 함수 핵심 로직

#### 4.3.1 함수 시그니처

```typescript
export async function* query(
  messages: Message[],
  systemPrompt: string[],
  context: { [k: string]: string },
  canUseTool: CanUseToolFn,
  toolUseContext: ExtendedToolUseContext,
  getBinaryFeedbackResponse?: (
    m1: AssistantMessage,
    m2: AssistantMessage,
  ) => Promise<BinaryFeedbackResult>,
): AsyncGenerator<Message, void>
```

**핵심 특징**:
- **비동기 제너레이터**: 스트리밍 방식으로 메시지 생성
- **재귀 구조**: 도구 사용 후 자기 자신을 호출하여 대화 지속
- **이진 피드백**: Anthropic 내부용 A/B 테스트 지원

#### 4.3.2 실행 흐름

```
┌──────────────────────────────────────────────────────────────┐
│ 1. 초기화 및 자동 컴팩션                                      │
│    - checkAutoCompact(): 메시지 히스토리 압축                │
│    - 컨텍스트 윈도우 초과 시 오래된 메시지 제거               │
└──────────────────────────────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│ 2. 시스템 프롬프트 구성                                       │
│    - formatSystemPromptWithContext()                         │
│    - 프로젝트 컨텍스트 주입 (Git 상태, 디렉토리 구조 등)      │
│    - 리마인더 이벤트 발생                                     │
└──────────────────────────────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│ 3. LLM 쿼리 실행                                             │
│    - queryLLM(): AI 모델에 메시지 전송                       │
│    - Binary Feedback 처리 (내부용)                           │
│    - 취소 신호 체크                                           │
└──────────────────────────────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│ 4. 응답 처리                                                  │
│    - yield assistantMessage (첫 응답 반환)                   │
│    - 도구 사용 블록 추출                                      │
└──────────────────────────────────────────────────────────────┘
                         ↓
                    도구 사용 있음?
                    /         \
                  No          Yes
                  ↓            ↓
               종료    ┌──────────────────────┐
                      │ 5. 도구 실행          │
                      │  - 병렬 vs 직렬 결정  │
                      │  - 권한 체크          │
                      │  - 도구 호출          │
                      └──────────────────────┘
                               ↓
                      ┌──────────────────────┐
                      │ 6. 재귀 호출          │
                      │  - 도구 결과 추가     │
                      │  - query() 재호출     │
                      └──────────────────────┘
                               ↓
                          (1번으로)
```

#### 4.3.3 핵심 코드 스니펫

```typescript
export async function* query(
  messages: Message[],
  systemPrompt: string[],
  context: { [k: string]: string },
  canUseTool: CanUseToolFn,
  toolUseContext: ExtendedToolUseContext,
  getBinaryFeedbackResponse?: (...) => Promise<BinaryFeedbackResult>,
): AsyncGenerator<Message, void> {
  // 1. 자동 컴팩션
  const { messages: processedMessages, wasCompacted } = await checkAutoCompact(
    messages,
    toolUseContext,
  )
  if (wasCompacted) {
    messages = processedMessages
  }

  // 2. 시스템 프롬프트 구성
  const { systemPrompt: fullSystemPrompt, reminders } =
    formatSystemPromptWithContext(systemPrompt, context, toolUseContext.agentId)

  // 리마인더 주입 (마지막 사용자 메시지에)
  if (reminders && messages.length > 0) {
    for (let i = messages.length - 1; i >= 0; i--) {
      const msg = messages[i]
      if (msg?.type === 'user') {
        // 리마인더를 메시지 앞에 추가
        messages[i] = { ...msg, message: {
          ...msg.message,
          content: reminders + msg.message.content
        }}
        break
      }
    }
  }

  // 3. LLM 쿼리
  function getAssistantResponse() {
    return queryLLM(
      normalizeMessagesForAPI(messages),
      fullSystemPrompt,
      toolUseContext.options.maxThinkingTokens,
      toolUseContext.options.tools,
      toolUseContext.abortController.signal,
      {
        safeMode: toolUseContext.options.safeMode ?? false,
        model: toolUseContext.options.model || 'main',
        prependCLISysprompt: true,
        toolUseContext: toolUseContext,
      },
    )
  }

  const result = await queryWithBinaryFeedback(
    toolUseContext,
    getAssistantResponse,
    getBinaryFeedbackResponse,
  )

  // 취소 체크
  if (toolUseContext.abortController.signal.aborted) {
    yield createAssistantMessage(INTERRUPT_MESSAGE)
    return
  }

  const assistantMessage = result.message
  yield assistantMessage

  // 4. 도구 사용 체크
  const toolUseMessages = assistantMessage.message.content.filter(
    _ => _.type === 'tool_use',
  )

  if (!toolUseMessages.length) {
    return  // 도구 사용 없으면 종료
  }

  // 5. 도구 실행 (병렬 vs 직렬)
  const toolResults: UserMessage[] = []
  const canRunConcurrently = toolUseMessages.every(msg =>
    toolUseContext.options.tools.find(t => t.name === msg.name)?.isReadOnly(),
  )

  if (canRunConcurrently) {
    for await (const message of runToolsConcurrently(...)) {
      yield message
      if (message.type === 'user') {
        toolResults.push(message)
      }
    }
  } else {
    for await (const message of runToolsSerially(...)) {
      yield message
      if (message.type === 'user') {
        toolResults.push(message)
      }
    }
  }

  // 6. 재귀 호출
  yield* await query(
    [...messages, assistantMessage, ...orderedToolResults],
    systemPrompt,
    context,
    canUseTool,
    toolUseContext,
    getBinaryFeedbackResponse,
  )
}
```

### 4.4 도구 실행 메커니즘

#### 4.4.1 병렬 vs 직렬 실행 결정

```typescript
// 읽기 전용 도구만 있으면 병렬 실행 가능
const canRunConcurrently = toolUseMessages.every(msg =>
  toolUseContext.options.tools
    .find(t => t.name === msg.name)
    ?.isReadOnly(),
)

// 병렬 실행 (최대 10개 동시)
async function* runToolsConcurrently(
  toolUseMessages: ToolUseBlock[],
  assistantMessage: AssistantMessage,
  canUseTool: CanUseToolFn,
  toolUseContext: ExtendedToolUseContext,
  shouldSkipPermissionCheck?: boolean,
): AsyncGenerator<Message, void> {
  yield* all(
    toolUseMessages.map(toolUse =>
      runToolUse(
        toolUse,
        new Set(toolUseMessages.map(_ => _.id)),
        assistantMessage,
        canUseTool,
        toolUseContext,
        shouldSkipPermissionCheck,
      ),
    ),
    MAX_TOOL_USE_CONCURRENCY,  // 10
  )
}

// 직렬 실행
async function* runToolsSerially(
  toolUseMessages: ToolUseBlock[],
  ...
): AsyncGenerator<Message, void> {
  for (const toolUse of toolUseMessages) {
    yield* runToolUse(...)
  }
}
```

#### 4.4.2 개별 도구 실행 (runToolUse)

```typescript
export async function* runToolUse(
  toolUse: ToolUseBlock,
  siblingToolUseIDs: Set<string>,
  assistantMessage: AssistantMessage,
  canUseTool: CanUseToolFn,
  toolUseContext: ExtendedToolUseContext,
  shouldSkipPermissionCheck?: boolean,
): AsyncGenerator<Message, void> {
  const toolName = toolUse.name
  const tool = toolUseContext.options.tools.find(t => t.name === toolName)

  // 1. 도구 존재 체크
  if (!tool) {
    yield createUserMessage([{
      type: 'tool_result',
      content: `Error: No such tool available: ${toolName}`,
      is_error: true,
      tool_use_id: toolUse.id,
    }])
    return
  }

  // 2. 취소 체크
  if (toolUseContext.abortController.signal.aborted) {
    yield createUserMessage([createToolResultStopMessage(toolUse.id)])
    return
  }

  try {
    // 3. 권한 체크 및 도구 호출
    for await (const message of checkPermissionsAndCallTool(
      tool,
      toolUse.id,
      siblingToolUseIDs,
      toolInput,
      toolUseContext,
      canUseTool,
      assistantMessage,
      shouldSkipPermissionCheck,
    )) {
      // 실행 중 취소 체크
      if (toolUseContext.abortController.signal.aborted) {
        yield createUserMessage([createToolResultStopMessage(toolUse.id)])
        return
      }
      yield message
    }
  } catch (e) {
    // 4. 에러 처리
    yield createUserMessage([{
      type: 'tool_result',
      content: `Tool execution failed: ${e.message}`,
      is_error: true,
      tool_use_id: toolUse.id,
    }])
  }
}
```

#### 4.4.3 권한 체크 및 호출 (checkPermissionsAndCallTool)

```typescript
async function* checkPermissionsAndCallTool(
  tool: Tool,
  toolUseID: string,
  siblingToolUseIDs: Set<string>,
  input: { [key: string]: boolean | string | number },
  context: ToolUseContext,
  canUseTool: CanUseToolFn,
  assistantMessage: AssistantMessage,
  shouldSkipPermissionCheck?: boolean,
): AsyncGenerator<UserMessage | ProgressMessage, void> {
  // 1. Zod 스키마 검증
  const isValidInput = tool.inputSchema.safeParse(input)
  if (!isValidInput.success) {
    yield createUserMessage([{
      type: 'tool_result',
      content: `InputValidationError: ${isValidInput.error.message}`,
      is_error: true,
      tool_use_id: toolUseID,
    }])
    return
  }

  // 2. 입력 정규화 (예: BashTool의 cwd 제거)
  const normalizedInput = normalizeToolInput(tool, input)

  // 3. 도구별 검증 로직
  const isValidCall = await tool.validateInput?.(normalizedInput, context)
  if (isValidCall?.result === false) {
    yield createUserMessage([{
      type: 'tool_result',
      content: isValidCall!.message,
      is_error: true,
      tool_use_id: toolUseID,
    }])
    return
  }

  // 4. 권한 체크
  const permissionResult = shouldSkipPermissionCheck
    ? ({ result: true } as const)
    : await canUseTool(tool, normalizedInput, context, assistantMessage)

  if (permissionResult.result === false) {
    yield createUserMessage([{
      type: 'tool_result',
      content: permissionResult.message,
      is_error: true,
      tool_use_id: toolUseID,
    }])
    return
  }

  // 5. 도구 호출
  try {
    const generator = tool.call(normalizedInput, context)
    for await (const result of generator) {
      switch (result.type) {
        case 'result':
          yield createUserMessage([{
            type: 'tool_result',
            content: result.resultForAssistant || String(result.data),
            tool_use_id: toolUseID,
          }], {
            data: result.data,
            resultForAssistant: result.resultForAssistant,
          })
          return

        case 'progress':
          yield createProgressMessage(
            toolUseID,
            siblingToolUseIDs,
            result.content,
            result.normalizedMessages || [],
            result.tools || [],
          )
          break
      }
    }
  } catch (error) {
    yield createUserMessage([{
      type: 'tool_result',
      content: formatError(error),
      is_error: true,
      tool_use_id: toolUseID,
    }])
  }
}
```

### 4.5 이진 피드백 시스템 (Binary Feedback)

Anthropic 내부용 A/B 테스트 기능:

```typescript
async function queryWithBinaryFeedback(
  toolUseContext: ExtendedToolUseContext,
  getAssistantResponse: () => Promise<AssistantMessage>,
  getBinaryFeedbackResponse?: (
    m1: AssistantMessage,
    m2: AssistantMessage,
  ) => Promise<BinaryFeedbackResult>,
): Promise<BinaryFeedbackResult> {
  // Anthropic 직원만 활성화
  if (
    process.env.USER_TYPE !== 'ant' ||
    !getBinaryFeedbackResponse ||
    !(await shouldUseBinaryFeedback())
  ) {
    const assistantMessage = await getAssistantResponse()
    return { message: assistantMessage, shouldSkipPermissionCheck: false }
  }

  // 두 개의 응답을 병렬 생성
  const [m1, m2] = await Promise.all([
    getAssistantResponse(),
    getAssistantResponse(),
  ])

  // 에러 처리
  if (m2.isApiErrorMessage) return { message: m1, ... }
  if (m1.isApiErrorMessage) return { message: m2, ... }

  // 피드백 비교
  if (!messagePairValidForBinaryFeedback(m1, m2)) {
    return { message: m1, ... }
  }

  // 사용자 선택 받기
  return await getBinaryFeedbackResponse(m1, m2)
}
```

### 4.6 Thinking 블록 규칙

```typescript
/**
 * Thinking 블록 규칙 (중요!):
 * 1. thinking/redacted_thinking을 포함하는 메시지는 max_thinking_length > 0인 쿼리의 일부여야 함
 * 2. thinking 블록은 메시지의 마지막 블록이 될 수 없음
 * 3. thinking 블록은 어시스턴트 궤적 동안 보존되어야 함
 *    (단일 턴, 또는 tool_use가 포함된 경우 후속 tool_result 및 다음 어시스턴트 메시지까지)
 */
```

---

## 5. Context 관리 시스템

### 5.1 Context 시스템 개요

**파일 위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/context.ts`

Context 시스템은 프로젝트의 구조와 상태를 AI에게 제공하여 코드베이스를 이해할 수 있게 합니다.

### 5.2 Context 구성 요소

```typescript
export const getContext = memoize(
  async (): Promise<{ [k: string]: string }> => {
    const codeStyle = getCodeStyle()
    const projectConfig = getCurrentProjectConfig()
    const dontCrawl = projectConfig.dontCrawlDirectory

    const [gitStatus, directoryStructure, claudeFiles, readme, projectDocs] =
      await Promise.all([
        getGitStatus(),                              // Git 저장소 상태
        dontCrawl ? '' : getDirectoryStructure(),    // 디렉토리 구조
        dontCrawl ? '' : getClaudeFiles(),           // AGENTS.md/CLAUDE.md
        getReadme(),                                  // README.md
        getProjectDocs(),                             // 프로젝트 문서
      ])

    return {
      ...projectConfig.context,
      ...(directoryStructure ? { directoryStructure } : {}),
      ...(gitStatus ? { gitStatus } : {}),
      ...(codeStyle ? { codeStyle } : {}),
      ...(claudeFiles ? { claudeFiles } : {}),
      ...(readme ? { readme } : {}),
      ...(projectDocs ? { projectDocs } : {}),
    }
  },
)
```

### 5.3 Git 상태 추출

```typescript
export const getGitStatus = memoize(async (): Promise<string | null> => {
  if (!(await getIsGit())) return null

  const [branch, mainBranch, status, log, authorLog] = await Promise.all([
    // 현재 브랜치
    execFileNoThrow('git', ['branch', '--show-current'])
      .then(({ stdout }) => stdout.trim()),

    // 메인 브랜치 (origin/HEAD)
    execFileNoThrow('git', ['rev-parse', '--abbrev-ref', 'origin/HEAD'])
      .then(({ stdout }) => stdout.replace('origin/', '').trim()),

    // 상태 (git status --short)
    execFileNoThrow('git', ['status', '--short'])
      .then(({ stdout }) => stdout.trim()),

    // 최근 커밋 5개
    execFileNoThrow('git', ['log', '--oneline', '-n', '5'])
      .then(({ stdout }) => stdout.trim()),

    // 현재 사용자의 최근 커밋 5개
    execFileNoThrow('git', ['log', '--oneline', '-n', '5', '--author', await getGitEmail()])
      .then(({ stdout }) => stdout.trim()),
  ])

  // 200줄 이상이면 잘라내기
  const statusLines = status.split('\n').length
  const truncatedStatus = statusLines > 200
    ? status.split('\n').slice(0, 200).join('\n') +
      '\n... (truncated because there are more than 200 lines)'
    : status

  return `This is the git status at the start of the conversation.
Current branch: ${branch}
Main branch: ${mainBranch}
Status:
${truncatedStatus || '(clean)'}
Recent commits:
${log}
Your recent commits:
${authorLog || '(no recent commits)'}`
})
```

**출력 예시**:
```
This is the git status at the start of the conversation.
Current branch: feature/new-tool
Main branch: main
Status:
M src/tools.ts
?? src/tools/NewTool/
Recent commits:
a1b2c3d Add new tool
e4f5g6h Fix bug in query system
i7j8k9l Update README
Your recent commits:
a1b2c3d Add new tool
```

### 5.4 디렉토리 구조 생성

```typescript
export const getDirectoryStructure = memoize(
  async function (): Promise<string> {
    try {
      const abortController = new AbortController()
      setTimeout(() => abortController.abort(), 1_000)  // 1초 타임아웃

      // LSTool 사용하여 디렉토리 구조 생성
      const resultsGen = LSTool.call(
        { path: '.' },
        {
          abortController,
          options: {
            commands: [],
            tools: [],
            forkNumber: 0,
            messageLogName: 'unused',
            maxThinkingTokens: 0,
          },
          messageId: undefined,
          readFileTimestamps: {},
        },
      )
      const result = await lastX(resultsGen)

      return `Below is a snapshot of this project's file structure at the start of the conversation.
This snapshot will NOT update during the conversation.

${result.data}`
    } catch (error) {
      logError(error)
      return ''
    }
  },
)
```

**출력 예시**:
```
Below is a snapshot of this project's file structure...

/project-root/
├── src/
│   ├── index.ts
│   ├── query.ts
│   ├── tools/
│   │   ├── BashTool/
│   │   └── FileReadTool/
│   └── utils/
├── package.json
└── README.md
```

### 5.5 프로젝트 문서 수집

#### 5.5.1 AGENTS.md 및 CLAUDE.md 검색

```typescript
export async function getClaudeFiles(): Promise<string | null> {
  const abortController = new AbortController()
  const timeout = setTimeout(() => abortController.abort(), 3000)

  try {
    // ripgrep으로 파일 검색
    const [codeContextFiles, claudeFiles] = await Promise.all([
      ripGrep(['--files', '--glob', join('**', '*', PROJECT_FILE)], getCwd(), ...)
        .catch(() => []),
      ripGrep(['--files', '--glob', join('**', '*', 'CLAUDE.md')], getCwd(), ...)
        .catch(() => []),
    ])

    const allFiles = [...codeContextFiles, ...claudeFiles]
    if (!allFiles.length) return null

    return `NOTE: Additional project documentation files (AGENTS.md, CLAUDE.md) were found.
When working in these directories, make sure to read and follow the instructions:
${allFiles.map(_ => `- ${path.join(getCwd(), _)}`).join('\n')}`
  } finally {
    clearTimeout(timeout)
  }
}
```

#### 5.5.2 프로젝트 문서 읽기

```typescript
export const getProjectDocs = memoize(async (): Promise<string | null> => {
  try {
    const cwd = getCwd()
    const codeContextPath = join(cwd, 'AGENTS.md')
    const claudePath = join(cwd, 'CLAUDE.md')

    const docs = []

    // AGENTS.md 읽기
    if (existsSync(codeContextPath)) {
      const content = await readFile(codeContextPath, 'utf-8')
      docs.push(`# AGENTS.md\n\n${content}`)
    }

    // CLAUDE.md 읽기
    if (existsSync(claudePath)) {
      const content = await readFile(claudePath, 'utf-8')
      docs.push(`# CLAUDE.md\n\n${content}`)
    }

    return docs.length > 0 ? docs.join('\n\n---\n\n') : null
  } catch (e) {
    logError(e)
    return null
  }
})
```

### 5.6 README.md 읽기

```typescript
export const getReadme = memoize(async (): Promise<string | null> => {
  try {
    const readmePath = join(getCwd(), 'README.md')
    if (!existsSync(readmePath)) return null

    const content = await readFile(readmePath, 'utf-8')
    return content
  } catch (e) {
    logError(e)
    return null
  }
})
```

### 5.7 Context 설정 관리

```typescript
// Context 추가
export function setContext(key: string, value: string): void {
  const projectConfig = getCurrentProjectConfig()
  const context = omit(
    { ...projectConfig.context, [key]: value },
    'codeStyle',              // 자동 생성 제외
    'directoryStructure',     // 자동 생성 제외
  )
  saveCurrentProjectConfig({ ...projectConfig, context })
}

// Context 제거
export function removeContext(key: string): void {
  const projectConfig = getCurrentProjectConfig()
  const context = omit(
    projectConfig.context,
    key,
    'codeStyle',
    'directoryStructure',
  )
  saveCurrentProjectConfig({ ...projectConfig, context })
}
```

### 5.8 Context 시스템 흐름

```
대화 시작
    ↓
┌──────────────────────────────────┐
│  getContext() 호출               │
│  (메모이제이션 - 한 번만 실행)    │
└──────────────────────────────────┘
    ↓
    ├─ getGitStatus()         → Git 상태 추출
    ├─ getDirectoryStructure() → 디렉토리 트리 생성
    ├─ getClaudeFiles()       → AGENTS.md/CLAUDE.md 검색
    ├─ getReadme()            → README.md 읽기
    └─ getProjectDocs()       → 프로젝트 문서 읽기
    ↓
┌──────────────────────────────────┐
│  Context 객체 구성               │
│  {                               │
│    gitStatus: "...",             │
│    directoryStructure: "...",    │
│    codeStyle: "...",             │
│    readme: "...",                │
│    projectDocs: "...",           │
│    ...사용자 정의 컨텍스트        │
│  }                               │
└──────────────────────────────────┘
    ↓
formatSystemPromptWithContext()
    ↓
AI에게 전달 (시스템 프롬프트에 주입)
```

---

## 6. 도구 등록 및 관리 메커니즘

### 6.1 Tool 인터페이스 정의

**파일 위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/Tool.ts`

#### 6.1.1 Tool 인터페이스 구조

```typescript
export interface Tool<
  TInput extends z.ZodObject<any> = z.ZodObject<any>,
  TOutput = any,
> {
  name: string
  description?: string | (() => Promise<string>)
  inputSchema: TInput
  inputJSONSchema?: Record<string, unknown>

  // 동적 프롬프트 (safeMode에 따라 변경 가능)
  prompt: (options?: { safeMode?: boolean }) => Promise<string>

  userFacingName?: () => string
  cachedDescription?: string  // 어댑터용 캐시된 설명

  // 도구 상태
  isEnabled: () => Promise<boolean>
  isReadOnly: () => boolean
  isConcurrencySafe: () => boolean
  needsPermissions: (input?: z.infer<TInput>) => boolean

  // 검증 및 실행
  validateInput?: (
    input: z.infer<TInput>,
    context?: ToolUseContext,
  ) => Promise<ValidationResult>

  // 렌더링
  renderResultForAssistant: (output: TOutput) => string | any[]
  renderToolUseMessage: (
    input: z.infer<TInput>,
    options: { verbose: boolean },
  ) => string
  renderToolUseRejectedMessage?: (...args: any[]) => React.ReactElement
  renderToolResultMessage?: (output: TOutput) => React.ReactElement

  // 핵심 실행 메서드 (비동기 제너레이터)
  call: (
    input: z.infer<TInput>,
    context: ToolUseContext,
  ) => AsyncGenerator<
    | { type: 'result'; data: TOutput; resultForAssistant?: string }
    | { type: 'progress'; content: any; normalizedMessages?: any[]; tools?: any[] },
    void,
    unknown
  >
}
```

#### 6.1.2 ToolUseContext

```typescript
export interface ToolUseContext {
  messageId: string | undefined
  agentId?: string
  safeMode?: boolean
  abortController: AbortController
  readFileTimestamps: { [filePath: string]: number }
  options?: {
    commands?: any[]
    tools?: any[]
    verbose?: boolean
    slowAndCapableModel?: string
    safeMode?: boolean
    forkNumber?: number
    messageLogName?: string
    maxThinkingTokens?: any
    isKodingRequest?: boolean
    kodingContext?: string
    isCustomCommand?: boolean
  }
  responseState?: {
    previousResponseId?: string
    conversationId?: string
  }
}

export interface ExtendedToolUseContext extends ToolUseContext {
  setToolJSX: SetToolJSXFn  // UI 업데이트 함수
}
```

#### 6.1.3 ValidationResult

```typescript
export interface ValidationResult {
  result: boolean
  message?: string
  errorCode?: number
  meta?: any
}
```

### 6.2 Tool 레지스트리

**파일 위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/tools.ts`

#### 6.2.1 전체 도구 목록

```typescript
export const getAllTools = (): Tool[] => {
  return [
    // 작업 관리
    TaskTool as unknown as Tool,
    TodoWriteTool as unknown as Tool,

    // 파일 작업
    FileReadTool as unknown as Tool,
    FileEditTool as unknown as Tool,
    MultiEditTool as unknown as Tool,
    FileWriteTool as unknown as Tool,

    // 노트북 작업
    NotebookReadTool as unknown as Tool,
    NotebookEditTool as unknown as Tool,

    // 파일 시스템
    LSTool as unknown as Tool,
    GlobTool as unknown as Tool,

    // 검색
    GrepTool as unknown as Tool,

    // 실행
    BashTool as unknown as Tool,

    // AI 협업
    AskExpertModelTool as unknown as Tool,
    ThinkTool as unknown as Tool,

    // 웹
    WebSearchTool as unknown as Tool,
    URLFetcherTool as unknown as Tool,

    // 확장성
    SkillTool as unknown as Tool,

    // Anthropic 내부용
    ...ANT_ONLY_TOOLS,  // MemoryReadTool, MemoryWriteTool
  ]
}
```

#### 6.2.2 활성화된 도구만 필터링

```typescript
export const getTools = memoize(
  async (enableArchitect?: boolean): Promise<Tool[]> => {
    // 모든 도구 + MCP 도구
    const tools = [...getAllTools(), ...(await getMCPTools())]

    // Architect 도구 (선택적)
    if (enableArchitect) {
      tools.push(ArchitectTool as unknown as Tool)
    }

    // isEnabled() 체크로 필터링
    const isEnabled = await Promise.all(tools.map(tool => tool.isEnabled()))
    return tools.filter((_, i) => isEnabled[i])
  },
)
```

#### 6.2.3 읽기 전용 도구만 필터링

```typescript
export const getReadOnlyTools = memoize(async (): Promise<Tool[]> => {
  const tools = getAllTools().filter(tool => tool.isReadOnly())
  const isEnabled = await Promise.all(tools.map(tool => tool.isEnabled()))
  return tools.filter((_, index) => isEnabled[index])
})
```

### 6.3 도구 분류

#### 6.3.1 카테고리별 도구

| 카테고리 | 도구 | 설명 |
|---------|------|------|
| **작업 관리** | TaskTool | 에이전트 위임 및 오케스트레이션 |
| | TodoWriteTool | TODO 리스트 관리 |
| **파일 작업** | FileReadTool | 파일 읽기 |
| | FileEditTool | 파일 편집 (정확한 문자열 치환) |
| | MultiEditTool | 여러 파일 동시 편집 |
| | FileWriteTool | 파일 쓰기 (새 파일 생성) |
| **노트북** | NotebookReadTool | Jupyter 노트북 읽기 |
| | NotebookEditTool | Jupyter 노트북 편집 |
| **파일 시스템** | LSTool | 디렉토리 목록 |
| | GlobTool | 파일 패턴 매칭 |
| **검색** | GrepTool | 파일 내용 검색 (ripgrep) |
| **실행** | BashTool | 쉘 명령 실행 |
| **AI 협업** | AskExpertModelTool | 다른 AI 모델에게 질문 |
| | ThinkTool | 내부 사고 과정 표시 |
| **웹** | WebSearchTool | 웹 검색 |
| | URLFetcherTool | URL 콘텐츠 가져오기 |
| **확장** | SkillTool | 사용자 정의 스킬 실행 |
| **메모리** | MemoryReadTool | 세션 간 메모리 읽기 (Ant 전용) |
| | MemoryWriteTool | 세션 간 메모리 쓰기 (Ant 전용) |
| **설계** | ArchitectTool | 아키텍처 설계 (선택적) |

#### 6.3.2 도구 속성

```typescript
// 읽기 전용 도구 (병렬 실행 가능)
const READ_ONLY_TOOLS = [
  'FileRead',
  'NotebookRead',
  'LS',
  'Glob',
  'Grep',
  'Think',
  'MemoryRead',
]

// 쓰기 도구 (직렬 실행 필요)
const WRITE_TOOLS = [
  'FileEdit',
  'MultiEdit',
  'FileWrite',
  'NotebookEdit',
  'Bash',
  'TodoWrite',
  'MemoryWrite',
]

// 권한 필요 도구
const PERMISSION_REQUIRED_TOOLS = [
  'FileEdit',
  'FileWrite',
  'Bash',
  'NotebookEdit',
]
```

### 6.4 도구 사용 흐름

```
AI가 도구 사용 결정
    ↓
┌──────────────────────────────────┐
│  Tool Schema 매칭                │
│  - name으로 도구 검색             │
│  - 도구 존재 확인                 │
└──────────────────────────────────┘
    ↓
┌──────────────────────────────────┐
│  입력 검증                        │
│  1. Zod 스키마 검증               │
│  2. 입력 정규화                   │
│  3. 도구별 validateInput() 호출   │
└──────────────────────────────────┘
    ↓
┌──────────────────────────────────┐
│  권한 체크                        │
│  - needsPermissions() 확인        │
│  - canUseTool() 호출              │
│  - 사용자 승인 대기 (필요 시)      │
└──────────────────────────────────┘
    ↓
┌──────────────────────────────────┐
│  도구 실행                        │
│  - tool.call() 호출               │
│  - 비동기 제너레이터로 진행 상황   │
│  - progress / result 메시지 yield │
└──────────────────────────────────┘
    ↓
┌──────────────────────────────────┐
│  결과 렌더링                      │
│  - renderResultForAssistant()     │
│  - renderToolResultMessage()      │
└──────────────────────────────────┘
    ↓
AI에게 결과 반환
```

### 6.5 도구 구현 예시

#### 6.5.1 간단한 읽기 전용 도구

```typescript
// LSTool 예시 (간략화)
export const LSTool: Tool = {
  name: 'LS',
  description: 'List directory contents',
  inputSchema: z.object({
    path: z.string(),
  }),

  isEnabled: async () => true,
  isReadOnly: () => true,
  isConcurrencySafe: () => true,
  needsPermissions: () => false,

  prompt: async () => 'List files and directories',

  renderResultForAssistant: (output) => output,
  renderToolUseMessage: (input, { verbose }) =>
    `Listing directory: ${input.path}`,

  async *call(input, context) {
    const result = await executeLS(input.path)
    yield {
      type: 'result',
      data: result,
    }
  },
}
```

#### 6.5.2 권한 필요 쓰기 도구

```typescript
// FileEditTool 예시 (간략화)
export const FileEditTool: Tool = {
  name: 'Edit',
  description: 'Edit a file by replacing exact strings',
  inputSchema: z.object({
    file_path: z.string(),
    old_string: z.string(),
    new_string: z.string(),
  }),

  isEnabled: async () => true,
  isReadOnly: () => false,
  isConcurrencySafe: () => false,
  needsPermissions: () => true,  // 권한 필요!

  validateInput: async (input, context) => {
    // 파일 존재 확인
    if (!existsSync(input.file_path)) {
      return {
        result: false,
        message: `File not found: ${input.file_path}`,
      }
    }
    // 읽기 전 타임스탬프 체크 (Read 도구 사용 여부)
    if (!context.readFileTimestamps[input.file_path]) {
      return {
        result: false,
        message: 'You must read the file before editing',
      }
    }
    return { result: true }
  },

  async *call(input, context) {
    // 진행 상황 보고
    yield {
      type: 'progress',
      content: `Editing ${input.file_path}...`,
    }

    // 파일 편집 수행
    const result = await performEdit(input)

    yield {
      type: 'result',
      data: result,
      resultForAssistant: `Successfully edited ${input.file_path}`,
    }
  },
}
```

### 6.6 MCP (Model Context Protocol) 통합

```typescript
import { getMCPTools } from './services/mcpClient'

export const getTools = memoize(
  async (enableArchitect?: boolean): Promise<Tool[]> => {
    // 내장 도구 + MCP 도구
    const tools = [...getAllTools(), ...(await getMCPTools())]

    // ... 필터링
  },
)
```

MCP를 통해 외부 도구를 동적으로 추가할 수 있습니다.

---

## 7. 메시지 시스템과 히스토리 관리

### 7.1 메시지 시스템

**파일 위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/messages.ts`

#### 7.1.1 메시지 상태 관리

```typescript
let getMessages: () => Message[] = () => []
let setMessages: React.Dispatch<React.SetStateAction<Message[]>> = () => {}

// Getter 설정
export function setMessagesGetter(getter: () => Message[]) {
  getMessages = getter
}

// Getter 조회
export function getMessagesGetter(): () => Message[] {
  return getMessages
}

// Setter 설정
export function setMessagesSetter(
  setter: React.Dispatch<React.SetStateAction<Message[]>>,
) {
  setMessages = setter
}

// Setter 조회
export function getMessagesSetter(): React.Dispatch<
  React.SetStateAction<Message[]>
> {
  return setMessages
}
```

**설계 패턴**:
- **전역 상태 관리**: React 상태를 전역적으로 접근 가능하게 함
- **Dependency Injection**: React 컴포넌트에서 getter/setter 주입
- **순환 의존성 회피**: 직접 import 대신 함수 주입

#### 7.1.2 모델 설정 변경 핸들러

```typescript
let onModelConfigChange: (() => void) | null = null

export function setModelConfigChangeHandler(handler: () => void) {
  onModelConfigChange = handler
}

export function triggerModelConfigChange() {
  if (onModelConfigChange) {
    onModelConfigChange()
  }
}
```

**사용 사례**:
- 모델 프로필 변경 시 UI 새로고침
- 설정 업데이트 후 도구 재로드

### 7.2 히스토리 관리

**파일 위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/history.ts`

#### 7.2.1 히스토리 구조

```typescript
const MAX_HISTORY_ITEMS = 100

// 히스토리 조회
export function getHistory(): string[] {
  return getCurrentProjectConfig().history ?? []
}

// 히스토리 추가
export function addToHistory(command: string): void {
  const projectConfig = getCurrentProjectConfig()
  const history = projectConfig.history ?? []

  // 중복 방지 (가장 최근 명령과 같으면 추가 안 함)
  if (history[0] === command) {
    return
  }

  // 새 명령을 맨 앞에 추가
  history.unshift(command)

  // 최대 100개까지만 유지
  saveCurrentProjectConfig({
    ...projectConfig,
    history: history.slice(0, MAX_HISTORY_ITEMS),
  })
}
```

#### 7.2.2 히스토리 저장 위치

```typescript
// 프로젝트 설정에 저장
// ~/.kode.json (전역) 또는 ./.kode.json (프로젝트)
{
  "history": [
    "create a new React component",
    "fix the bug in query.ts",
    "add tests for context.ts",
    ...
  ]
}
```

#### 7.2.3 히스토리 사용 흐름

```
사용자 명령 입력
    ↓
┌──────────────────────────────────┐
│  REPL에서 명령 실행               │
└──────────────────────────────────┘
    ↓
┌──────────────────────────────────┐
│  addToHistory(command) 호출       │
│  1. 현재 프로젝트 설정 로드        │
│  2. 중복 체크                     │
│  3. 맨 앞에 추가                  │
│  4. 100개로 제한                  │
│  5. 설정 파일에 저장              │
└──────────────────────────────────┘
    ↓
다음 세션에서 히스토리 사용 가능
(↑/↓ 키로 이전 명령 탐색)
```

### 7.3 메시지 흐름 다이어그램

```
사용자 입력
    ↓
┌────────────────────────────────────────┐
│  UserMessage 생성                      │
│  - message: MessageParam               │
│  - type: 'user'                        │
│  - uuid: UUID                          │
└────────────────────────────────────────┘
    ↓
getMessagesSetter()로 메시지 추가
    ↓
┌────────────────────────────────────────┐
│  query() 함수 호출                     │
│  - messages 배열 전달                  │
└────────────────────────────────────────┘
    ↓
LLM에 쿼리
    ↓
┌────────────────────────────────────────┐
│  AssistantMessage 생성                 │
│  - message: APIAssistantMessage        │
│  - type: 'assistant'                   │
│  - costUSD, durationMs                 │
└────────────────────────────────────────┘
    ↓
yield → REPL에 표시
    ↓
도구 사용 있음?
    ↓ Yes
┌────────────────────────────────────────┐
│  ProgressMessage (선택적)              │
│  - type: 'progress'                    │
│  - content: 진행 상황 UI               │
└────────────────────────────────────────┘
    ↓
도구 실행 완료
    ↓
┌────────────────────────────────────────┐
│  UserMessage (도구 결과)               │
│  - message.content[0].type: 'tool_result' │
│  - toolUseResult                       │
└────────────────────────────────────────┘
    ↓
재귀 호출 (다시 query()로)
```

---

## 8. 의존성 구조와 모듈 관계

### 8.1 주요 의존성

**파일 위치**: `/home/user/analysis_claude_code/kode-cli-analysis/package.json`

#### 8.1.1 AI/LLM 관련

```json
{
  "@anthropic-ai/sdk": "^0.39.0",           // Anthropic Claude API
  "@anthropic-ai/bedrock-sdk": "^0.12.6",   // AWS Bedrock용 Claude
  "@anthropic-ai/vertex-sdk": "^0.7.0",     // Google Vertex용 Claude
  "openai": "^4.104.0",                      // OpenAI 호환 모델
  "@modelcontextprotocol/sdk": "^1.15.1"    // MCP 프로토콜
}
```

#### 8.1.2 UI 프레임워크

```json
{
  "react": "18.3.1",                // React 코어
  "ink": "^5.2.1",                  // React for CLI
  "@inkjs/ui": "^2.0.0",            // Ink UI 컴포넌트
  "ink-link": "^4.1.0",             // 하이퍼링크
  "ink-select-input": "^6.2.0",     // 선택 입력
  "ink-text-input": "^6.0.0"        // 텍스트 입력
}
```

#### 8.1.3 CLI 및 터미널

```json
{
  "commander": "^13.1.0",                      // CLI 파서
  "@commander-js/extra-typings": "^13.1.0",   // TypeScript 타입
  "ansi-escapes": "^7.0.0",                    // ANSI 이스케이프 코드
  "chalk": "^5.4.1",                           // 터미널 색상
  "figures": "^6.1.0",                         // 유니코드 심볼
  "cli-highlight": "^2.1.11",                  // 코드 하이라이팅
  "cli-table3": "^0.6.5"                       // 테이블 렌더링
}
```

#### 8.1.4 파일 시스템 및 검색

```json
{
  "@vscode/ripgrep": "^1.17.0",    // ripgrep (빠른 검색)
  "glob": "^11.0.3",                // 파일 패턴 매칭
  "diff": "^7.0.0"                  // 파일 차이 비교
}
```

#### 8.1.5 유틸리티

```json
{
  "lodash-es": "^4.17.21",          // 유틸리티 함수
  "zod": "^3.25.76",                // 스키마 검증
  "zod-to-json-schema": "^3.24.6",  // Zod → JSON Schema
  "nanoid": "^5.1.5",               // UUID 생성
  "lru-cache": "^11.1.0",           // LRU 캐시
  "dotenv": "^16.6.1",              // 환경 변수
  "env-paths": "^3.0.0",            // 플랫폼별 경로
  "semver": "^7.7.2"                // 버전 비교
}
```

#### 8.1.6 마크다운 및 웹

```json
{
  "marked": "^15.0.12",             // Markdown 파서
  "gray-matter": "^4.0.3",          // YAML frontmatter
  "turndown": "^7.2.0",             // HTML → Markdown
  "node-html-parser": "^7.0.1",     // HTML 파싱
  "node-fetch": "^3.3.2",           // HTTP 요청
  "undici": "^7.11.0"               // 빠른 HTTP 클라이언트
}
```

#### 8.1.7 프로세스 관리

```json
{
  "spawn-rx": "^5.1.2",             // 프로세스 스폰 (RxJS)
  "shell-quote": "^1.8.3"           // 쉘 명령 이스케이프
}
```

#### 8.1.8 개발 도구

```json
{
  "typescript": "^5.9.2",           // TypeScript
  "tsx": "^4.20.3",                 // TS 실행기
  "esbuild": "^0.25.9",             // 빌드 도구
  "prettier": "^3.6.2",             // 코드 포맷터
  "bun-types": "latest"             // Bun 타입
}
```

### 8.2 모듈 의존성 그래프

```
index.ts (진입점)
  │
  └─→ entrypoints/cli.tsx
        │
        ├─→ screens/REPL.tsx (UI 레이어)
        │     │
        │     ├─→ messages.ts (메시지 상태)
        │     ├─→ history.ts (히스토리)
        │     └─→ Ink (React for CLI)
        │
        ├─→ query.ts (오케스트레이션)
        │     │
        │     ├─→ services/claude.ts (AI API)
        │     │     │
        │     │     ├─→ @anthropic-ai/sdk
        │     │     └─→ modelAdapterFactory.ts
        │     │
        │     ├─→ context.ts (컨텍스트)
        │     │     │
        │     │     ├─→ utils/git.ts
        │     │     ├─→ utils/ripgrep.ts
        │     │     └─→ tools/lsTool/lsTool.ts
        │     │
        │     ├─→ tools.ts (도구 레지스트리)
        │     │     │
        │     │     └─→ Tool.ts (인터페이스)
        │     │           │
        │     │           └─→ tools/* (개별 도구)
        │     │                 │
        │     │                 ├─→ BashTool
        │     │                 ├─→ FileReadTool
        │     │                 ├─→ FileEditTool
        │     │                 └─→ ...
        │     │
        │     └─→ utils/messageContextManager.ts
        │
        └─→ utils/
              │
              ├─→ config.ts (설정 관리)
              ├─→ model.ts (모델 매니저)
              ├─→ agentLoader.ts (에이전트 로딩)
              └─→ debugLogger.ts (로깅)
```

### 8.3 계층별 의존성

#### 8.3.1 프레젠테이션 계층
```
screens/REPL.tsx
  ↓
messages.ts, history.ts
  ↓
Ink, React
```

#### 8.3.2 비즈니스 로직 계층
```
query.ts
  ↓
context.ts, tools.ts
  ↓
services/claude.ts, utils/*
```

#### 8.3.3 데이터 계층
```
utils/config.ts
  ↓
fs/promises, env-paths
```

#### 8.3.4 외부 통합 계층
```
services/*
  ↓
@anthropic-ai/sdk, openai, @modelcontextprotocol/sdk
```

### 8.4 주요 모듈 책임

| 모듈 | 책임 | 의존성 |
|------|------|--------|
| `index.ts` | 경량 진입점 | module |
| `cli.tsx` | 메인 애플리케이션 | commander, screens/* |
| `REPL.tsx` | 사용자 인터페이스 | ink, messages, history |
| `query.ts` | AI 대화 루프 | services/claude, context, tools |
| `context.ts` | 프로젝트 컨텍스트 | utils/git, ripgrep, lsTool |
| `Tool.ts` | 도구 인터페이스 | zod, react |
| `tools.ts` | 도구 레지스트리 | tools/*, mcpClient |
| `messages.ts` | 메시지 상태 | react |
| `history.ts` | 히스토리 관리 | utils/config |
| `config.ts` | 설정 관리 | fs, env-paths |
| `model.ts` | 모델 매니저 | config |
| `claude.ts` | AI API 통합 | @anthropic-ai/sdk, modelAdapterFactory |

---

## 9. 아키텍처 다이어그램

### 9.1 전체 시스템 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                         사용자 (CLI)                            │
└────────────────────────────┬────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                      진입점 (index.ts)                          │
│  - 버전/도움말: 즉시 응답                                        │
│  - 기타: cli.tsx 로드                                           │
└────────────────────────────┬────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                 사용자 인터랙션 레이어                           │
│                   (screens/REPL.tsx)                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Ink (React for CLI)                                    │   │
│  │  - 명령 파싱                                             │   │
│  │  - 실시간 UI 업데이트                                    │   │
│  │  - 문법 강조                                             │   │
│  └─────────────────────────────────────────────────────────┘   │
└────────────────────────────┬────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│               오케스트레이션 레이어 (query.ts)                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  AI 대화 루프                                            │   │
│  │  1. 메시지 히스토리 관리                                 │   │
│  │  2. 컨텍스트 주입                                        │   │
│  │  3. LLM 쿼리                                            │   │
│  │  4. 도구 사용 조율                                       │   │
│  │  5. 재귀 호출 (도구 결과 → 다음 쿼리)                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Context 관리 (context.ts)                              │   │
│  │  - Git 상태                                              │   │
│  │  - 디렉토리 구조                                         │   │
│  │  - README, AGENTS.md, CLAUDE.md                         │   │
│  └─────────────────────────────────────────────────────────┘   │
└────────┬───────────────────────────┬────────────────────────────┘
         ↓                           ↓
┌──────────────────────┐    ┌──────────────────────────────────┐
│  AI 서비스            │    │  도구 실행 레이어 (tools/*)      │
│  (services/*)         │    │  ┌─────────────────────────────┐│
│  ┌─────────────────┐ │    │  │  파일 I/O                   ││
│  │ Anthropic       │ │    │  │  - FileRead, FileEdit, ...  ││
│  │ Claude API      │ │    │  └─────────────────────────────┘│
│  └─────────────────┘ │    │  ┌─────────────────────────────┐│
│  ┌─────────────────┐ │    │  │  검색                       ││
│  │ OpenAI          │ │    │  │  - Grep, Glob, LS           ││
│  │ Compatible      │ │    │  └─────────────────────────────┘│
│  └─────────────────┘ │    │  ┌─────────────────────────────┐│
│  ┌─────────────────┐ │    │  │  실행                       ││
│  │ Model Adapter   │ │    │  │  - Bash                     ││
│  │ Factory         │ │    │  └─────────────────────────────┘│
│  └─────────────────┘ │    │  ┌─────────────────────────────┐│
└──────────────────────┘    │  │  AI 협업                    ││
                            │  │  - Task, AskExpert, Think   ││
                            │  └─────────────────────────────┘│
                            │  ┌─────────────────────────────┐│
                            │  │  웹                         ││
                            │  │  - WebSearch, URLFetcher    ││
                            │  └─────────────────────────────┘│
                            └──────────────────────────────────┘
```

### 9.2 Query 시스템 상세 흐름

```
사용자 입력
    ↓
┌──────────────────────────────────────────────────────────┐
│  1. 초기화                                               │
│  - checkAutoCompact(): 메시지 압축                       │
│  - formatSystemPromptWithContext(): 프롬프트 구성        │
└──────────────────────────────────────────────────────────┘
    ↓
┌──────────────────────────────────────────────────────────┐
│  2. LLM 쿼리                                             │
│  - normalizeMessagesForAPI(): 메시지 정규화              │
│  - queryLLM(): AI 호출                                  │
│  - Binary Feedback (선택적)                             │
└──────────────────────────────────────────────────────────┘
    ↓
┌──────────────────────────────────────────────────────────┐
│  3. 응답 처리                                            │
│  - yield AssistantMessage                               │
│  - 도구 사용 블록 추출                                   │
└──────────────────────────────────────────────────────────┘
    ↓
    도구 사용 있음?
    /              \
  No               Yes
  ↓                 ↓
종료    ┌──────────────────────────────────────────┐
       │  4. 도구 실행 전략 결정                   │
       │  - 모두 읽기 전용? → 병렬 실행            │
       │  - 쓰기 도구 포함? → 직렬 실행            │
       └──────────────────────────────────────────┘
                       ↓
       ┌──────────────────────────────────────────┐
       │  5. 각 도구 실행 (runToolUse)            │
       │  ┌────────────────────────────────────┐  │
       │  │  a. 도구 검색                      │  │
       │  │  b. 입력 검증 (Zod)                │  │
       │  │  c. 입력 정규화                    │  │
       │  │  d. 도구별 검증 (validateInput)    │  │
       │  │  e. 권한 체크 (canUseTool)         │  │
       │  │  f. 도구 호출 (tool.call)          │  │
       │  │  g. 진행 상황 yield (progress)     │  │
       │  │  h. 결과 yield (result)            │  │
       │  └────────────────────────────────────┘  │
       └──────────────────────────────────────────┘
                       ↓
       ┌──────────────────────────────────────────┐
       │  6. 도구 결과 수집 및 정렬                │
       │  - UserMessage (tool_result) 생성        │
       │  - 원래 순서대로 정렬                     │
       └──────────────────────────────────────────┘
                       ↓
       ┌──────────────────────────────────────────┐
       │  7. 재귀 호출                             │
       │  query(                                  │
       │    [...messages,                         │
       │     assistantMessage,                    │
       │     ...toolResults]                      │
       │  )                                       │
       └──────────────────────────────────────────┘
                       ↓
                  (1번으로 돌아감)
```

### 9.3 Context 시스템 흐름

```
대화 시작
    ↓
┌──────────────────────────────────────────────────────────┐
│  getContext() (메모이제이션)                             │
└──────────────────────────────────────────────────────────┘
    ↓
    ├─→ getGitStatus()
    │     │
    │     ├─ git branch --show-current
    │     ├─ git rev-parse --abbrev-ref origin/HEAD
    │     ├─ git status --short
    │     ├─ git log --oneline -n 5
    │     └─ git log --author <email> -n 5
    │     ↓
    │   "Current branch: feature/...\nStatus: ..."
    │
    ├─→ getDirectoryStructure()
    │     │
    │     └─ LSTool.call({path: '.'})
    │     ↓
    │   "├── src/\n│   ├── index.ts\n..."
    │
    ├─→ getClaudeFiles()
    │     │
    │     └─ ripGrep(['--glob', '**/AGENTS.md'])
    │     ↓
    │   "NOTE: Additional docs found..."
    │
    ├─→ getReadme()
    │     │
    │     └─ readFile('README.md')
    │     ↓
    │   "# Project Name\n..."
    │
    └─→ getProjectDocs()
          │
          ├─ readFile('AGENTS.md')
          └─ readFile('CLAUDE.md')
          ↓
        "# AGENTS.md\n\n..."
    ↓
┌──────────────────────────────────────────────────────────┐
│  Context 객체 반환                                       │
│  {                                                       │
│    gitStatus: "...",                                     │
│    directoryStructure: "...",                            │
│    codeStyle: "...",                                     │
│    claudeFiles: "...",                                   │
│    readme: "...",                                        │
│    projectDocs: "..."                                    │
│  }                                                       │
└──────────────────────────────────────────────────────────┘
    ↓
formatSystemPromptWithContext()
    ↓
시스템 프롬프트에 주입
    ↓
AI에게 전달
```

### 9.4 도구 실행 파이프라인

```
AI가 도구 사용 요청
    ↓
┌──────────────────────────────────────────────────────────┐
│  1. 도구 매칭                                            │
│  toolUseContext.options.tools.find(t => t.name === name) │
└──────────────────────────────────────────────────────────┘
    ↓
    존재함?
    /      \
  No       Yes
  ↓         ↓
에러    ┌────────────────────────────────────────────────┐
       │  2. 입력 검증                                   │
       │  - Zod 스키마: tool.inputSchema.safeParse()    │
       │  - 정규화: normalizeToolInput()                │
       │  - 도구별 검증: tool.validateInput()           │
       └────────────────────────────────────────────────┘
              ↓
              검증 성공?
              /        \
            No         Yes
            ↓           ↓
         에러    ┌──────────────────────────────────────┐
                │  3. 권한 체크                         │
                │  - needsPermissions() 확인            │
                │  - canUseTool() 호출                  │
                │  - 사용자 승인 대기 (필요 시)          │
                └──────────────────────────────────────┘
                        ↓
                        승인됨?
                        /      \
                      No       Yes
                      ↓         ↓
                   거부    ┌────────────────────────────┐
                          │  4. 도구 실행               │
                          │  for await (tool.call()) {  │
                          │    if (progress)           │
                          │      yield ProgressMsg     │
                          │    if (result)             │
                          │      yield UserMsg         │
                          │  }                         │
                          └────────────────────────────┘
                                  ↓
                          ┌────────────────────────────┐
                          │  5. 결과 렌더링             │
                          │  - renderResultForAssistant │
                          │  - renderToolResultMessage │
                          └────────────────────────────┘
                                  ↓
                          AI에게 결과 반환
```

### 9.5 메시지 타입 및 흐름

```
UserMessage
  ├─ 사용자 입력
  │   type: 'user'
  │   message: { role: 'user', content: "..." }
  │
  └─ 도구 결과
      type: 'user'
      message: { role: 'user', content: [{ type: 'tool_result', ... }] }
      toolUseResult: { data, resultForAssistant }

AssistantMessage
  ├─ 텍스트 응답
  │   type: 'assistant'
  │   message: { role: 'assistant', content: [{ type: 'text', text: "..." }] }
  │
  └─ 도구 사용
      type: 'assistant'
      message: { role: 'assistant', content: [
        { type: 'text', text: "..." },
        { type: 'tool_use', id: "...", name: "...", input: {...} }
      ]}

ProgressMessage
  └─ 진행 상황
      type: 'progress'
      content: AssistantMessage (UI 업데이트용)
      normalizedMessages: NormalizedMessage[]
      tools: Tool[]
```

### 9.6 데이터 흐름 종합

```
┌───────────┐
│   사용자   │
└─────┬─────┘
      ↓ 입력
┌─────────────────┐
│  REPL (UI)      │
│  - messages     │ ←─────┐
│  - history      │        │ yield
└────┬────────────┘        │
     ↓ 메시지 추가          │
┌────────────────────────┐ │
│  query()               │ │
│  ┌──────────────────┐  │ │
│  │ Context 주입     │  │ │
│  │ - Git 상태       │  │ │
│  │ - 디렉토리       │  │ │
│  │ - 문서           │  │ │
│  └──────────────────┘  │ │
│  ┌──────────────────┐  │ │
│  │ LLM 쿼리         │  │ │
│  │ - Anthropic API  │  │ │
│  │ - OpenAI API     │  │ │
│  └──────────────────┘  │ │
│  ┌──────────────────┐  │ │
│  │ 도구 실행        │  │ │
│  │ - 검증           │  │ │
│  │ - 권한 체크      │  │ │
│  │ - call()         │  │ │
│  └──────────────────┘  │ │
└────────────────────────┘ │
      ↓ 재귀                │
      └────────────────────┘
```

---

## 10. 핵심 설계 원칙 및 패턴

### 10.1 설계 원칙

#### 10.1.1 비동기 제너레이터 패턴
- **이유**: 스트리밍 응답과 진행 상황 업데이트를 위해
- **적용**: `query()`, `tool.call()`, `runToolUse()`
- **장점**: 메모리 효율적, 실시간 피드백

#### 10.1.2 재귀적 대화 루프
- **이유**: 도구 사용 후 자동으로 다음 AI 응답 생성
- **적용**: `query()` 함수의 마지막 부분
- **장점**: 자연스러운 대화 흐름, 복잡한 작업 자동화

#### 10.1.3 메모이제이션
- **이유**: 반복 계산 방지, 성능 최적화
- **적용**: `getContext()`, `getGitStatus()`, `getTools()`
- **사용**: lodash-es의 `memoize()`

#### 10.1.4 Dependency Injection
- **이유**: 순환 의존성 회피, 테스트 용이성
- **적용**: `messages.ts`의 getter/setter 패턴
- **장점**: 모듈 간 결합도 감소

#### 10.1.5 타입 안전성
- **이유**: 런타임 에러 방지
- **적용**: TypeScript + Zod 스키마 검증
- **장점**: 개발 시 버그 조기 발견

### 10.2 주요 패턴

#### 10.2.1 제너레이터 패턴
```typescript
async function* query(...): AsyncGenerator<Message, void> {
  // 초기화
  yield firstMessage

  // 도구 실행
  for await (const msg of runTools(...)) {
    yield msg
  }

  // 재귀
  yield* query(...)
}
```

#### 10.2.2 Strategy 패턴 (도구 실행)
```typescript
const canRunConcurrently = toolUseMessages.every(...)

if (canRunConcurrently) {
  yield* runToolsConcurrently(...)
} else {
  yield* runToolsSerially(...)
}
```

#### 10.2.3 Builder 패턴 (컨텍스트 구성)
```typescript
const context = {
  ...projectConfig.context,
  ...(gitStatus ? { gitStatus } : {}),
  ...(directoryStructure ? { directoryStructure } : {}),
  ...
}
```

#### 10.2.4 Observer 패턴 (모델 설정 변경)
```typescript
setModelConfigChangeHandler(() => {
  // UI 새로고침
})

// 나중에
triggerModelConfigChange()
```

### 10.3 성능 최적화

#### 10.3.1 지연 로딩
- `index.ts`에서 필요할 때만 `cli.tsx` 로드
- 도구도 필요할 때만 활성화 (`isEnabled()`)

#### 10.3.2 병렬 실행
- 읽기 전용 도구는 동시 실행 (최대 10개)
- Context 수집도 `Promise.all()` 사용

#### 10.3.3 타임아웃
- `getDirectoryStructure()`: 1초
- `getClaudeFiles()`: 3초

#### 10.3.4 캐싱
- LRU 캐시 사용 (에이전트 로딩)
- 메모이제이션 (컨텍스트, 도구)

---

## 11. 확장 포인트

### 11.1 새로운 도구 추가

```typescript
// 1. 도구 구현 (src/tools/MyTool/MyTool.ts)
export const MyTool: Tool = {
  name: 'MyTool',
  description: 'Does something useful',
  inputSchema: z.object({
    param: z.string(),
  }),
  isEnabled: async () => true,
  isReadOnly: () => false,
  // ... 나머지 구현
}

// 2. tools.ts에 등록
import { MyTool } from './tools/MyTool/MyTool'

export const getAllTools = (): Tool[] => {
  return [
    ...
    MyTool as unknown as Tool,
  ]
}
```

### 11.2 새로운 AI 모델 추가

```typescript
// 1. 어댑터 구현 (src/services/adapters/MyModelAdapter.ts)
export class MyModelAdapter implements ModelAdapter {
  async queryModel(...) { ... }
}

// 2. Factory에 등록 (src/services/modelAdapterFactory.ts)
export function createModelAdapter(model: ModelProfile): ModelAdapter {
  if (model.provider === 'my-provider') {
    return new MyModelAdapter(model)
  }
  // ...
}
```

### 11.3 MCP 도구 추가

```json
// .kode.json
{
  "mcpServers": {
    "my-server": {
      "command": "node",
      "args": ["./my-mcp-server.js"]
    }
  }
}
```

자동으로 `getMCPTools()`가 로드합니다.

---

## 12. 결론

### 12.1 아키텍처 강점

1. **모듈화**: 각 계층이 명확히 분리되어 유지보수 용이
2. **확장성**: 새로운 도구/모델 추가가 간단
3. **타입 안전성**: TypeScript + Zod로 런타임 에러 최소화
4. **성능**: 병렬 실행, 메모이제이션, 지연 로딩
5. **사용자 경험**: 실시간 진행 상황, 권한 시스템

### 12.2 핵심 혁신

1. **재귀적 AI 루프**: 도구 사용 후 자동으로 다음 단계 진행
2. **멀티 모델 지원**: 여러 AI 모델 협업 가능
3. **동적 에이전트**: 마크다운 파일로 에이전트 설정
4. **MCP 통합**: 외부 도구를 쉽게 추가

### 12.3 향후 개선 방향

1. **스트리밍 최적화**: 더 빠른 응답 스트리밍
2. **캐시 전략**: 더 지능적인 컨텍스트 캐싱
3. **에러 복구**: 더 견고한 에러 처리
4. **테스트 커버리지**: 단위 테스트 및 통합 테스트 확대

---

## 부록 A: 핵심 파일 위치 요약

| 파일 | 경로 | 역할 |
|------|------|------|
| 진입점 | `/home/user/analysis_claude_code/kode-cli-analysis/src/index.ts` | 경량 CLI 진입점 |
| Query | `/home/user/analysis_claude_code/kode-cli-analysis/src/query.ts` | AI 대화 루프 |
| Context | `/home/user/analysis_claude_code/kode-cli-analysis/src/context.ts` | 프로젝트 컨텍스트 |
| Tool 인터페이스 | `/home/user/analysis_claude_code/kode-cli-analysis/src/Tool.ts` | 도구 계약 |
| Tool 레지스트리 | `/home/user/analysis_claude_code/kode-cli-analysis/src/tools.ts` | 도구 등록 |
| Messages | `/home/user/analysis_claude_code/kode-cli-analysis/src/messages.ts` | 메시지 상태 |
| History | `/home/user/analysis_claude_code/kode-cli-analysis/src/history.ts` | 히스토리 관리 |
| Package | `/home/user/analysis_claude_code/kode-cli-analysis/package.json` | 프로젝트 메타데이터 |

---

## 부록 B: 주요 타입 정의 요약

```typescript
// 메시지 타입
type UserMessage = { type: 'user', message: MessageParam, ... }
type AssistantMessage = { type: 'assistant', message: APIAssistantMessage, ... }
type ProgressMessage = { type: 'progress', content: AssistantMessage, ... }
type Message = UserMessage | AssistantMessage | ProgressMessage

// 도구 컨텍스트
interface ToolUseContext {
  messageId: string | undefined
  agentId?: string
  abortController: AbortController
  readFileTimestamps: { [filePath: string]: number }
  options?: { ... }
}

// 도구 인터페이스
interface Tool<TInput, TOutput> {
  name: string
  description?: string | (() => Promise<string>)
  inputSchema: z.ZodObject
  isEnabled: () => Promise<boolean>
  isReadOnly: () => boolean
  needsPermissions: (input?: TInput) => boolean
  call: (...) => AsyncGenerator<Result | Progress, void>
}

// 검증 결과
interface ValidationResult {
  result: boolean
  message?: string
  errorCode?: number
}
```

---

**문서 작성일**: 2025년 12월 24일
**분석 버전**: kode-cli v1.1.23
**작성자**: Claude Code Analysis Agent
