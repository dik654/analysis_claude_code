# Kode-CLI 파일 도구 시스템 분석

## 목차
1. [개요](#개요)
2. [FileRead 도구](#fileread-도구)
3. [FileWrite 도구](#filewrite-도구)
4. [FileEdit 도구](#fileedit-도구)
5. [MultiEdit 도구](#multiedit-도구)
6. [Glob 도구](#glob-도구)
7. [Grep 도구](#grep-도구)
8. [ls 도구](#ls-도구)
9. [파일 신선도 관리 시스템](#파일-신선도-관리-시스템)
10. [아키텍처 설계 원칙](#아키텍처-설계-원칙)

---

## 개요

Kode-CLI의 파일 도구 시스템은 AI 에이전트가 코드베이스와 안전하게 상호작용할 수 있도록 설계된 종합적인 파일 작업 프레임워크입니다. 이 시스템은 읽기, 쓰기, 편집, 검색의 네 가지 핵심 작업 영역을 지원하며, 각 도구는 독립적으로 설계되었지만 파일 신선도(freshness) 관리 시스템을 통해 통합됩니다.

### 핵심 설계 철학

1. **안전성 우선**: 모든 쓰기 작업은 파일을 먼저 읽어야 함
2. **충돌 방지**: 타임스탬프 기반 수정 감지
3. **명시적 검증**: 다단계 검증 프로세스
4. **사용자 친화적**: 명확한 에러 메시지와 제안
5. **성능 최적화**: 대용량 파일 처리를 위한 제한과 스트리밍

---

## FileRead 도구

**위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/tools/FileReadTool/`

### 기본 개념

FileRead 도구는 텍스트와 이미지 파일을 읽는 다목적 도구입니다. 단순히 파일 내용을 반환하는 것을 넘어, 파일 형식에 따른 최적화 처리, 크기 제한, 파일 신선도 추적 등의 기능을 제공합니다.

### 입력 스키마

```typescript
const inputSchema = z.strictObject({
  file_path: z.string().describe('The absolute path to the file to read'),
  offset: z.number().optional().describe('The line number to start reading from'),
  limit: z.number().optional().describe('The number of lines to read'),
})
```

### 주요 기능

#### 1. 텍스트 파일 읽기

**크기 제한**:
- 최대 파일 크기: **256KB** (0.25 * 1024 * 1024 bytes)
- 최대 줄 수: **2000줄**
- 줄당 최대 길이: **2000자** (초과 시 잘림)

**offset/limit 지원**:
```typescript
// 100번째 줄부터 50줄 읽기
{
  file_path: '/path/to/file.txt',
  offset: 100,
  limit: 50
}
```

**줄 번호 표시**:
```typescript
// 출력 예시 (cat -n 형식)
   1→import { z } from 'zod'
   2→import { Tool } from '@tool'
   3→
   4→export const FileReadTool = {
   5→  name: 'View',
```

#### 2. 이미지 파일 읽기

**지원 형식**:
```typescript
const IMAGE_EXTENSIONS = new Set([
  '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp'
])
```

**크기 제한 및 최적화**:
- 최대 이미지 크기: **5MB** (base64 인코딩 고려)
- 최대 너비: **2000px**
- 최대 높이: **2000px**

**자동 크기 조정 로직**:
```typescript
async function readImage(filePath: string, ext: string) {
  const sharp = (await import('sharp')).default
  const image = sharp(buffer)
  const metadata = await image.metadata()

  let width = metadata.width || 0
  let height = metadata.height || 0

  // 원본이 제한 내에 있으면 그대로 반환
  if (stats.size <= MAX_IMAGE_SIZE &&
      width <= MAX_WIDTH &&
      height <= MAX_HEIGHT) {
    return createImageResponse(buffer, ext)
  }

  // 너비 초과 시 비율 유지하며 조정
  if (width > MAX_WIDTH) {
    height = Math.round((height * MAX_WIDTH) / width)
    width = MAX_WIDTH
  }

  // 높이 초과 시 비율 유지하며 조정
  if (height > MAX_HEIGHT) {
    width = Math.round((width * MAX_HEIGHT) / height)
    height = MAX_HEIGHT
  }

  // 크기 조정
  const resizedImageBuffer = await image
    .resize(width, height, {
      fit: 'inside',
      withoutEnlargement: true,
    })
    .toBuffer()

  // 여전히 크다면 JPEG 압축 (품질 80%)
  if (resizedImageBuffer.length > MAX_IMAGE_SIZE) {
    const compressedBuffer = await image.jpeg({ quality: 80 }).toBuffer()
    return createImageResponse(compressedBuffer, 'jpeg')
  }

  return createImageResponse(resizedImageBuffer, ext)
}
```

#### 3. 파일 신선도 추적

모든 파일 읽기는 자동으로 추적됩니다:

```typescript
async *call({ file_path, offset = 1, limit = undefined }, { readFileTimestamps }) {
  const fullFilePath = normalizeFilePath(file_path)

  // 1. 파일 읽기 기록
  recordFileRead(fullFilePath)

  // 2. 타임스탬프 업데이트
  readFileTimestamps[fullFilePath] = Date.now()

  // 3. 수정 감지 및 경고
  const modificationReminder = generateFileModificationReminder(fullFilePath)
  if (modificationReminder) {
    emitReminderEvent('file:modified', {
      filePath: fullFilePath,
      reminder: modificationReminder,
      timestamp: Date.now(),
    })
  }

  // 4. 파일 내용 읽기
  const { content, lineCount, totalLines } = readTextContent(
    fullFilePath, lineOffset, limit
  )

  yield { type: 'result', data, resultForAssistant: ... }
}
```

### 검증 메커니즘

#### 단계 1: 파일 존재 확인

```typescript
async validateInput({ file_path, offset, limit }) {
  const fullFilePath = normalizeFilePath(file_path)

  // 보안 파일 서비스를 통한 파일 정보 확인
  const fileCheck = secureFileService.safeGetFileInfo(fullFilePath)
  if (!fileCheck.success) {
    // 유사 파일 제안
    const similarFilename = findSimilarFile(fullFilePath)
    let message = 'File does not exist.'

    if (similarFilename) {
      message += ` Did you mean ${similarFilename}?`
    }

    return { result: false, message }
  }
}
```

#### 단계 2: 크기 검증 (텍스트 파일)

```typescript
const stats = fileCheck.stats!
const fileSize = stats.size
const ext = path.extname(fullFilePath).toLowerCase()

// 이미지가 아닌 경우 크기 검증
if (!IMAGE_EXTENSIONS.has(ext)) {
  if (fileSize > MAX_OUTPUT_SIZE && !offset && !limit) {
    return {
      result: false,
      message: formatFileSizeError(fileSize),
      meta: { fileSize },
    }
  }
}
```

**에러 메시지 예시**:
```
File content (512KB) exceeds maximum allowed size (256KB).
Please use offset and limit parameters to read specific portions
of the file, or use the GrepTool to search for specific content.
```

### UI 렌더링

#### 터미널 출력 (최대 5줄)

```typescript
renderToolResultMessage(output) {
  const { filePath, content, numLines } = output.file
  const contentWithFallback = content || '(No content)'

  return (
    <Box>
      <Text>&nbsp;&nbsp;⎿ &nbsp;</Text>
      <Box flexDirection="column">
        <HighlightedCode
          code={
            contentWithFallback
              .split('\n')
              .slice(0, MAX_LINES_TO_RENDER)  // 5줄
              .filter(_ => _.trim() !== '')
              .join('\n')
          }
          language={extname(filePath).slice(1)}
        />
        {numLines > MAX_LINES_TO_RENDER && (
          <Text color={theme.secondaryText}>
            ... (+{numLines - MAX_LINES_TO_RENDER} lines)
          </Text>
        )}
      </Box>
    </Box>
  )
}
```

---

## FileWrite 도구

**위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/tools/FileWriteTool/`

### 기본 개념

FileWrite 도구는 파일을 생성하거나 전체 내용을 교체하는 도구입니다. **안전성을 위해 기존 파일을 쓰기 전에 반드시 읽어야 하는 제약**이 있습니다.

### 입력 스키마

```typescript
const inputSchema = z.strictObject({
  file_path: z.string().describe(
    'The absolute path to the file to write (must be absolute, not relative)'
  ),
  content: z.string().describe('The content to write to the file'),
})
```

### 안전성 검증

#### 1. 파일을 읽어야만 쓸 수 있음

```typescript
async validateInput({ file_path }, { readFileTimestamps }) {
  const fullFilePath = isAbsolute(file_path)
    ? file_path
    : resolve(getCwd(), file_path)

  // 새 파일인 경우는 OK
  if (!existsSync(fullFilePath)) {
    return { result: true }
  }

  // 기존 파일인 경우 읽은 적이 있는지 확인
  const readTimestamp = readFileTimestamps[fullFilePath]
  if (!readTimestamp) {
    return {
      result: false,
      message: 'File has not been read yet. Read it first before writing to it.',
    }
  }

  // 읽은 이후 수정되었는지 확인
  const stats = statSync(fullFilePath)
  const lastWriteTime = stats.mtimeMs
  if (lastWriteTime > readTimestamp) {
    return {
      result: false,
      message: 'File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.',
    }
  }

  return { result: true }
}
```

**검증 흐름**:
```
파일 존재?
  ├─ NO → 생성 허용 ✓
  └─ YES →
      └─ 읽은 적 있음?
          ├─ NO → 거부 ✗ "Read it first"
          └─ YES →
              └─ 수정됨?
                  ├─ YES → 거부 ✗ "Read it again"
                  └─ NO → 쓰기 허용 ✓
```

#### 2. 인코딩 및 줄바꿈 자동 감지

```typescript
async *call({ file_path, content }, { readFileTimestamps }) {
  const fullFilePath = isAbsolute(file_path)
    ? file_path
    : resolve(getCwd(), file_path)

  const oldFileExists = existsSync(fullFilePath)

  // 기존 파일의 인코딩 감지
  const enc = oldFileExists
    ? detectFileEncoding(fullFilePath)
    : 'utf-8'

  // 기존 파일의 줄바꿈 스타일 감지
  const endings = oldFileExists
    ? detectLineEndings(fullFilePath)
    : await detectRepoLineEndings(getCwd())

  // 디렉토리 생성
  mkdirSync(dir, { recursive: true })

  // 파일 쓰기
  writeTextContent(fullFilePath, content, enc, endings!)

  // 신선도 추적 업데이트
  recordFileEdit(fullFilePath, content)
  readFileTimestamps[fullFilePath] = statSync(fullFilePath).mtimeMs
}
```

### 출력 형식

#### 새 파일 생성

```typescript
type: 'create'
filePath: '/path/to/new/file.ts'
content: '...'
structuredPatch: []
```

**터미널 출력**:
```
  ⎿ Wrote 42 lines to file.ts
     import { z } from 'zod'
     import { Tool } from '@tool'

     export const MyTool = {
       name: 'MyTool',
     ... (+37 lines)
```

#### 기존 파일 업데이트

```typescript
type: 'update'
filePath: '/path/to/existing/file.ts'
content: '...'
structuredPatch: [
  {
    oldStart: 10,
    oldLines: 5,
    newStart: 10,
    newLines: 8,
    lines: [
      ' unchanged line',
      '-removed line',
      '+added line',
      ' unchanged line',
    ]
  }
]
```

**AI에게 전달되는 메시지**:
```
The file /path/to/file.ts has been updated. Here's the result
of running `cat -n` on a snippet of the edited file:
    1→import { z } from 'zod'
    2→import { Tool } from '@tool'
    ...
   42→} satisfies Tool
```

**터미널 diff 출력**:
```
  ⎿ Updated file.ts
     @@ -10,5 +10,8 @@
      unchanged line
     -removed line
     +added line
     +added line 2
      unchanged line
```

### 이벤트 발생

```typescript
emitReminderEvent('file:edited', {
  filePath: fullFilePath,
  content,
  oldContent: oldContent || '',
  timestamp: Date.now(),
  operation: oldFileExists ? 'update' : 'create',
})
```

---

## FileEdit 도구

**위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/tools/FileEditTool/`

### 기본 개념

FileEdit은 파일의 특정 부분을 정밀하게 수정하는 도구입니다. **old_string을 정확히 1번만 찾아서 new_string으로 교체**하는 방식으로 작동하며, 9단계의 엄격한 검증 프로세스를 거칩니다.

### 입력 스키마

```typescript
const inputSchema = z.strictObject({
  file_path: z.string().describe('The absolute path to the file to modify'),
  old_string: z.string().describe('The text to replace'),
  new_string: z.string().describe('The text to replace it with'),
})
```

### 9단계 검증 메커니즘

#### 단계 1: 동일성 검증

```typescript
if (old_string === new_string) {
  return {
    result: false,
    message: 'No changes to make: old_string and new_string are exactly the same.',
    meta: { old_string },
  }
}
```

#### 단계 2: 새 파일 생성 충돌 방지

```typescript
const fullFilePath = isAbsolute(file_path)
  ? file_path
  : resolve(getCwd(), file_path)

if (existsSync(fullFilePath) && old_string === '') {
  return {
    result: false,
    message: 'Cannot create new file - file already exists.',
  }
}
```

**참고**: `old_string === ''`는 새 파일 생성을 의미합니다.

#### 단계 3: 새 파일 생성 허용

```typescript
if (!existsSync(fullFilePath) && old_string === '') {
  return { result: true }
}
```

#### 단계 4: 파일 존재 확인 및 유사 파일 제안

```typescript
if (!existsSync(fullFilePath)) {
  const similarFilename = findSimilarFile(fullFilePath)
  let message = 'File does not exist.'

  if (similarFilename) {
    message += ` Did you mean ${similarFilename}?`
  }

  return {
    result: false,
    message,
  }
}
```

**유사 파일 찾기 예시**:
```typescript
// 요청: /src/utils/helper.js
// 실제: /src/utils/helper.ts
// 메시지: "File does not exist. Did you mean /src/utils/helper.ts?"
```

#### 단계 5: Jupyter Notebook 제외

```typescript
if (fullFilePath.endsWith('.ipynb')) {
  return {
    result: false,
    message: `File is a Jupyter Notebook. Use the ${NotebookEditTool.name} to edit this file.`,
  }
}
```

#### 단계 6: 파일 읽기 이력 확인

```typescript
const readTimestamp = readFileTimestamps[fullFilePath]
if (!readTimestamp) {
  return {
    result: false,
    message: 'File has not been read yet. Read it first before writing to it.',
    meta: {
      isFilePathAbsolute: String(isAbsolute(file_path)),
    },
  }
}
```

#### 단계 7: 수정 시간 검증

```typescript
const stats = statSync(fullFilePath)
const lastWriteTime = stats.mtimeMs
if (lastWriteTime > readTimestamp) {
  return {
    result: false,
    message: 'File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.',
  }
}
```

#### 단계 8: old_string 존재 확인

```typescript
const enc = detectFileEncoding(fullFilePath)
const file = readFileSync(fullFilePath, enc)

if (!file.includes(old_string)) {
  return {
    result: false,
    message: `String to replace not found in file.`,
    meta: {
      isFilePathAbsolute: String(isAbsolute(file_path)),
    },
  }
}
```

#### 단계 9: 고유성 검증 (가장 중요!)

```typescript
const matches = file.split(old_string).length - 1
if (matches > 1) {
  return {
    result: false,
    message: `Found ${matches} matches of the string to replace. For safety, this tool only supports replacing exactly one occurrence at a time. Add more lines of context to your edit and try again.`,
    meta: {
      isFilePathAbsolute: String(isAbsolute(file_path)),
    },
  }
}

return { result: true }
```

**고유성 검증의 중요성**:

```typescript
// ❌ 잘못된 사용 - 여러 곳에서 매칭됨
{
  old_string: "console.log('test')",
  new_string: "console.log('updated')"
}
// 에러: "Found 5 matches of the string to replace."

// ✓ 올바른 사용 - 충분한 컨텍스트로 고유하게 식별
{
  old_string: `
function validateUser() {
  console.log('test')
  return user.isValid()
}`,
  new_string: `
function validateUser() {
  console.log('validating user')
  return user.isValid()
}`
}
```

### 편집 적용

```typescript
export function applyEdit(
  file_path: string,
  old_string: string,
  new_string: string,
): { patch: Hunk[]; updatedFile: string } {
  const fullFilePath = isAbsolute(file_path)
    ? file_path
    : resolve(getCwd(), file_path)

  let originalFile
  let updatedFile

  if (old_string === '') {
    // 새 파일 생성
    originalFile = ''
    updatedFile = new_string
  } else {
    // 기존 파일 편집
    const enc = detectFileEncoding(fullFilePath)
    originalFile = readFileSync(fullFilePath, enc)

    // 삭제 작업 시 줄바꿈 처리
    if (new_string === '') {
      if (!old_string.endsWith('\n') &&
          originalFile.includes(old_string + '\n')) {
        updatedFile = originalFile.replace(old_string + '\n', () => new_string)
      } else {
        updatedFile = originalFile.replace(old_string, () => new_string)
      }
    } else {
      updatedFile = originalFile.replace(old_string, () => new_string)
    }

    if (updatedFile === originalFile) {
      throw new Error('Original and edited file match exactly. Failed to apply edit.')
    }
  }

  const patch = getPatch({
    filePath: file_path,
    fileContents: originalFile,
    oldStr: originalFile,
    newStr: updatedFile,
  })

  return { patch, updatedFile }
}
```

### 스니펫 생성

편집 후 AI에게 컨텍스트를 제공하기 위해 수정된 부분 전후 4줄씩을 포함한 스니펫을 생성합니다:

```typescript
export function getSnippet(
  initialText: string,
  oldStr: string,
  newStr: string,
): { snippet: string; startLine: number } {
  const before = initialText.split(oldStr)[0] ?? ''
  const replacementLine = before.split(/\r?\n/).length - 1
  const newFileLines = initialText.replace(oldStr, newStr).split(/\r?\n/)

  // 앞뒤 4줄씩 포함
  const startLine = Math.max(0, replacementLine - N_LINES_SNIPPET)  // 4
  const endLine = replacementLine + N_LINES_SNIPPET + newStr.split(/\r?\n/).length

  const snippetLines = newFileLines.slice(startLine, endLine + 1)
  const snippet = snippetLines.join('\n')

  return { snippet, startLine: startLine + 1 }
}
```

**출력 예시**:
```
The file /src/utils/helper.ts has been updated. Here's the result
of running `cat -n` on a snippet of the edited file:
   12→  const user = getUser()
   13→  if (!user) {
   14→    throw new Error('User not found')
   15→  }
   16→  console.log('validating user')  ← 수정된 줄
   17→  return user.isValid()
   18→}
   19→
   20→export function processUser() {
```

---

## MultiEdit 도구

**위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/tools/MultiEditTool/`

### 기본 개념

MultiEdit은 **단일 파일에 여러 편집을 한 번에 적용**하는 도구입니다. 각 편집은 순차적으로 적용되며, 모든 편집이 성공하거나 모두 실패하는 원자적(atomic) 작업입니다.

### 입력 스키마

```typescript
const EditSchema = z.object({
  old_string: z.string().describe('The text to replace'),
  new_string: z.string().describe('The text to replace it with'),
  replace_all: z.boolean().optional().default(false)
    .describe('Replace all occurences of old_string (default false)'),
})

const inputSchema = z.strictObject({
  file_path: z.string().describe('The absolute path to the file to modify'),
  edits: z.array(EditSchema).min(1)
    .describe('Array of edit operations to perform sequentially on the file'),
})
```

### 순차 적용 메커니즘

```typescript
async *call({ file_path, edits }, { readFileTimestamps }) {
  let currentContent = ''
  let fileExists = existsSync(filePath)

  if (fileExists) {
    const encoding = detectFileEncoding(filePath)
    currentContent = readFileSync(filePath, 'utf-8')
  }

  // 모든 편집을 순차적으로 적용
  let modifiedContent = currentContent
  const appliedEdits = []

  for (let i = 0; i < edits.length; i++) {
    const edit = edits[i]
    const { old_string, new_string, replace_all } = edit

    try {
      const result = applyContentEdit(
        modifiedContent,      // ← 이전 편집의 결과
        old_string,
        new_string,
        replace_all,
      )
      modifiedContent = result.newContent  // ← 다음 편집에 사용
      appliedEdits.push({
        editIndex: i + 1,
        success: true,
        occurrences: result.occurrences,
      })
    } catch (error) {
      // 하나라도 실패하면 전체 중단
      yield {
        type: 'result',
        data: `Error in edit ${i + 1}: ${error.message}`,
        resultForAssistant: `Error in edit ${i + 1}: ${error.message}`,
      }
      return
    }
  }

  // 모든 편집 성공 시에만 파일 쓰기
  writeTextContent(filePath, modifiedContent, encoding, lineEndings)
  recordFileEdit(filePath, modifiedContent)
  readFileTimestamps[filePath] = Date.now()

  yield { type: 'result', data: resultData, ... }
}
```

### replace_all 기능

```typescript
function applyContentEdit(
  content: string,
  oldString: string,
  newString: string,
  replaceAll: boolean = false
): { newContent: string; occurrences: number } {
  if (replaceAll) {
    // 정규식 특수문자 이스케이프
    const regex = new RegExp(
      oldString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
      'g'
    )
    const matches = content.match(regex)
    const occurrences = matches ? matches.length : 0
    const newContent = content.replace(regex, newString)
    return { newContent, occurrences }
  } else {
    if (content.includes(oldString)) {
      const newContent = content.replace(oldString, newString)
      return { newContent, occurrences: 1 }
    } else {
      throw new Error(`String not found: ${oldString.substring(0, 50)}...`)
    }
  }
}
```

**사용 예시**:
```typescript
// 변수명 일괄 변경
{
  file_path: '/src/utils.ts',
  edits: [
    {
      old_string: 'oldVariableName',
      new_string: 'newVariableName',
      replace_all: true  // 파일 전체에서 변경
    }
  ]
}
```

### 10단계 검증 시스템

#### 에러 코드 1: Jupyter Notebook 제외

```typescript
if (normalizedPath.endsWith('.ipynb')) {
  return {
    result: false,
    errorCode: 1,
    message: `For Jupyter notebooks (.ipynb files), use the ${NotebookEditTool.name} tool instead.`,
  }
}
```

#### 에러 코드 2: 부모 디렉토리 미존재

```typescript
if (!existsSync(normalizedPath)) {
  const parentDir = dirname(normalizedPath)
  if (!existsSync(parentDir)) {
    return {
      result: false,
      errorCode: 2,
      message: `Parent directory does not exist: ${parentDir}`,
    }
  }
}
```

#### 에러 코드 3: 동일한 문자열

```typescript
for (let i = 0; i < edits.length; i++) {
  const edit = edits[i]
  if (edit.old_string === edit.new_string) {
    return {
      result: false,
      errorCode: 3,
      message: `Edit ${i + 1}: old_string and new_string cannot be the same`,
    }
  }
}
```

#### 에러 코드 6: 새 파일 생성 시 첫 편집

```typescript
if (!existsSync(normalizedPath)) {
  if (edits.length === 0 || edits[0].old_string !== '') {
    return {
      result: false,
      errorCode: 6,
      message: 'For new files, the first edit must have an empty old_string to create the file content.',
    }
  }
}
```

#### 에러 코드 7: 파일 미읽음

```typescript
const readTimestamp = readFileTimestamps[normalizedPath]
if (!readTimestamp) {
  return {
    result: false,
    errorCode: 7,
    message: 'File has not been read yet. Read it first before editing it.',
    meta: {
      filePath: normalizedPath,
      isFilePathAbsolute: String(isAbsolute(file_path)),
    },
  }
}
```

#### 에러 코드 8: 파일 수정됨

```typescript
const stats = statSync(normalizedPath)
const lastWriteTime = stats.mtimeMs
if (lastWriteTime > readTimestamp) {
  return {
    result: false,
    errorCode: 8,
    message: 'File has been modified since read, either by the user or by a linter. Read it again before attempting to edit it.',
    meta: {
      filePath: normalizedPath,
      lastWriteTime,
      readTimestamp,
    },
  }
}
```

#### 에러 코드 9: 바이너리 파일

```typescript
const encoding = detectFileEncoding(normalizedPath)
if (encoding === 'binary') {
  return {
    result: false,
    errorCode: 9,
    message: 'Cannot edit binary files.',
  }
}
```

#### 에러 코드 10: old_string 미발견

```typescript
const currentContent = readFileSync(normalizedPath, 'utf-8')
for (let i = 0; i < edits.length; i++) {
  const edit = edits[i]
  if (edit.old_string !== '' && !currentContent.includes(edit.old_string)) {
    return {
      result: false,
      errorCode: 10,
      message: `Edit ${i + 1}: String to replace not found in file: "${edit.old_string.substring(0, 100)}..."`,
      meta: {
        editIndex: i + 1,
        oldString: edit.old_string.substring(0, 200),
      },
    }
  }
}
```

### 사용 시나리오

#### 시나리오 1: 여러 함수 이름 변경

```typescript
{
  file_path: '/src/api.ts',
  edits: [
    {
      old_string: 'function getUserData(',
      new_string: 'function fetchUserData(',
      replace_all: true
    },
    {
      old_string: 'function saveUser(',
      new_string: 'function persistUser(',
      replace_all: true
    }
  ]
}
```

#### 시나리오 2: 새 파일 생성 후 편집

```typescript
{
  file_path: '/src/new-module.ts',
  edits: [
    // 첫 편집: 파일 생성
    {
      old_string: '',
      new_string: `export class NewModule {
  constructor() {}
}
`
    },
    // 두 번째 편집: 메서드 추가
    {
      old_string: 'constructor() {}',
      new_string: `constructor() {}

  public init() {
    // initialization logic
  }`
    }
  ]
}
```

---

## Glob 도구

**위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/tools/GlobTool/`

### 기본 개념

Glob 도구는 **파일 이름 패턴 매칭**을 통해 파일을 빠르게 찾는 도구입니다. 정규식이 아닌 glob 패턴을 사용하며, 수정 시간 순으로 정렬된 결과를 반환합니다.

### 입력 스키마

```typescript
const inputSchema = z.strictObject({
  pattern: z.string().describe('The glob pattern to match files against'),
  path: z.string().optional()
    .describe('The directory to search in. Defaults to the current working directory.'),
})
```

### Glob 패턴 예시

```typescript
// 모든 TypeScript 파일
pattern: "**/*.ts"

// src 디렉토리의 모든 JavaScript/TypeScript 파일
pattern: "src/**/*.{js,ts}"

// 테스트 파일
pattern: "**/*.test.ts"

// 특정 이름 패턴
pattern: "**/Component*.tsx"

// 중첩 제한
pattern: "src/*/*.ts"  // src의 1단계 하위만
```

### 실행 로직

```typescript
async *call({ pattern, path }, { abortController }) {
  const start = Date.now()

  // glob 검색 (최대 100개 제한)
  const { files, truncated } = await glob(
    pattern,
    path ?? getCwd(),
    { limit: 100, offset: 0 },
    abortController.signal,
  )

  const output = {
    filenames: files,
    durationMs: Date.now() - start,
    numFiles: files.length,
    truncated,
  }

  yield {
    type: 'result',
    resultForAssistant: this.renderResultForAssistant(output),
    data: output,
  }
}
```

### 결과 형식

**AI에게 전달**:
```typescript
renderResultForAssistant(output) {
  let result = output.filenames.join('\n')

  if (output.filenames.length === 0) {
    result = 'No files found'
  } else if (output.truncated) {
    result += '\n(Results are truncated. Consider using a more specific path or pattern.)'
  }

  return result
}
```

**출력 예시**:
```
src/tools/FileReadTool/FileReadTool.tsx
src/tools/FileWriteTool/FileWriteTool.tsx
src/tools/FileEditTool/FileEditTool.tsx
src/tools/MultiEditTool/MultiEditTool.tsx
src/tools/GlobTool/GlobTool.tsx
... (95개 더)
(Results are truncated. Consider using a more specific path or pattern.)
```

**터미널 출력**:
```
  ⎿  Found 100 files                                    ⏱ 45ms
```

### 제한사항

- **최대 결과**: 100개
- **정렬**: 수정 시간 기준 (최신순)
- **중단 지원**: AbortController를 통한 검색 중단 가능

---

## Grep 도구

**위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/tools/GrepTool/`

### 기본 개념

Grep 도구는 **파일 내용을 정규식으로 검색**하는 도구입니다. ripgrep을 내부적으로 사용하여 빠른 검색을 제공합니다.

### 입력 스키마

```typescript
const inputSchema = z.strictObject({
  pattern: z.string()
    .describe('The regular expression pattern to search for in file contents'),
  path: z.string().optional()
    .describe('The directory to search in. Defaults to the current working directory.'),
  include: z.string().optional()
    .describe('File pattern to include in the search (e.g. "*.js", "*.{ts,tsx}")'),
})
```

### 정규식 패턴 예시

```typescript
// 특정 함수 호출 찾기
pattern: "console\\.log"

// 클래스 정의 찾기
pattern: "class\\s+\\w+"

// 에러 핸들링 찾기
pattern: "catch\\s*\\("

// import 구문 찾기
pattern: "import.*from\\s+['\"]react['\"]"

// TODO 주석 찾기
pattern: "TODO:"

// 복잡한 패턴
pattern: "function\\s+\\w+\\s*\\([^)]*\\)\\s*\\{"
```

### 실행 로직

```typescript
async *call({ pattern, path, include }, { abortController }) {
  const start = Date.now()
  const absolutePath = getAbsolutePath(path) || getCwd()

  // ripgrep 인자 구성
  const args = ['-li', pattern]  // -l: 파일명만, -i: 대소문자 무시
  if (include) {
    args.push('--glob', include)
  }

  // ripgrep 실행
  const results = await ripGrep(args, absolutePath, abortController.signal)

  // 파일 통계 가져오기
  const stats = await Promise.all(results.map(_ => stat(_)))

  // 수정 시간으로 정렬
  const matches = results
    .map((_, i) => [_, stats[i]!] as const)
    .sort((a, b) => {
      if (process.env.NODE_ENV === 'test') {
        return a[0].localeCompare(b[0])  // 테스트: 파일명순
      }
      const timeComparison = (b[1].mtimeMs ?? 0) - (a[1].mtimeMs ?? 0)
      if (timeComparison === 0) {
        return a[0].localeCompare(b[0])  // 동일 시간: 파일명순
      }
      return timeComparison  // 최신순
    })
    .map(_ => _[0])

  const output = {
    filenames: matches,
    durationMs: Date.now() - start,
    numFiles: matches.length,
  }

  yield {
    type: 'result',
    resultForAssistant: this.renderResultForAssistant(output),
    data: output,
  }
}
```

### 결과 형식

**AI에게 전달** (최대 100개):
```typescript
renderResultForAssistant({ numFiles, filenames }) {
  if (numFiles === 0) {
    return 'No files found'
  }

  let result = `Found ${numFiles} file${numFiles === 1 ? '' : 's'}\n${filenames.slice(0, MAX_RESULTS).join('\n')}`

  if (numFiles > MAX_RESULTS) {
    result += '\n(Results are truncated. Consider using a more specific path or pattern.)'
  }

  return result
}
```

**출력 예시**:
```
Found 23 files
src/tools/FileReadTool/FileReadTool.tsx
src/tools/FileWriteTool/FileWriteTool.tsx
src/utils/file.ts
src/services/fileFreshness.ts
... (19개 더)
```

**터미널 출력**:
```
  ⎿  Found 23 files                                    ⏱ 128ms
```

### 제한사항

- **최대 결과**: 100개
- **정렬**: 수정 시간 기준 (최신순)
- **중단 지원**: AbortController를 통한 검색 중단 가능

---

## ls 도구

**위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/tools/lsTool/`

### 기본 개념

ls 도구는 **디렉토리 구조를 트리 형태로 표시**하는 도구입니다. 재귀적으로 하위 디렉토리를 탐색하며, 숨김 파일과 특정 디렉토리는 자동으로 제외합니다.

### 입력 스키마

```typescript
const inputSchema = z.strictObject({
  path: z.string()
    .describe('The absolute path to the directory to list (must be absolute, not relative)'),
})
```

### 트리 출력 형식

```typescript
function printTree(tree: TreeNode[], level = 0, prefix = ''): string {
  let result = ''

  // 최상위에 절대 경로 표시
  if (level === 0) {
    result += `- ${getCwd()}${sep}\n`
    prefix = '  '
  }

  for (const node of tree) {
    // 현재 노드 추가
    result += `${prefix}${'-'} ${node.name}${node.type === 'directory' ? sep : ''}\n`

    // 재귀적으로 자식 노드 출력
    if (node.children && node.children.length > 0) {
      result += printTree(node.children, level + 1, `${prefix}  `)
    }
  }

  return result
}
```

**출력 예시**:
```
- /home/user/project/
  - src/
    - tools/
      - FileReadTool/
        - FileReadTool.tsx
        - prompt.ts
      - FileWriteTool/
        - FileWriteTool.tsx
        - prompt.ts
    - utils/
      - file.ts
      - state.ts
  - package.json
  - README.md
```

### 제한사항

**최대 파일 수**: 1000개

```typescript
const MAX_FILES = 1000
const TRUNCATED_MESSAGE = `There are more than ${MAX_FILES} files in the repository. Use the LS tool (passing a specific path), Bash tool, and other tools to explore nested directories. The first ${MAX_FILES} files and directories are included below:\n\n`

if (result.length < MAX_FILES) {
  yield { type: 'result', data: userTree, ... }
} else {
  const userData = `${TRUNCATED_MESSAGE}${userTree}`
  yield { type: 'result', data: userData, ... }
}
```

### 자동 제외 규칙

```typescript
function skip(path: string): boolean {
  // 숨김 파일/디렉토리
  if (path !== '.' && basename(path).startsWith('.')) {
    return true
  }

  // Python 캐시
  if (path.includes(`__pycache__${sep}`)) {
    return true
  }

  return false
}
```

**제외되는 항목**:
- `.git/`, `.vscode/`, `.idea/` 등 숨김 디렉토리
- `.gitignore`, `.env` 등 숨김 파일
- `__pycache__/` Python 캐시

### 디렉토리 탐색 로직

```typescript
function listDirectory(
  initialPath: string,
  cwd: string,
  abortSignal: AbortSignal,
): string[] {
  const results: string[] = []
  const queue = [initialPath]

  while (queue.length > 0) {
    // 제한 확인
    if (results.length > MAX_FILES) {
      return results
    }

    // 중단 확인
    if (abortSignal.aborted) {
      return results
    }

    const path = queue.shift()!
    if (skip(path)) {
      continue
    }

    // 현재 경로 추가 (초기 경로 제외)
    if (path !== initialPath) {
      results.push(relative(cwd, path) + sep)
    }

    // 자식 읽기
    let children
    try {
      children = readdirSync(path, { withFileTypes: true })
    } catch (e) {
      // 권한 에러 등 무시
      logError(e)
      continue
    }

    // 자식 처리
    for (const child of children) {
      if (child.isDirectory()) {
        queue.push(join(path, child.name) + sep)
      } else {
        const fileName = join(path, child.name)
        if (skip(fileName)) {
          continue
        }
        results.push(relative(cwd, fileName))
        if (results.length > MAX_FILES) {
          return results
        }
      }
    }
  }

  return results
}
```

### 터미널 출력 (최대 5줄)

```typescript
renderToolResultMessage(content) {
  const result = content.replace(TRUNCATED_MESSAGE, '')

  return (
    <Box>
      <Text>&nbsp;&nbsp;⎿ &nbsp;</Text>
      <Box flexDirection="column">
        {result
          .split('\n')
          .filter(_ => _.trim() !== '')
          .slice(0, MAX_LINES)  // 5줄
          .map((_, i) => (
            <Text key={i}>{_}</Text>
          ))}
        {result.split('\n').length > MAX_LINES && (
          <Text color={theme.secondaryText}>
            ... (+{result.split('\n').length - MAX_LINES} items)
          </Text>
        )}
      </Box>
    </Box>
  )
}
```

---

## 파일 신선도 관리 시스템

**위치**: `/home/user/analysis_claude_code/kode-cli-analysis/src/services/fileFreshness.ts`

### 기본 개념

파일 신선도(Freshness) 관리 시스템은 **파일이 읽힌 후 외부에서 수정되었는지 추적**하는 핵심 안전 메커니즘입니다. AI 에이전트가 오래된 정보를 바탕으로 파일을 수정하는 것을 방지합니다.

### 상태 구조

```typescript
interface FileTimestamp {
  path: string          // 파일 경로
  lastRead: number      // 마지막 읽은 시간 (ms)
  lastModified: number  // 마지막 수정 시간 (파일 시스템 mtime)
  size: number          // 파일 크기
  lastAgentEdit?: number // 에이전트가 마지막으로 편집한 시간
}

interface FileFreshnessState {
  readTimestamps: Map<string, FileTimestamp>  // 파일별 타임스탬프
  editConflicts: Set<string>                   // 충돌 파일 목록
  sessionFiles: Set<string>                    // 세션에서 접근한 파일
  watchedTodoFiles: Map<string, string>        // 감시 중인 TODO 파일
}
```

### 핵심 메서드

#### 1. recordFileRead - 파일 읽기 기록

```typescript
public recordFileRead(filePath: string): void {
  try {
    if (!existsSync(filePath)) {
      return
    }

    const stats = statSync(filePath)
    const timestamp: FileTimestamp = {
      path: filePath,
      lastRead: Date.now(),           // 현재 시간
      lastModified: stats.mtimeMs,    // 파일의 수정 시간
      size: stats.size,
    }

    this.state.readTimestamps.set(filePath, timestamp)
    this.state.sessionFiles.add(filePath)

    // 이벤트 발생
    emitReminderEvent('file:read', {
      filePath,
      timestamp: timestamp.lastRead,
      size: timestamp.size,
      modified: timestamp.lastModified,
    })
  } catch (error) {
    console.error(`Error recording file read for ${filePath}:`, error)
  }
}
```

**호출 위치**: FileReadTool, FileEditTool의 validateInput 등

#### 2. checkFileFreshness - 파일 신선도 확인

```typescript
public checkFileFreshness(filePath: string): {
  isFresh: boolean
  lastRead?: number
  currentModified?: number
  conflict: boolean
} {
  const recorded = this.state.readTimestamps.get(filePath)

  // 기록이 없으면 신선한 것으로 간주
  if (!recorded) {
    return { isFresh: true, conflict: false }
  }

  try {
    // 파일이 삭제된 경우
    if (!existsSync(filePath)) {
      return { isFresh: false, conflict: true }
    }

    const currentStats = statSync(filePath)

    // 파일의 현재 수정 시간 vs 기록된 수정 시간
    const isFresh = currentStats.mtimeMs <= recorded.lastModified
    const conflict = !isFresh

    if (conflict) {
      this.state.editConflicts.add(filePath)

      // 충돌 이벤트 발생
      emitReminderEvent('file:conflict', {
        filePath,
        lastRead: recorded.lastRead,
        lastModified: recorded.lastModified,
        currentModified: currentStats.mtimeMs,
        sizeDiff: currentStats.size - recorded.size,
      })
    }

    return {
      isFresh,
      lastRead: recorded.lastRead,
      currentModified: currentStats.mtimeMs,
      conflict,
    }
  } catch (error) {
    console.error(`Error checking freshness for ${filePath}:`, error)
    return { isFresh: false, conflict: true }
  }
}
```

#### 3. recordFileEdit - 에이전트 편집 기록

```typescript
public recordFileEdit(filePath: string, content?: string): void {
  try {
    const now = Date.now()

    if (existsSync(filePath)) {
      const stats = statSync(filePath)
      const existing = this.state.readTimestamps.get(filePath)

      if (existing) {
        existing.lastModified = stats.mtimeMs
        existing.size = stats.size
        existing.lastAgentEdit = now  // ← 에이전트 편집 시간 기록
        this.state.readTimestamps.set(filePath, existing)
      } else {
        const timestamp: FileTimestamp = {
          path: filePath,
          lastRead: now,
          lastModified: stats.mtimeMs,
          size: stats.size,
          lastAgentEdit: now,
        }
        this.state.readTimestamps.set(filePath, timestamp)
      }
    }

    // 충돌에서 제거 (방금 편집했으므로)
    this.state.editConflicts.delete(filePath)

    // 편집 이벤트 발생
    emitReminderEvent('file:edited', {
      filePath,
      timestamp: now,
      contentLength: content?.length || 0,
      source: 'agent',
    })
  } catch (error) {
    console.error(`Error recording file edit for ${filePath}:`, error)
  }
}
```

**호출 위치**: FileWriteTool, FileEditTool, MultiEditTool의 call 메서드

#### 4. generateFileModificationReminder - 수정 알림 생성

```typescript
public generateFileModificationReminder(filePath: string): string | null {
  const recorded = this.state.readTimestamps.get(filePath)

  if (!recorded) {
    return null
  }

  try {
    // 파일 삭제 확인
    if (!existsSync(filePath)) {
      return `Note: ${filePath} was deleted since last read.`
    }

    const currentStats = statSync(filePath)
    const isModified = currentStats.mtimeMs > recorded.lastModified

    if (!isModified) {
      return null
    }

    // 에이전트가 편집한 것인지 확인
    const TIME_TOLERANCE_MS = 100  // 파일시스템 정밀도 고려
    if (
      recorded.lastAgentEdit &&
      recorded.lastAgentEdit >= recorded.lastModified - TIME_TOLERANCE_MS
    ) {
      // 에이전트가 수정한 경우: 알림 불필요
      return null
    }

    // 외부 수정 감지
    return `Note: ${filePath} was modified externally since last read. The file may have changed outside of this session.`
  } catch (error) {
    console.error(`Error checking modification for ${filePath}:`, error)
    return null
  }
}
```

**사용 시나리오**:

```typescript
// FileReadTool에서 사용
const modificationReminder = generateFileModificationReminder(fullFilePath)
if (modificationReminder) {
  // AI에게 경고 전달
  emitReminderEvent('file:modified', {
    filePath: fullFilePath,
    reminder: modificationReminder,
    timestamp: Date.now(),
  })
}
```

### TODO 파일 감시

에이전트별 TODO 파일의 외부 수정을 감시합니다:

```typescript
public startWatchingTodoFile(agentId: string): void {
  try {
    const filePath = getAgentFilePath(agentId)

    if (this.state.watchedTodoFiles.has(agentId)) {
      return
    }

    this.state.watchedTodoFiles.set(agentId, filePath)

    // 초기 상태 기록
    if (existsSync(filePath)) {
      this.recordFileRead(filePath)
    }

    // 파일 감시 시작 (1초 간격)
    watchFile(filePath, { interval: 1000 }, (curr, prev) => {
      const reminder = this.generateFileModificationReminder(filePath)
      if (reminder) {
        // 외부 수정 감지 시 이벤트 발생
        emitReminderEvent('todo:file_changed', {
          agentId,
          filePath,
          reminder,
          timestamp: Date.now(),
          currentStats: { mtime: curr.mtime, size: curr.size },
          previousStats: { mtime: prev.mtime, size: prev.size },
        })
      }
    })
  } catch (error) {
    console.error(`Error starting todo file watch for agent ${agentId}:`, error)
  }
}

public stopWatchingTodoFile(agentId: string): void {
  const filePath = this.state.watchedTodoFiles.get(agentId)
  if (filePath) {
    unwatchFile(filePath)
    this.state.watchedTodoFiles.delete(agentId)
  }
}
```

### 대화 압축 시 중요 파일 복구

대화 컨텍스트가 압축될 때 최근 작업 파일을 우선 복구합니다:

```typescript
public getImportantFiles(maxFiles: number = 5): Array<{
  path: string
  timestamp: number
  size: number
}> {
  return Array.from(this.state.readTimestamps.entries())
    .map(([path, info]) => ({
      path,
      timestamp: info.lastRead,
      size: info.size,
    }))
    .filter(file => this.isValidForRecovery(file.path))
    .sort((a, b) => b.timestamp - a.timestamp)  // 최신순
    .slice(0, maxFiles)
}

private isValidForRecovery(filePath: string): boolean {
  return (
    !filePath.includes('node_modules') &&
    !filePath.includes('.git') &&
    !filePath.startsWith('/tmp') &&
    !filePath.includes('.cache') &&
    !filePath.includes('dist/') &&
    !filePath.includes('build/')
  )
}
```

**제외되는 파일**:
- `node_modules/` - 의존성
- `.git/` - Git 저장소
- `/tmp/` - 임시 파일
- `.cache/`, `dist/`, `build/` - 빌드 산출물

### 세션 관리

```typescript
public resetSession(): void {
  // 기존 TODO 파일 감시 해제
  this.state.watchedTodoFiles.forEach(filePath => {
    try {
      unwatchFile(filePath)
    } catch (error) {
      console.error(`Error unwatching file ${filePath}:`, error)
    }
  })

  // 상태 초기화
  this.state = {
    readTimestamps: new Map(),
    editConflicts: new Set(),
    sessionFiles: new Set(),
    watchedTodoFiles: new Map(),
  }
}
```

**호출 시점**: 세션 시작 시 (`session:startup` 이벤트)

### 타임스탬프 기반 검증 흐름

```
파일 읽기 (FileReadTool)
    ↓
recordFileRead(filePath)
    ↓ 저장: { lastRead: now, lastModified: stats.mtimeMs }

시간 경과... (사용자가 외부 편집기로 파일 수정)

파일 쓰기 시도 (FileEditTool)
    ↓
validateInput()
    ↓
stats.mtimeMs > readTimestamp?
    ↓
YES → 거부: "File has been modified since read"
NO → 허용
    ↓
call()
    ↓
recordFileEdit(filePath)
    ↓ 업데이트: { lastModified: 새로운 mtimeMs, lastAgentEdit: now }
```

### 에이전트 편집 vs 외부 편집 구분

```typescript
// 시나리오 1: 에이전트가 편집
recordFileEdit(filePath, content)
// → lastAgentEdit = now
// → lastModified = stats.mtimeMs

// 다시 읽을 때
generateFileModificationReminder(filePath)
// → lastAgentEdit >= lastModified - 100ms
// → return null (알림 없음)

// 시나리오 2: 외부에서 편집
// (에이전트가 recordFileEdit를 호출하지 않음)

// 다시 읽을 때
generateFileModificationReminder(filePath)
// → lastAgentEdit가 없거나 오래됨
// → return "Note: file was modified externally..."
```

---

## 아키텍처 설계 원칙

### 1. 계층적 안전성

```
사용자 요청
    ↓
AI 에이전트
    ↓
도구 선택 (FileEdit, FileWrite 등)
    ↓
validateInput() ← 9단계 검증
    ↓
call() ← 실제 파일 작업
    ↓
recordFileEdit() ← 신선도 추적 업데이트
    ↓
emitReminderEvent() ← 이벤트 발생
```

### 2. 읽기-쓰기 의존성

모든 쓰기 작업은 읽기를 선행 조건으로 요구합니다:

```typescript
// ✓ 올바른 순서
await FileReadTool.call({ file_path: '/src/app.ts' })
await FileEditTool.call({
  file_path: '/src/app.ts',
  old_string: '...',
  new_string: '...'
})

// ✗ 잘못된 순서
await FileEditTool.call({
  file_path: '/src/app.ts',  // 읽지 않음
  old_string: '...',
  new_string: '...'
})
// 에러: "File has not been read yet. Read it first before writing to it."
```

### 3. 타임스탬프 기반 충돌 감지

```typescript
interface ValidationFlow {
  읽기_시점: {
    파일_수정_시간: number    // stats.mtimeMs
    읽기_타임스탬프: number    // Date.now()
  }

  쓰기_시도_시점: {
    현재_파일_수정_시간: number  // stats.mtimeMs
    기록된_읽기_시간: number     // readFileTimestamps[path]
  }

  검증: {
    조건: '현재_파일_수정_시간 <= 기록된_읽기_시간',
    통과: '쓰기 허용',
    실패: '파일이 수정됨 - 다시 읽어야 함'
  }
}
```

### 4. 원자성과 트랜잭션

**MultiEdit**은 원자적 작업을 보장합니다:

```typescript
// 모든 편집이 성공하거나
edits.forEach(edit => apply(edit))
writeFile(result)
// ✓ 성공

// 또는 하나라도 실패하면 전체 중단
edits.forEach(edit => {
  if (!apply(edit)) {
    throw Error()  // 파일에 아무것도 쓰지 않음
  }
})
// ✗ 실패 - 원본 유지
```

### 5. 도구별 책임 분리

| 도구 | 책임 | 사용 시나리오 |
|------|------|---------------|
| **FileRead** | 파일 읽기, 이미지 처리, 신선도 기록 | 코드 이해, 이미지 확인 |
| **FileWrite** | 전체 파일 교체, 새 파일 생성 | 파일 재작성, 템플릿 생성 |
| **FileEdit** | 정밀한 부분 수정, 1:1 교체 | 버그 수정, 작은 변경 |
| **MultiEdit** | 여러 부분 일괄 수정, 원자적 작업 | 리팩토링, 변수명 변경 |
| **Glob** | 파일명 패턴 검색 | 특정 타입 파일 찾기 |
| **Grep** | 내용 정규식 검색 | 함수/클래스 위치 찾기 |
| **ls** | 디렉토리 구조 탐색 | 프로젝트 구조 이해 |

### 6. 에러 메시지 설계

모든 도구는 **실행 가능한 조언을 포함한 에러 메시지**를 제공합니다:

```typescript
// ✓ 좋은 에러 메시지
"File does not exist. Did you mean /src/utils/helper.ts?"
"Found 5 matches of the string to replace. Add more lines of context to your edit and try again."
"File content (512KB) exceeds maximum allowed size (256KB). Please use offset and limit parameters."

// ✗ 나쁜 에러 메시지
"Error"
"File not found"
"Invalid input"
```

### 7. 성능 최적화 전략

#### 파일 크기 제한
```typescript
FileRead: {
  텍스트: 256KB,
  이미지: 5MB (압축 후),
  줄수: 2000줄
}
```

#### 검색 결과 제한
```typescript
Glob: 100개 파일
Grep: 100개 파일
ls: 1000개 파일
```

#### 중단 지원
```typescript
// 모든 검색 도구는 AbortController 지원
async *call(input, { abortController }) {
  const results = await search(pattern, abortController.signal)
  // 사용자가 중단하면 즉시 종료
}
```

### 8. 이벤트 기반 확장성

```typescript
// 각 도구는 주요 작업 시 이벤트 발생
emitReminderEvent('file:read', { filePath, timestamp })
emitReminderEvent('file:edited', { filePath, operation })
emitReminderEvent('file:conflict', { filePath, lastRead, currentModified })
emitReminderEvent('todo:file_changed', { agentId, filePath })

// 다른 시스템이 이를 구독하여 반응
systemReminderService.addEventListener('file:edited', handler)
```

---

## 통합 워크플로우 예시

### 시나리오: 함수 이름 변경 및 로직 수정

```typescript
// 1단계: 프로젝트 구조 파악
await LSTool.call({ path: '/home/project' })
// 출력: 디렉토리 트리

// 2단계: 함수가 있는 파일 찾기
await GrepTool.call({
  pattern: 'function processUserData',
  path: '/home/project/src'
})
// 출력: src/services/user.ts

// 3단계: 함수가 사용되는 모든 곳 찾기
await GrepTool.call({
  pattern: 'processUserData\\(',
  path: '/home/project'
})
// 출력:
// - src/services/user.ts
// - src/controllers/userController.ts
// - tests/user.test.ts

// 4단계: 첫 번째 파일 읽기
await FileReadTool.call({
  file_path: '/home/project/src/services/user.ts'
})
// → recordFileRead() 호출
// → readFileTimestamps 업데이트

// 5단계: 함수 정의 수정 (이름 변경 + 로직 개선)
await FileEditTool.call({
  file_path: '/home/project/src/services/user.ts',
  old_string: `
function processUserData(user) {
  if (!user) return null
  return {
    id: user.id,
    name: user.name
  }
}`,
  new_string: `
function transformUserData(user) {
  if (!user) {
    throw new Error('User is required')
  }
  return {
    id: user.id,
    name: user.name,
    email: user.email
  }
}`
})
// → validateInput() 9단계 검증
// → applyEdit() 실행
// → recordFileEdit() 호출
// → readFileTimestamps 업데이트

// 6단계: 두 번째 파일 읽기
await FileReadTool.call({
  file_path: '/home/project/src/controllers/userController.ts'
})

// 7단계: 함수 호출 수정
await MultiEditTool.call({
  file_path: '/home/project/src/controllers/userController.ts',
  edits: [
    {
      old_string: 'processUserData',
      new_string: 'transformUserData',
      replace_all: true  // 파일 전체에서 변경
    }
  ]
})

// 8단계: 테스트 파일 읽기
await FileReadTool.call({
  file_path: '/home/project/tests/user.test.ts'
})

// 9단계: 테스트 수정
await MultiEditTool.call({
  file_path: '/home/project/tests/user.test.ts',
  edits: [
    {
      old_string: 'processUserData',
      new_string: 'transformUserData',
      replace_all: true
    },
    {
      old_string: "expect(result).toBeNull()",
      new_string: "expect(() => transformUserData(null)).toThrow('User is required')"
    }
  ]
})
```

### 전체 흐름의 신선도 추적

```
파일                          작업         타임스탬프                   상태
─────────────────────────────────────────────────────────────────────────
user.ts                      읽기         10:00:00                     ✓
user.ts                      편집         10:01:00  (에이전트)         ✓
userController.ts            읽기         10:02:00                     ✓
userController.ts            편집         10:03:00  (에이전트)         ✓
user.test.ts                 읽기         10:04:00                     ✓
user.test.ts                 편집         10:05:00  (에이전트)         ✓

만약 10:02:30에 사용자가 user.ts를 외부 편집기로 수정했다면?
→ userController.ts 편집 전에 FileReadTool이 경고 생성:
  "Note: user.ts was modified externally since last read."
→ AI는 user.ts를 다시 읽고 변경사항 확인 후 진행
```

---

## 결론

Kode-CLI의 파일 도구 시스템은 **안전성, 정확성, 사용자 경험**의 세 가지 축을 중심으로 설계되었습니다:

### 안전성
- 다단계 검증 프로세스
- 타임스탬프 기반 충돌 감지
- 읽기-쓰기 의존성 강제
- 원자적 작업 보장

### 정확성
- 고유성 검증 (정확히 1번 매칭)
- 인코딩 자동 감지
- 줄바꿈 스타일 유지
- diff 기반 변경 추적

### 사용자 경험
- 명확한 에러 메시지
- 유사 파일 제안
- 크기 제한과 부분 읽기
- 터미널 UI 최적화

이러한 설계 원칙들이 결합되어, AI 에이전트가 대규모 코드베이스에서도 안전하고 효율적으로 작업할 수 있는 견고한 파일 작업 환경을 제공합니다.
