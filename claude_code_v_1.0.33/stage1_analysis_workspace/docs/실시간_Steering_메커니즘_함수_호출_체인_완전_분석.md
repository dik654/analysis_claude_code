# 실시간 Steering 메커니즘 함수 호출 체인 완전 분석

## 개요

Claude Code 난독화 소스 코드에 대한 심층 분석을 기반으로, 본 문서는 실시간 Steering 메커니즘의 완전한 함수 호출 체인을 상세히 기록하며, 사용자 입력부터 시스템 응답까지의 전체 프로세스를 추적합니다.

## 1. 호출 체인 개요

```
사용자 입력(stdin) → 입력 리스닝 → 메시지 파싱 → 큐 관리 → 스트리밍 처리 → Agent 루프 → AI 처리 → 도구 실행 → 결과 출력
```

## 2. 상세 호출 체인 분석

### 2.1 입력 계층 - 표준 입력 리스닝

#### 호출 경로1: 전역 stdin 리스닝 초기화
```
파일 위치: improved-claude-code-5.mjs:49065
┌─────────────────────────────────────────────────────────────────┐
│ JX5 = L0(() => process.stdin.on("data", Fc))                    │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ function pq2(A, B = dq2) {                                      │
│   Y1A.useEffect(() => {                                         │
│     JX5();    // stdin 리스닝 초기화                            │
│     Fc();     // 포커스 검사 트리거                             │
│   }, []);                                                       │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

#### 호출 경로2: 포커스 감지의 stdin 리스닝
```
파일 위치: improved-claude-code-5.mjs:53568-53570
┌─────────────────────────────────────────────────────────────────┐
│ if (yy.add(G), yy.size === 1) {                                │
│   process.stdout.write("\x1B[?1004h");  // 포커스 보고 활성화  │
│   process.stdin.on("data", eAA);        // 데이터 리스닝       │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ return () => {                                                  │
│   if (yy.delete(G), yy.size === 0) {                          │
│     process.stdin.off("data", eAA);     // 리스너 정리         │
│     process.stdout.write("\x1B[?1004l"); // 포커스 보고 비활성화│
│   }                                                             │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

#### 호출 경로3: 키보드 입력 리스닝
```
파일 위치: improved-claude-code-5.mjs:67405-67407
┌─────────────────────────────────────────────────────────────────┐
│ useEffect(() => {                                               │
│   return process.stdin.on("data", Q), () => {                  │
│     process.stdin.off("data", Q);                              │
│   };                                                            │
│ }, [A]);                                                        │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 파싱 계층 - 메시지 파서 (g2A)

#### 메시지 파싱 클래스 초기화
```
파일 위치: improved-claude-code-5.mjs:68893-68899
┌─────────────────────────────────────────────────────────────────┐
│ class g2A {                                                     │
│   input;                                                        │
│   structuredInput;                                              │
│   constructor(A) {                                              │
│     this.input = A;                                             │
│     this.structuredInput = this.read();  // 비동기 읽기 시작    │
│   }                                                             │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ async *read() {                                                 │
│   let A = "";                                                   │
│   for await (let B of this.input) {     // 입력 스트림 비동기 반복│
│     A += B;                                                     │
│     let Q;                                                      │
│     while ((Q = A.indexOf('\n')) !== -1) {  // 줄 단위로 분할  │
│       let I = A.slice(0, Q);                                   │
│       A = A.slice(Q + 1);                                      │
│       let G = this.processLine(I);       // 단일 줄 처리       │
│       if (G) yield G;                   // 파싱 결과 출력      │
│     }                                                           │
│   }                                                             │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ processLine(A) {                                                │
│   try {                                                         │
│     let B = JSON.parse(A);              // JSON 파싱           │
│     if (B.type !== "user") Bk2(`Error: Expected 'user'`);     │
│     if (B.message.role !== "user") Bk2(`Error: Expected 'user'`); │
│     return B;                           // 검증된 메시지 반환  │
│   } catch (B) {                                                 │
│     console.error(`Error parsing: ${A}: ${B}`);               │
│     process.exit(1);                                            │
│   }                                                             │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 큐 계층 - 비동기 메시지 큐 (h2A)

#### 큐 초기화 및 핵심 메서드
```
파일 위치: improved-claude-code-5.mjs:68934-68993
┌─────────────────────────────────────────────────────────────────┐
│ class h2A {                                                     │
│   constructor(A) { this.returned = A; }                        │
│   [Symbol.asyncIterator]() {                                   │
│     if (this.started) throw new Error("Stream can only be iterated once"); │
│     return this.started = !0, this;                            │
│   }                                                             │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ next() {                                                        │
│   if (this.queue.length > 0) return Promise.resolve({          │
│     done: !1, value: this.queue.shift()  // 큐에서 메시지 추출 │
│   });                                                           │
│   if (this.isDone) return Promise.resolve({                    │
│     done: !0, value: void 0              // 큐 완료            │
│   });                                                           │
│   if (this.hasError) return Promise.reject(this.hasError);     │
│   return new Promise((A, B) => {         // 새 메시지 대기     │
│     this.readResolve = A, this.readReject = B;                │
│   });                                                           │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ enqueue(A) {                                                    │
│   if (this.readResolve) {               // 대기 중인 읽기 있음 │
│     let B = this.readResolve;                                   │
│     this.readResolve = void 0, this.readReject = void 0;       │
│     B({ done: !1, value: A });          // 메시지 직접 반환    │
│   } else this.queue.push(A);            // 큐 버퍼에 푸시      │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4 처리 계층 - 스트리밍 처리 엔진 (kq5)

#### 스트리밍 프로세서 초기화 및 실행
```
파일 위치: improved-claude-code-5.mjs:69363-69421
┌─────────────────────────────────────────────────────────────────┐
│ function kq5(A, B, Q, I, G, Z, D, Y) {                         │
│   let W = [],                           // 명령 큐              │
│       J = () => W,                      // 큐 접근자            │
│       F = (N) => { W = W.filter(...) }, // 큐 클리너            │
│       X = !1,                          // 실행 상태 플래그      │
│       V = !1,                          // 완료 상태 플래그      │
│       C = new h2A,                     // 출력 큐 생성          │
│       K = Dk2(Z);                      // 초기 메시지 처리      │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│   E = async () => {                     // 비동기 실행 엔진     │
│     X = !0;                            // 실행 상태 설정       │
│     try {                                                       │
│       while (W.length > 0) {           // 큐의 명령 처리       │
│         let N = W.shift();                                      │
│         if (N.mode !== "prompt") throw new Error("only prompt commands"); │
│         let q = N.value;                                        │
│         for await (let O of Zk2({      // 메인 Agent 루프 호출│
│           commands: I, prompt: q, ... │
│         })) {                                                   │
│           K.push(O), C.enqueue(O);     // 큐로 출력            │
│         }                                                       │
│       }                                                         │
│     } finally { X = !1; }              // 실행 상태 재설정     │
│     if (V) C.done();                   // 큐 완료              │
│   };                                                            │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│   return (async () => {                 // 입력 처리 코루틴     │
│     for await (let N of A) {           // 입력 스트림 처리     │
│       let q = /* 메시지 내용 추출 */;    // 메시지 내용 추출    │
│       W.push({ mode: "prompt", value: q }); // 명령 enqueue    │
│       if (!X) E();                     // 실행 엔진 시작       │
│     }                                                           │
│     if (V = !0, !X) C.done();          // 완료 표시            │
│   })(), C;                             // 출력 큐 반환         │
└─────────────────────────────────────────────────────────────────┘
```

### 2.5 실행 계층 - Agent 메인 루프 (nO & Zk2)

#### Agent 컨텍스트 생성
```
파일 위치: improved-claude-code-5.mjs:69025-69105
┌─────────────────────────────────────────────────────────────────┐
│ async function* Zk2({ commands: A, permissionContext: B, ... }) { │
│   // Agent 컨텍스트 생성                                        │
│   let k = {                                                     │
│     messages: _,                                                │
│     options: {                                                  │
│       commands: A, tools: G, verbose: D,                       │
│       mainLoopModel: q, maxThinkingTokens: s$(_),              │
│       mcpClients: Z, isNonInteractiveSession: !0, ...          │
│     },                                                          │
│     abortController: new AbortController,  // 중단 컨트롤러 생성│
│     getToolPermissionContext: () => B, ...                     │
│   };                                                            │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│   // 메인 루프 호출 및 스트리밍 결과 출력                        │
│   for await (let u of nO(i, B, Q, G, I, k, null, Y, W)) {     │
│     yield u;                            // 스트리밍 출력        │
│   }                                                             │
└─────────────────────────────────────────────────────────────────┘
```

#### 메인 Agent 루프 구현
```
파일 위치: improved-claude-code-5.mjs:46187-46300+
┌─────────────────────────────────────────────────────────────────┐
│ async function* nO(A, B, Q, I, G, Z, D, Y, W) {                │
│   yield { type: "stream_request_start" }; // 스트림 시작 마커   │
│   let J = A, F = D;                                             │
│   let { messages: X, wasCompacted: V } = await wU2(A, Z);      │
│   let C = [], K = Z.options.mainLoopModel, E = !0;             │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│   try {                                                         │
│     while (E) {                         // 메인 실행 루프       │
│       E = !1;                                                   │
│       try {                                                     │
│         for await (let _ of wu(         // AI 처리 루프 호출    │
│           Ie1(J, Q), Qe1(B, I), Z.options.maxThinkingTokens,   │
│           Z.options.tools, Z.abortController.signal, {         │
│             getToolPermissionContext: Z.getToolPermissionContext, │
│             model: K, fallbackModel: Y, ...                    │
│           }                                                     │
│         )) {                                                    │
│           if (yield _, _.type === "assistant") C.push(_);      │
│         }                                                       │
│       } catch (_) {                     // 에러 처리 및 모델 다운그레이드│
│         if (_ instanceof wH1 && Y) {    // 모델 다운그레이드 로직│
│           K = Y, E = !0, C.length = 0;  // 상태 재설정 및 재시도│
│           continue;                                             │
│         }                                                       │
│         throw _;                                                │
│       }                                                         │
│     }                                                           │
│   } catch (_) { /* 에러 처리 */ }                              │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│   // 도구 실행 처리                                             │
│   let N = C.flatMap((_) => _.message.content.filter(           │
│     (k) => k.type === "tool_use"       // 도구 사용 추출        │
│   ));                                                           │
│   for await (let _ of hW5(N, C, G, Z)) { // 도구 호출 실행     │
│     if (yield _, _ && _.type === "system" && _.preventContinuation) │
│       O = !0;                          // 계속 진행 차단 여부 확인│
│   }                                                             │
│   if (Z.abortController.signal.aborted) { // 중단 상태 확인    │
│     yield St1({ toolUse: !0, hardcodedMessage: void 0 });     │
│     return;                                                     │
│   }                                                             │
└─────────────────────────────────────────────────────────────────┘
```

### 2.6 AI 처리 계층 - 핵심 AI 호출 (wu 함수)

#### AI 처리 호출 체인
```
추정 위치: improved-claude-code-5.mjs의 wu 함수
┌─────────────────────────────────────────────────────────────────┐
│ async function* wu(messages, context, maxTokens, tools,         │
│                   abortSignal, options) {                      │
│   // 중단 신호 검사                                             │
│   if (abortSignal.aborted) throw new Error("Request aborted"); │
│                                                                 │
│   // AI 요청 구축                                               │
│   let request = buildAIRequest(messages, context, options);    │
│                                                                 │
│   // AI API 호출 및 스트리밍 응답 처리                          │
│   for await (let chunk of callAIAPI(request, abortSignal)) {   │
│     yield processAIChunk(chunk);       // AI 응답 청크 처리     │
│   }                                                             │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 2.7 도구 실행 계층 - 도구 호출 (hW5 함수)

#### 도구 실행 호출 체인
```
추정 위치: improved-claude-code-5.mjs의 hW5 함수
┌─────────────────────────────────────────────────────────────────┐
│ async function* hW5(toolUses, responses, context, agentContext) { │
│   for (let toolUse of toolUses) {      // 도구 사용 순회        │
│     try {                                                       │
│       // 중단 상태 확인                                         │
│       if (agentContext.abortController.signal.aborted) {       │
│         yield createAbortMessage();                             │
│         return;                                                 │
│       }                                                         │
│                                                                 │
│       // 구체적인 도구 실행                                     │
│       let result = await executeTool(toolUse, context);        │
│       yield createToolResult(result);  // 도구 결과 출력        │
│                                                                 │
│     } catch (error) {                                           │
│       yield createErrorResult(error);  // 에러 결과 출력        │
│     }                                                           │
│   }                                                             │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 3. 중단 신호 전파 체인

### 3.1 AbortController 생성 및 전파

```
Agent 컨텍스트 생성 (69070행)
    ↓
abortController: new AbortController()
    ↓
AI 처리로 전달 (46215행)
    ↓
Z.abortController.signal
    ↓
도구 실행으로 전달
    ↓
도구 내부 중단 검사
    ↓
중단 상태 검사 (46270행)
    ↓
if (Z.abortController.signal.aborted)
```

### 3.2 중단 체크포인트 분포

```
┌─────────────────────────────────────────────────────────────────┐
│ 중단 체크포인트1: AI 처리 시작 전                               │
│ 위치: wu 함수 진입점                                            │
│ 검사: abortSignal.aborted                                       │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 중단 체크포인트2: 각 AI 응답 청크 처리                          │
│ 위치: AI API 호출 루프 내                                       │
│ 검사: abortSignal 상태                                          │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 중단 체크포인트3: 도구 실행 전                                  │
│ 위치: 도구 실행 루프 시작                                       │
│ 검사: agentContext.abortController.signal.aborted              │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 중단 체크포인트4: 메인 루프 계속 전                             │
│ 위치: nO 함수 도구 실행 후 (46270행)                           │
│ 검사: Z.abortController.signal.aborted                         │
└─────────────────────────────────────────────────────────────────┘
```

## 4. 에러 처리 및 복구 체인

### 4.1 에러 캡처 레벨

```
┌─────────────────────────────────────────────────────────────────┐
│ 1계층: 입력 파싱 에러                                           │
│ 위치: g2A.processLine (68918-68927행)                          │
│ 처리: console.error + process.exit(1)                          │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 2계층: 큐 작업 에러                                             │
│ 위치: h2A.error 메서드 (68980-68984행)                         │
│ 처리: Promise.reject를 통한 전파                                │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 3계층: 스트리밍 처리 에러                                       │
│ 위치: kq5 실행 엔진의 try-finally (69373-69402행)              │
│ 처리: 상태 재설정 보장                                          │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 4계층: Agent 실행 에러                                          │
│ 위치: nO 메인 루프의 try-catch (46211-46260행)                 │
│ 처리: 모델 다운그레이드 + 에러 결과 생성                        │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 5계층: 도구 실행 에러                                           │
│ 위치: 각 도구의 내부 에러 처리                                  │
│ 처리: 에러 결과 래핑 + 실행 계속                                │
└─────────────────────────────────────────────────────────────────┘
```

## 5. 주요 타이밍 다이어그램

### 5.1 정상 흐름 타이밍

```
타임라인 →

사용자 입력     │ 파서          │ 큐            │ 프로세서      │ Agent        │ AI           │ 도구
────────────────────────────────────────────────────────────────────────────────────────────────────
stdin.data   │               │               │               │              │              │
     ├──────→│ processLine() │               │               │              │              │
             │       ├──────→│ enqueue()     │               │              │              │
             │               │       ├──────→│ executeCommands() │              │              │
             │               │               │       ├──────→│ nO()         │              │
             │               │               │               │      ├──────→│ wu()         │
             │               │               │               │              │      ├──────→│ executeTool()
             │               │               │               │              │              │      ├─→ result
             │               │               │               │              │              │←─────┘
             │               │               │               │              │←─────┘      │
             │               │               │               │←─────┘      │              │
             │               │               │←──────┘       │              │              │
             │               │←──────┘       │               │              │              │
             │←──────┘       │               │               │              │              │
     ←───────┘               │               │               │              │              │
```

### 5.2 중단 흐름 타이밍

```
타임라인 →

사용자 중단     │ AbortController│ Agent        │ AI           │ 도구         │ 출력
────────────────────────────────────────────────────────────────────────────────────
abort()      │               │              │              │              │
     ├──────→│ signal.abort  │              │              │              │
             │       ├──────→│ signal.aborted 확인│      │              │
             │               │      ├──────→│ abort 확인   │              │
             │               │              │      ├──────→│ abort 확인   │
             │               │              │              │      ├──────→│ abort 메시지
             │               │              │              │              │      ├─→ user
             │               │              │              │              │←─────┘
             │               │              │              │←─────┘       │
             │               │              │←─────┘       │              │
             │               │←─────┘       │              │              │
             │←──────┘       │              │              │              │
     ←───────┘               │              │              │              │
```

## 6. 성능 핵심 경로

### 6.1 핫 패스 분석

1. **메시지 enqueue 핫 패스** (최빈 호출):
   ```
   stdin.data → g2A.processLine → h2A.enqueue → (직접 콜백 또는 큐 캐시)
   ```

2. **메시지 dequeue 핫 패스** (최빈 호출):
   ```
   h2A.next → (큐 추출 또는 Promise 대기) → kq5 실행 엔진
   ```

3. **AI 처리 핫 패스** (컴퓨팅 집약):
   ```
   nO 메인 루프 → wu(AI 처리) → 스트리밍 응답 → yield 출력
   ```

### 6.2 병목 식별

1. **잠재적 병목1**: JSON 파싱
   - 위치: g2A.processLine
   - 최적화: 스트리밍 JSON 파싱

2. **잠재적 병목2**: 큐 작업
   - 위치: h2A 큐 작업
   - 최적화: 링 버퍼

3. **잠재적 병목3**: AI API 호출
   - 위치: wu 함수 내부
   - 최적화: 연결 풀 + 캐싱

## 7. 메모리 관리 경로

### 7.1 메모리 할당 지점

```
┌─────────────────────────────────────────────────────────────────┐
│ 할당 지점1: 메시지 큐 버퍼                                      │
│ 위치: h2A.queue.push(A)                                         │
│ 크기: 각 메시지 객체                                            │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 할당 지점2: 명령 큐                                             │
│ 위치: kq5의 W.push({mode: "prompt", value: q})                 │
│ 크기: 명령 객체                                                 │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 할당 지점3: 메시지 히스토리                                     │
│ 위치: kq5의 K.push(O)                                           │
│ 크기: 누적된 메시지 히스토리                                    │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 할당 지점4: Agent 응답                                          │
│ 위치: nO의 C.push(_)                                            │
│ 크기: AI 응답 객체                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 7.2 메모리 해제 지점

```
┌─────────────────────────────────────────────────────────────────┐
│ 해제 지점1: 큐 소비                                             │
│ 위치: h2A.next()의 this.queue.shift()                          │
│ 메커니즘: 자동 가비지 컬렉션                                    │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 해제 지점2: 명령 완료                                           │
│ 위치: kq5의 W.shift()                                           │
│ 메커니즘: 자동 가비지 컬렉션                                    │
└─────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────┐
│ 해제 지점3: 정리 콜백                                           │
│ 위치: h2A.return()의 this.returned()                           │
│ 메커니즘: 수동 정리                                             │
└─────────────────────────────────────────────────────────────────┘
```

## 8. 요약

Claude Code의 실시간 Steering 메커니즘은 정교하게 설계된 다층 호출 체인을 통해 다음을 구현합니다:

1. **비차단 처리**: 각 계층이 비동기 메커니즘을 사용하여 차단 방지
2. **실시간 응답**: 직접 콜백 및 Promise 메커니즘을 통한 저지연 구현
3. **상태 일관성**: 다층 상태 관리를 통한 시스템 일관성 보장
4. **에러 복구**: 계층화된 에러 처리를 통한 우아한 저하
5. **리소스 관리**: 자동 및 수동 정리를 통한 메모리 누수 방지

이 호출 체인 분석은 Claude Code의 기술 구현을 이해하고 오픈소스 재구축을 위한 완전한 기술 청사진을 제공합니다.
