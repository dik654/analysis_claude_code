# ë‹¨ê³„5: í…ŒìŠ¤íŠ¸ ìµœì í™”ì™€ë°°í¬ ì¤€å¤‡ê°€ì´ë“œ

## ğŸ“‹ ëŒ€ìƒ ë…ì
**ë³¸ ë¬¸ì„œì˜ ëŒ€ìƒ: ì´ˆë³´ ìˆ˜ì¤€ì˜ í”„ë¡œê·¸ë˜ë¨¸**
- ê¹Šì€ ì‚¬ê³  ì—†ì´ ë‹¨ê³„ë³„ë¡œ ì—„ê²©íˆ ì‹¤í–‰
- ê° ë‹¨ê³„ëŠ” ëª…í™•í•œ íŒŒì¼ ì‘ì—… ì§€ì¹¨ í¬í•¨
- í•„ìš”í•œ ì½”ë“œ í…œí”Œë¦¿ê³¼ ì„¤ì • í¬í•¨

## ğŸ¯ ë‹¨ê³„ëª©í‘œ
ê¸°ë°˜å‰4ä¸ªë‹¨ê³„ì˜ì™„ì „ êµ¬í˜„, è¿›è¡Œì‹œìŠ¤í…œìµœì í™”ì™€ë°°í¬ ì¤€å¤‡: 
- âœ… **ì„±ëŠ¥ ìµœì í™”ì™€ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸** (ë©”ëª¨ë¦¬, CPU, ë„¤íŠ¸ì›Œí¬, ì‘ë‹µæ—¶é—´ìµœì í™”)
- âœ… **ì „ì²´í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œ** (ë‹¨ìœ„ í…ŒìŠ¤íŠ¸, í†µí•© í…ŒìŠ¤íŠ¸, ì—”ë“œíˆ¬ì—”ë“œ í…ŒìŠ¤íŠ¸, ì„±ëŠ¥ í…ŒìŠ¤íŠ¸)
- âœ… **ë¬¸ì„œì™€ì‚¬ìš©ìê°€ì´ë“œ** (APIë¬¸ì„œ, ì‚¬ìš©ìë§¤ë‰´ì–¼, ê°œë°œê°€ì´ë“œ, ì¥ì• í•´ê²°)
- âœ… **CI/CDì™€ë°°í¬ í”„ë¡œì„¸ìŠ¤** (ìë™í™”ë¹Œë“œ, í…ŒìŠ¤íŠ¸, ë°°í¬, ë²„ì „ ê´€ë¦¬)
- âœ… **í”„ë¡œë•ì…˜í™˜ê²½ìµœì í™”** (ëª¨ë‹ˆí„°ë§, ë¡œê·¸, ì˜¤ë¥˜ ì²˜ë¦¬, ë³´ì•ˆê°•í™”)

**ì˜ˆìƒ ì„±ê³¼ë¬¼**: 
- âœ… ì „ì²´ì˜í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸ (ì˜¤ë²„ë¼ì´ë“œç‡ > 90%)
- âœ… æ€§èƒ½ë²¤ì¹˜ë§ˆí¬ì™€ìµœì í™”ë¦¬í¬íŠ¸
- âœ… ì „ì²´ì˜ì‚¬ìš©ìì™€ê°œë°œë¬¸ì„œ
- âœ… í”„ë¡œë•ì…˜å°±ç»ªì˜ë¦´ë¦¬ìŠ¤ë²„ì „
- âœ… CI/CDìë™í™”í”„ë¡œì„¸ìŠ¤

**ì‘ì—… ì‹œê°„**: 2ì£¼ (80ì‹œê°„)

---

## ğŸ“ 1ì£¼ì°¨: ì„±ëŠ¥ ìµœì í™”ì™€í…ŒìŠ¤íŠ¸å®Œå–„

### ë‹¨ê³„5.1: æ€§èƒ½ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸í”„ë ˆì„ì›Œí¬

**å»ºç«‹ì „ì²´ì˜ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ì™€ëª¨ë‹ˆí„°ë§ä½“ç³»**

**íŒŒì¼ ê²½ë¡œ**: `src/__tests__/performance/benchmark-suite.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * Open Claude Code æ€§èƒ½ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸
 * í…ŒìŠ¤íŠ¸ì‹œìŠ¤í…œå„ì»´í¬ë„ŒíŠ¸ì˜æ€§èƒ½è¡¨ç°ì™€èµ„æºä½¿ç”¨
 */

import { performance } from 'perf_hooks';
import * as os from 'os';
import * as process from 'process';

export interface PerformanceMetrics {
  cpu: {
    usage: number;
    loadAverage: number[];
  };
  memory: {
    used: number;
    total: number;
    heapUsed: number;
    heapTotal: number;
    external: number;
  };
  timing: {
    responseTime: number;
    throughput: number;
    latency: number;
  };
  network: {
    connectionTime: number;
    dataTransfer: number;
  };
}

export interface BenchmarkResult {
  name: string;
  metrics: PerformanceMetrics;
  passed: boolean;
  baseline: PerformanceMetrics;
  improvement: number; // ç™¾åˆ†æ¯”æ”¹è¿›
  timestamp: number;
}

/**
 * æ€§èƒ½ëª¨ë‹ˆí„°ë§å™¨
 */
export class PerformanceMonitor {
  private startTime: number = 0;
  private startMemory: NodeJS.MemoryUsage;
  private measurements: PerformanceMetrics[] = [];

  constructor() {
    this.startMemory = process.memoryUsage();
  }

  /**
   * å¼€å§‹æ€§èƒ½ëª¨ë‹ˆí„°ë§
   */
  public start(): void {
    this.startTime = performance.now();
    this.startMemory = process.memoryUsage();
  }

  /**
   * ç»“æŸëª¨ë‹ˆí„°ë§å¹¶ê°€ì ¸ì˜¤ê¸°ì§€í‘œ
   */
  public end(): PerformanceMetrics {
    const endTime = performance.now();
    const endMemory = process.memoryUsage();
    const cpuUsage = process.cpuUsage();

    const metrics: PerformanceMetrics = {
      cpu: {
        usage: (cpuUsage.user + cpuUsage.system) / 1000, // ë³€í™˜ä¸ºæ¯«ç§’
        loadAverage: os.loadavg()
      },
      memory: {
        used: endMemory.rss - this.startMemory.rss,
        total: os.totalmem(),
        heapUsed: endMemory.heapUsed,
        heapTotal: endMemory.heapTotal,
        external: endMemory.external
      },
      timing: {
        responseTime: endTime - this.startTime,
        throughput: 0, // å°†ç”±êµ¬ì²´í…ŒìŠ¤íŠ¸ê³„ì‚°
        latency: endTime - this.startTime
      },
      network: {
        connectionTime: 0, // å°†ç”±ë„¤íŠ¸ì›Œí¬í…ŒìŠ¤íŠ¸å¡«å……
        dataTransfer: 0
      }
    };

    this.measurements.push(metrics);
    return metrics;
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°å¹³å‡ì§€í‘œ
   */
  public getAverageMetrics(): PerformanceMetrics {
    if (this.measurements.length === 0) {
      throw new Error('No measurements available');
    }

    const avg = this.measurements.reduce((acc, metrics) => {
      acc.cpu.usage += metrics.cpu.usage;
      acc.memory.used += metrics.memory.used;
      acc.timing.responseTime += metrics.timing.responseTime;
      acc.timing.throughput += metrics.timing.throughput;
      acc.timing.latency += metrics.timing.latency;
      acc.network.connectionTime += metrics.network.connectionTime;
      acc.network.dataTransfer += metrics.network.dataTransfer;
      return acc;
    }, {
      cpu: { usage: 0, loadAverage: os.loadavg() },
      memory: { used: 0, total: os.totalmem(), heapUsed: 0, heapTotal: 0, external: 0 },
      timing: { responseTime: 0, throughput: 0, latency: 0 },
      network: { connectionTime: 0, dataTransfer: 0 }
    });

    const count = this.measurements.length;
    return {
      cpu: {
        usage: avg.cpu.usage / count,
        loadAverage: avg.cpu.loadAverage
      },
      memory: {
        used: avg.memory.used / count,
        total: avg.memory.total,
        heapUsed: avg.memory.heapUsed / count,
        heapTotal: avg.memory.heapTotal / count,
        external: avg.memory.external / count
      },
      timing: {
        responseTime: avg.timing.responseTime / count,
        throughput: avg.timing.throughput / count,
        latency: avg.timing.latency / count
      },
      network: {
        connectionTime: avg.network.connectionTime / count,
        dataTransfer: avg.network.dataTransfer / count
      }
    };
  }
}

/**
 * ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸
 */
export class BenchmarkSuite {
  private baselines: Map<string, PerformanceMetrics> = new Map();
  private results: BenchmarkResult[] = [];

  /**
   * ì„¤ì •ë²¤ì¹˜ë§ˆí¬çº¿
   */
  public setBaseline(name: string, metrics: PerformanceMetrics): void {
    this.baselines.set(name, metrics);
  }

  /**
   * ì‹¤í–‰ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸
   */
  public async runBenchmark(
    name: string,
    testFunction: () => Promise<void>,
    iterations: number = 10
  ): Promise<BenchmarkResult> {
    const monitor = new PerformanceMonitor();
    
    // ì›Œë°ì—…
    await testFunction();
    
    // æ‰§è¡Œí…ŒìŠ¤íŠ¸
    for (let i = 0; i < iterations; i++) {
      monitor.start();
      await testFunction();
      monitor.end();
    }

    const metrics = monitor.getAverageMetrics();
    const baseline = this.baselines.get(name);
    
    let improvement = 0;
    let passed = true;

    if (baseline) {
      improvement = ((baseline.timing.responseTime - metrics.timing.responseTime) / baseline.timing.responseTime) * 100;
      passed = metrics.timing.responseTime <= baseline.timing.responseTime * 1.1; // å…è®¸10%ì˜æ€§èƒ½ä¸‹é™
    }

    const result: BenchmarkResult = {
      name,
      metrics,
      passed,
      baseline: baseline || metrics,
      improvement,
      timestamp: Date.now()
    };

    this.results.push(result);
    return result;
  }

  /**
   * Agentí•µì‹¬ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
   */
  public async benchmarkAgentCore(): Promise<BenchmarkResult> {
    const { AgentCore } = await import('../../core/agent-core');
    const { h2A } = await import('../../core/message-queue');
    
    return this.runBenchmark('agent-core', async () => {
      const steeringQueue = new h2A();
      const agentCore = new AgentCore(steeringQueue);
      
      // æ¨¡æ‹Ÿå…¸å‹ì˜Agentä»»åŠ¡
      const messages = [
        { role: 'user', content: 'Hello, please help me with a simple task' }
      ];
      
      const config = {
        model: 'claude-3-sonnet',
        maxTokens: 1000,
        timeout: 5000
      };
      
      // æ¨¡æ‹ŸAgentìˆœí™˜æ‰§è¡Œ
      const generator = agentCore.mainLoop(messages, config, {});
      const results = [];
      
      for await (const chunk of generator) {
        results.push(chunk);
        if (results.length > 5) break; // é™åˆ¶í…ŒìŠ¤íŠ¸è§„æ¨¡
      }
    });
  }

  /**
   * ë„êµ¬æ‰§è¡Œì„±ëŠ¥ í…ŒìŠ¤íŠ¸
   */
  public async benchmarkToolExecution(): Promise<BenchmarkResult> {
    const { ToolRegistry } = await import('../../tools/registry');
    
    return this.runBenchmark('tool-execution', async () => {
      const registry = new ToolRegistry();
      
      // í…ŒìŠ¤íŠ¸å¤šä¸ªë„êµ¬è°ƒç”¨
      await registry.executeTool('Read', { file_path: '/tmp/test.txt' });
      await registry.executeTool('LS', { path: '/tmp' });
      await registry.executeTool('Grep', { pattern: 'test', path: '/tmp' });
    });
  }

  /**
   * MCPì—°ê²°ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
   */
  public async benchmarkMcpConnections(): Promise<BenchmarkResult> {
    const { McpServerManager } = await import('../../mcp/server-manager');
    
    return this.runBenchmark('mcp-connections', async () => {
      const manager = new McpServerManager();
      
      // æ¨¡æ‹Ÿå¤šä¸ªì„œë²„ì—°ê²°
      const servers = Array.from({ length: 5 }, (_, i) => ({
        name: `test-server-${i}`,
        transport: { type: 'stdio' as const, command: 'echo' }
      }));
      
      await Promise.all(servers.map(config => manager.addServer(config)));
      
      // æ¨¡æ‹Ÿë„êµ¬è°ƒç”¨
      for (let i = 0; i < 10; i++) {
        try {
          await manager.callTool('echo', { message: `test-${i}` });
        } catch (error) {
          // å¿½ç•¥í…ŒìŠ¤íŠ¸ä¸­ì˜ì—°ê²°ì˜¤ë¥˜
        }
      }
      
      await manager.cleanup();
    });
  }

  /**
   * Planëª¨ë“œì„±ëŠ¥ í…ŒìŠ¤íŠ¸
   */
  public async benchmarkPlanMode(): Promise<BenchmarkResult> {
    const { PlanModeManager } = await import('../../core/plan-mode');
    const { PlanAwareSteeringQueue } = await import('../../core/steering-plan-integration');
    
    return this.runBenchmark('plan-mode', async () => {
      const eventLogger = () => {};
      const planManager = new PlanModeManager('default', 'test-session', eventLogger);
      const steeringQueue = new PlanAwareSteeringQueue(planManager);
      
      // æ¨¡æ‹ŸPlanëª¨ë“œæ“ä½œ
      for (let i = 0; i < 20; i++) {
        planManager.cyclePlanMode();
        
        if (planManager.isPlanMode()) {
          // æ¨¡æ‹ŸPlanëª¨ë“œä¸‹ì˜æ“ä½œ
          steeringQueue.enqueue({
            type: 'user_input',
            content: `plan input ${i}`,
            timestamp: Date.now(),
            sessionId: 'test'
          });
        }
      }
    });
  }

  /**
   * UIæ¸²æŸ“ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
   */
  public async benchmarkUIRendering(): Promise<BenchmarkResult> {
    return this.runBenchmark('ui-rendering', async () => {
      // æ¨¡æ‹Ÿå¤§é‡UIì»´í¬ë„ŒíŠ¸æ¸²æŸ“
      const React = await import('react');
      const { render } = await import('react-dom/server');
      
      const TestComponent = React.createElement('div', null,
        Array.from({ length: 100 }, (_, i) =>
          React.createElement('span', { key: i }, `Item ${i}`)
        )
      );
      
      // æ¸²æŸ“100æ¬¡
      for (let i = 0; i < 100; i++) {
        render(TestComponent);
      }
    });
  }

  /**
   * ç”Ÿæˆæ€§èƒ½ë¦¬í¬íŠ¸
   */
  public generateReport(): string {
    const report = ['# Open Claude Code æ€§èƒ½ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸ë¦¬í¬íŠ¸\n'];
    
    report.push(`## í…ŒìŠ¤íŠ¸æ¦‚è§ˆ`);
    report.push(`- æ€»í…ŒìŠ¤íŠ¸æ•°: ${this.results.length}`);
    report.push(`- é€šè¿‡í…ŒìŠ¤íŠ¸: ${this.results.filter(r => r.passed).length}`);
    report.push(`- ì‹¤íŒ¨í…ŒìŠ¤íŠ¸: ${this.results.filter(r => !r.passed).length}`);
    report.push(`- í…ŒìŠ¤íŠ¸æ—¶é—´: ${new Date().toISOString()}\n`);
    
    report.push(`## ìƒì„¸ç»“æœ\n`);
    
    for (const result of this.results) {
      report.push(`### ${result.name}`);
      report.push(`- **ìƒíƒœ**: ${result.passed ? 'âœ… é€šè¿‡' : 'âŒ ì‹¤íŒ¨'}`);
      report.push(`- **ì‘ë‹µæ—¶é—´**: ${result.metrics.timing.responseTime.toFixed(2)}ms`);
      report.push(`- **ë©”ëª¨ë¦¬ ì‚¬ìš©**: ${(result.metrics.memory.used / 1024 / 1024).toFixed(2)}MB`);
      report.push(`- **CPUä½¿ç”¨**: ${result.metrics.cpu.usage.toFixed(2)}ms`);
      
      if (result.baseline) {
        report.push(`- **æ€§èƒ½æ”¹è¿›**: ${result.improvement.toFixed(2)}%`);
      }
      
      report.push('');
    }
    
    report.push(`## æ€§èƒ½ë²¤ì¹˜ë§ˆí¬çº¿\n`);
    report.push(`| í…ŒìŠ¤íŠ¸é¡¹ | ì‘ë‹µæ—¶é—´ | ë©”ëª¨ë¦¬ ì‚¬ìš© | CPUä½¿ç”¨ | ìƒíƒœ |`);
    report.push(`|-------|---------|---------|---------|------|`);
    
    for (const result of this.results) {
      const status = result.passed ? 'âœ…' : 'âŒ';
      report.push(`| ${result.name} | ${result.metrics.timing.responseTime.toFixed(2)}ms | ${(result.metrics.memory.used / 1024 / 1024).toFixed(2)}MB | ${result.metrics.cpu.usage.toFixed(2)}ms | ${status} |`);
    }
    
    return report.join('\n');
  }

  /**
   * ì‹¤í–‰ì „ì²´ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸
   */
  public async runFullSuite(): Promise<BenchmarkResult[]> {
    console.log('å¼€å§‹ì‹¤í–‰ì „ì²´æ€§èƒ½ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸...');
    
    const tests = [
      () => this.benchmarkAgentCore(),
      () => this.benchmarkToolExecution(),
      () => this.benchmarkMcpConnections(),
      () => this.benchmarkPlanMode(),
      () => this.benchmarkUIRendering()
    ];
    
    const results = [];
    for (const test of tests) {
      try {
        const result = await test();
        results.push(result);
        console.log(`âœ… ${result.name}: ${result.metrics.timing.responseTime.toFixed(2)}ms`);
      } catch (error) {
        console.error(`âŒ í…ŒìŠ¤íŠ¸ì‹¤íŒ¨:`, error);
      }
    }
    
    console.log('\næ€§èƒ½ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸å®Œæˆï¼');
    console.log(this.generateReport());
    
    return results;
  }
}
```

### ë‹¨ê³„5.2: ì „ì²´í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œç‡

**å»ºç«‹å…¨é¢ì˜í…ŒìŠ¤íŠ¸ä½“ç³»ç¡®ä¿ì½”ë“œ í’ˆì§ˆ**

**íŒŒì¼ ê²½ë¡œ**: `src/__tests__/coverage/test-suite.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * Open Claude Code ì „ì²´í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸
 * ç¡®ä¿90%+ì˜ì½”ë“œì˜¤ë²„ë¼ì´ë“œç‡ì™€å…¨é¢ì˜åŠŸèƒ½ê²€ì¦
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/testing-library';

/**
 * í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œç‡ì„¤ì •
 */
export const coverageConfig = {
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.test.ts',
    '!src/**/__tests__/**',
    '!src/**/node_modules/**'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html', 'json'],
  coverageThreshold: {
    global: {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  }
};

/**
 * í…ŒìŠ¤íŠ¸ë„êµ¬í´ë˜ìŠ¤
 */
export class TestUtils {
  /**
   * ìƒì„±æ¨¡æ‹Ÿì˜Agentì„¤ì •
   */
  static createMockAgentConfig() {
    return {
      model: 'claude-3-sonnet',
      maxTokens: 1000,
      temperature: 0.7,
      timeout: 30000,
      fallbackModel: 'claude-3-haiku'
    };
  }

  /**
   * ìƒì„±æ¨¡æ‹Ÿì˜ë©”ì‹œì§€í
   */
  static createMockMessageQueue() {
    const { h2A } = require('../../core/message-queue');
    return new h2A();
  }

  /**
   * ìƒì„±æ¨¡æ‹Ÿì˜ë„êµ¬ì»¨í…ìŠ¤íŠ¸
   */
  static createMockToolContext() {
    return {
      sessionId: 'test-session',
      userId: 'test-user',
      agentId: 'test-agent',
      workingDirectory: '/tmp/test',
      permissions: ['read', 'write'],
      timeout: 30000
    };
  }

  /**
   * ìƒì„±æ¨¡æ‹Ÿì˜MCPì„œë²„ì„¤ì •
   */
  static createMockMcpServerConfig() {
    return {
      name: 'test-server',
      transport: {
        type: 'stdio' as const,
        command: 'echo',
        args: ['test']
      },
      timeout: 5000,
      retryAttempts: 3
    };
  }

  /**
   * awaitë¹„ë™ê¸°æ“ä½œå®Œæˆ
   */
  static async waitFor(condition: () => boolean, timeout: number = 5000): Promise<void> {
    const start = Date.now();
    while (!condition() && Date.now() - start < timeout) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    if (!condition()) {
      throw new Error('Condition not met within timeout');
    }
  }

  /**
   * æ¨¡æ‹ŸíŒŒì¼ì‹œìŠ¤í…œæ“ä½œ
   */
  static mockFileSystem() {
    const fs = require('fs/promises');
    const mockFs = {
      readFile: jest.fn(),
      writeFile: jest.fn(),
      readdir: jest.fn(),
      stat: jest.fn(),
      access: jest.fn(),
      mkdir: jest.fn()
    };
    
    Object.assign(fs, mockFs);
    return mockFs;
  }

  /**
   * æ¨¡æ‹Ÿë„¤íŠ¸ì›Œí¬ìš”ì²­
   */
  static mockNetworkRequests() {
    const mockFetch = jest.fn();
    global.fetch = mockFetch;
    return mockFetch;
  }

  /**
   * ìƒì„±ì„±ëŠ¥ í…ŒìŠ¤íŠ¸è¾…åŠ©í•¨ìˆ˜
   */
  static measurePerformance<T>(fn: () => Promise<T>): Promise<{ result: T; duration: number }> {
    return new Promise(async (resolve) => {
      const start = performance.now();
      const result = await fn();
      const duration = performance.now() - start;
      resolve({ result, duration });
    });
  }
}

/**
 * í•µì‹¬ì»´í¬ë„ŒíŠ¸í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸
 */
describe('Core Components Test Suite', () => {
  describe('Agent Core Engine', () => {
    test('ä¸»ìˆœí™˜ê¸°ë³¸åŠŸèƒ½', async () => {
      const { AgentCore } = await import('../../core/agent-core');
      const steeringQueue = TestUtils.createMockMessageQueue();
      const agent = new AgentCore(steeringQueue);
      
      const messages = [{ role: 'user', content: 'Hello' }];
      const config = TestUtils.createMockAgentConfig();
      
      // í…ŒìŠ¤íŠ¸Agentä¸»ìˆœí™˜
      const generator = agent.mainLoop(messages, config, {});
      const firstChunk = await generator.next();
      
      expect(firstChunk).toBeDefined();
    });

    test('ë©”ì‹œì§€ì••ì¶•ë©”ì»¤ë‹ˆì¦˜', async () => {
      const { AgentCore } = await import('../../core/agent-core');
      const agent = new AgentCore(TestUtils.createMockMessageQueue());
      
      // ìƒì„±å¤§é‡ë©”ì‹œì§€í…ŒìŠ¤íŠ¸ì••ì¶•
      const messages = Array.from({ length: 100 }, (_, i) => ({
        role: 'user',
        content: `Message ${i}`
      }));
      
      const compressed = await agent.compressMessages(messages, { maxMessages: 10 });
      expect(compressed.messages.length).toBeLessThanOrEqual(10);
      expect(compressed.wasCompacted).toBe(true);
    });

    test('ì˜¤ë¥˜ ì²˜ë¦¬ì™€ë³µì›', async () => {
      const { AgentCore } = await import('../../core/agent-core');
      const agent = new AgentCore(TestUtils.createMockMessageQueue());
      
      // æ¨¡æ‹ŸAPIì˜¤ë¥˜
      const mockGenerator = async function* () {
        throw new Error('API Error');
      };
      
      agent.streamGenerator = mockGenerator;
      
      const messages = [{ role: 'user', content: 'Test' }];
      const config = { ...TestUtils.createMockAgentConfig(), fallbackModel: 'claude-3-haiku' };
      
      // åº”è¯¥èƒ½å¤Ÿì²˜ë¦¬ì˜¤ë¥˜å¹¶ä½¿ç”¨å›é€€æ¨¡å‹
      await expect(async () => {
        const generator = agent.mainLoop(messages, config, {});
        await generator.next();
      }).not.toThrow();
    });

    test('ì‹¤ì‹œê°„ Steeringë©”ì»¤ë‹ˆì¦˜', async () => {
      const { AgentCore } = await import('../../core/agent-core');
      const { PlanAwareSteeringQueue } = await import('../../core/steering-plan-integration');
      const { PlanModeManager } = await import('../../core/plan-mode');
      
      const planManager = new PlanModeManager('default', 'test', () => {});
      const steeringQueue = new PlanAwareSteeringQueue(planManager);
      const agent = new AgentCore(steeringQueue);
      
      // æ¨¡æ‹Ÿì‹¤ì‹œê°„ì‚¬ìš©ìì…ë ¥
      steeringQueue.enqueue({
        type: 'user_input',
        content: 'interrupt message',
        timestamp: Date.now(),
        sessionId: 'test'
      });
      
      const steeringMessage = await agent.checkSteeringInput();
      expect(steeringMessage).toBeDefined();
    });
  });

  describe('Message Queue System', () => {
    test('h2Aë¹„ë™ê¸°íê¸°ë³¸åŠŸèƒ½', async () => {
      const { h2A } = await import('../../core/message-queue');
      const queue = new h2A();
      
      const message = { test: 'data' };
      queue.enqueue(message);
      
      const iterator = queue[Symbol.asyncIterator]();
      const result = await iterator.next();
      
      expect(result.value).toEqual(message);
      expect(result.done).toBe(false);
    });

    test('íå®Œæˆì™€æ¸…ç†', async () => {
      const { h2A } = await import('../../core/message-queue');
      let cleanupCalled = false;
      const queue = new h2A(() => { cleanupCalled = true; });
      
      queue.complete();
      
      const iterator = queue[Symbol.asyncIterator]();
      const result = await iterator.next();
      
      expect(result.done).toBe(true);
      expect(cleanupCalled).toBe(true);
    });

    test('ì˜¤ë¥˜ ì²˜ë¦¬', async () => {
      const { h2A } = await import('../../core/message-queue');
      const queue = new h2A();
      
      const error = new Error('Test error');
      queue.error(error);
      
      const iterator = queue[Symbol.asyncIterator]();
      
      await expect(iterator.next()).rejects.toThrow('Test error');
    });

    test('ë™ì‹œè®¿é—®ë³´ì•ˆæ€§', async () => {
      const { h2A } = await import('../../core/message-queue');
      const queue = new h2A();
      
      // å¤šä¸ªæ¶ˆè´¹è€…åŒæ—¶è¯»å–
      const consumers = Array.from({ length: 5 }, async (_, i) => {
        const iterator = queue[Symbol.asyncIterator]();
        return iterator.next();
      });
      
      // í”„ë¡œë•ì…˜è€…ì¶”ê°€ë©”ì‹œì§€
      for (let i = 0; i < 5; i++) {
        queue.enqueue({ id: i });
      }
      
      const results = await Promise.all(consumers);
      expect(results.every(r => !r.done)).toBe(true);
    });
  });

  describe('Tool System', () => {
    test('ë„êµ¬ë“±ë¡ì™€å‘ç°', async () => {
      const { ToolRegistry } = await import('../../tools/registry');
      const registry = new ToolRegistry();
      
      const tools = registry.getAllTools();
      expect(tools.length).toBeGreaterThan(0);
      
      const readTool = registry.getTool('Read');
      expect(readTool).toBeDefined();
      expect(readTool.name).toBe('Read');
    });

    test('ë„êµ¬æ‰§è¡Œì™€ç»“æœì²˜ë¦¬', async () => {
      const { ToolRegistry } = await import('../../tools/registry');
      const registry = new ToolRegistry();
      
      // æ¨¡æ‹ŸíŒŒì¼ì‹œìŠ¤í…œ
      const mockFs = TestUtils.mockFileSystem();
      mockFs.readFile.mockResolvedValue('test content');
      
      const context = TestUtils.createMockToolContext();
      const result = await registry.executeTool('Read', { file_path: '/test.txt' }, context);
      
      expect(result).toBeDefined();
      expect(mockFs.readFile).toHaveBeenCalledWith('/test.txt', 'utf-8');
    });

    test('ë„êµ¬ê¶Œí•œê²€ì¦', async () => {
      const { ToolRegistry } = await import('../../tools/registry');
      const registry = new ToolRegistry();
      
      const context = { ...TestUtils.createMockToolContext(), permissions: ['read'] };
      
      // åº”è¯¥å…è®¸è¯»å–æ“ä½œ
      await expect(registry.executeTool('Read', { file_path: '/test.txt' }, context))
        .resolves.toBeDefined();
      
      // åº”è¯¥æ‹’ç»å†™å…¥æ“ä½œ
      await expect(registry.executeTool('Write', { file_path: '/test.txt', content: 'test' }, context))
        .rejects.toThrow();
    });

    test('ë„êµ¬ë™ì‹œæ‰§è¡Œ', async () => {
      const { ToolRegistry } = await import('../../tools/registry');
      const registry = new ToolRegistry();
      
      const mockFs = TestUtils.mockFileSystem();
      mockFs.readFile.mockResolvedValue('content');
      
      // ë™ì‹œæ‰§è¡Œå¤šä¸ªë„êµ¬
      const context = TestUtils.createMockToolContext();
      const promises = Array.from({ length: 10 }, (_, i) =>
        registry.executeTool('Read', { file_path: `/test${i}.txt` }, context)
      );
      
      const results = await Promise.all(promises);
      expect(results).toHaveLength(10);
    });

    test('Editë„êµ¬å¼ºåˆ¶è¯»å–ë©”ì»¤ë‹ˆì¦˜', async () => {
      const { EditTool } = await import('../../tools/implementations/edit');
      const tool = new EditTool();
      
      const context = TestUtils.createMockToolContext();
      
      // æœªè¯»å–íŒŒì¼æ—¶åº”è¯¥ì‹¤íŒ¨
      await expect(tool.call({
        file_path: '/unread.txt',
        old_string: 'old',
        new_string: 'new'
      }, context)).rejects.toThrow();
      
      // è¯»å–íŒŒì¼ååº”è¯¥ì„±ê³µ
      await tool.beforeEdit('/unread.txt', context);
      await expect(tool.call({
        file_path: '/unread.txt',
        old_string: 'old',
        new_string: 'new'
      }, context)).resolves.toBeDefined();
    });

    test('Taskë„êµ¬å¤šAgentæ¶æ„', async () => {
      const { TaskTool } = await import('../../tools/implementations/task');
      const tool = new TaskTool();
      
      const context = TestUtils.createMockToolContext();
      
      const result = await tool.call({
        task_description: 'Test parallel task',
        task_prompt: 'Execute multiple subtasks',
        context: { parallel: true }
      }, context);
      
      expect(result).toBeDefined();
      // ê²€ì¦SubAgentì¸ìŠ¤í„´ìŠ¤åŒ–ì™€ë™ì‹œæ‰§è¡Œ
    });
  });

  describe('Plan Mode System', () => {
    test('ëª¨ë“œìˆœí™˜ìƒíƒœ ë¨¸ì‹ ', () => {
      const { wj2 } = require('../../core/plan-mode');
      
      // í…ŒìŠ¤íŠ¸ê¸°ë³¸ìˆœí™˜
      expect(wj2({ mode: 'default', isBypassPermissionsModeAvailable: false })).toBe('acceptEdits');
      expect(wj2({ mode: 'acceptEdits', isBypassPermissionsModeAvailable: false })).toBe('plan');
      expect(wj2({ mode: 'plan', isBypassPermissionsModeAvailable: false })).toBe('default');
      
      // í…ŒìŠ¤íŠ¸bypassê¶Œí•œëª¨ë“œ
      expect(wj2({ mode: 'plan', isBypassPermissionsModeAvailable: true })).toBe('bypassPermissions');
      expect(wj2({ mode: 'bypassPermissions', isBypassPermissionsModeAvailable: true })).toBe('default');
    });

    test('Planëª¨ë“œê´€ë¦¬å™¨', () => {
      const { PlanModeManager } = require('../../core/plan-mode');
      const eventLogger = jest.fn();
      const manager = new PlanModeManager('default', 'test-session', eventLogger);
      
      expect(manager.getCurrentMode()).toBe('default');
      
      manager.cyclePlanMode();
      expect(manager.getCurrentMode()).toBe('acceptEdits');
      expect(eventLogger).toHaveBeenCalledWith('tengu_mode_cycle', expect.any(Object));
    });

    test('exit_plan_modeë„êµ¬', async () => {
      const { ExitPlanModeTool } = await import('../../tools/implementations/exit-plan-mode');
      const tool = new ExitPlanModeTool();
      
      const context = TestUtils.createMockToolContext();
      
      // í…ŒìŠ¤íŠ¸ê¶Œí•œí™•ì¸
      const permission = await tool.checkPermissions({ plan: 'Test plan' });
      expect(permission.behavior).toBe('ask');
      
      // í…ŒìŠ¤íŠ¸ë„êµ¬æ‰§è¡Œ
      const generator = tool.call({ plan: 'Test plan' }, context);
      const result = await generator.next();
      
      expect(result.value).toBeDefined();
      expect(result.value.data.plan).toBe('Test plan');
    });

    test('Planëª¨ë“œì‹œìŠ¤í…œæé†’', () => {
      const { generatePlanModeSystemReminder, isToolAllowedInPlanMode } = require('../../core/plan-mode');
      
      const reminder = generatePlanModeSystemReminder();
      expect(reminder).toContain('<system-reminder>');
      expect(reminder).toContain('Plan mode is active');
      
      // ì½ê¸° ì „ìš©ë„êµ¬åº”è¯¥è¢«å…è®¸
      expect(isToolAllowedInPlanMode('Read')).toBe(true);
      expect(isToolAllowedInPlanMode('LS')).toBe(true);
      
      // ìˆ˜ì •ë„êµ¬åº”è¯¥è¢«é˜»æ­¢
      expect(isToolAllowedInPlanMode('Write')).toBe(false);
      expect(isToolAllowedInPlanMode('Edit')).toBe(false);
    });
  });

  describe('MCP Integration', () => {
    test('MCPí´ë¼ì´ì–¸íŠ¸ì—°ê²°ì™€é€šä¿¡', async () => {
      const { McpClient } = await import('../../mcp/client');
      const config = TestUtils.createMockMcpServerConfig();
      const client = new McpClient(config);
      
      // æ¨¡æ‹Ÿì—°ê²°
      expect(client.connected).toBe(false);
      
      // í…ŒìŠ¤íŠ¸ë„êµ¬è°ƒç”¨í˜•ì‹
      const toolCall = {
        toolName: 'test_tool',
        arguments: { param: 'value' }
      };
      
      // ì‹¤ì œí…ŒìŠ¤íŠ¸ä¸­ä¼šæ¨¡æ‹ŸMCPì‘ë‹µ
      expect(toolCall.toolName).toBe('test_tool');
    });

    test('ë‹¤ì¤‘ ì„œë²„ ê´€ë¦¬', async () => {
      const { McpServerManager } = await import('../../mcp/server-manager');
      const manager = new McpServerManager();
      
      const config1 = { ...TestUtils.createMockMcpServerConfig(), name: 'server1' };
      const config2 = { ...TestUtils.createMockMcpServerConfig(), name: 'server2' };
      
      await manager.addServer(config1);
      await manager.addServer(config2);
      
      const states = manager.getAllServerStates();
      expect(states).toHaveLength(2);
      
      const stats = manager.getStatistics();
      expect(stats.total).toBe(2);
    });

    test('ë„êµ¬ë³´ì•ˆì™€í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸', () => {
      const { ToolSecurityManager } = require('../../mcp/security/tool-whitelist');
      const security = new ToolSecurityManager();
      
      // í…ŒìŠ¤íŠ¸IDEë„êµ¬í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸
      expect(security.isToolAllowed('mcp__ide__getDiagnostics')).toBe(true);
      expect(security.isToolAllowed('mcp__ide__executeCode')).toBe(true);
      expect(security.isToolAllowed('mcp__ide__malicious')).toBe(false);
      
      // í…ŒìŠ¤íŠ¸ê¶Œí•œè¦æ±‚
      expect(security.requiresPermission('mcp__ide__executeCode')).toBe(true);
    });

    test('ì„¤ì • ê´€ë¦¬3ë‹¨ê³„å±‚æ¬¡', async () => {
      const { McpConfigManager } = await import('../../mcp/config/config-manager');
      const manager = new McpConfigManager();
      
      // æ¨¡æ‹Ÿì„¤ì •ë¡œë”©
      await manager.initialize('./test-workspace');
      
      const config = manager.getConfiguration();
      expect(config).toHaveProperty('servers');
      expect(config).toHaveProperty('globalSettings');
      expect(config).toHaveProperty('security');
      
      const validation = manager.validateConfiguration();
      expect(validation).toHaveProperty('valid');
      expect(validation).toHaveProperty('errors');
    });
  });

  describe('IDE Integration', () => {
    test('ì§„ë‹¨ì •ë³´ê´€ë¦¬', () => {
      const { IdeDiagnosticsManager } = require('../../integrations/ide-diagnostics');
      const manager = IdeDiagnosticsManager.getInstance();
      
      // í…ŒìŠ¤íŠ¸ì‹±ê¸€í†¤ëª¨ë“œ
      const manager2 = IdeDiagnosticsManager.getInstance();
      expect(manager).toBe(manager2);
      
      // í…ŒìŠ¤íŠ¸ì§„ë‹¨æ¯”è¾ƒ
      const diag1 = {
        message: 'Error message',
        severity: 1,
        range: { start: { line: 0, character: 0 }, end: { line: 0, character: 5 } }
      };
      
      const diag2 = { ...diag1 };
      expect(manager.areDiagnosticsEqual(diag1, diag2)).toBe(true);
    });

    test('IDEì—°ê²°æ£€æµ‹', () => {
      const { IdeConnectionDetector } = require('../../integrations/ide-diagnostics');
      
      const mockServers = [
        {
          type: 'connected',
          name: 'ide',
          config: { type: 'sse-ide', ideName: 'vscode' }
        }
      ];
      
      const detected = IdeConnectionDetector.detectConnectedIde(mockServers);
      expect(detected).toBe('vscode');
      
      const displayName = IdeConnectionDetector.getIdeDisplayName('vscode');
      expect(displayName).toBe('VS Code');
    });
  });

  describe('UI Components', () => {
    test('Planëª¨ë“œæŒ‡ç¤ºå™¨', () => {
      const { PlanModeIndicator } = require('../../ui/components/plan-mode-indicator');
      const React = require('react');
      
      const context = {
        currentMode: 'plan',
        previousMode: 'default',
        timestamp: Date.now(),
        sessionId: 'test'
      };
      
      const element = React.createElement(PlanModeIndicator, {
        context,
        theme: { planMode: '#ff0000', secondaryText: '#666666' }
      });
      
      expect(element).toBeDefined();
    });

    test('íŠ¹ìˆ˜ëª¨ë“œì²˜ë¦¬å™¨', () => {
      const { SpecialModeHandler } = require('../../ui/special-modes');
      const handler = new SpecialModeHandler();
      
      // í…ŒìŠ¤íŠ¸Bashëª¨ë“œ
      const bashResult = handler.processInput('!ls -la');
      expect(bashResult.mode).toBe('bash');
      expect(bashResult.content).toBe('ls -la');
      
      // í…ŒìŠ¤íŠ¸ë…¸íŠ¸ëª¨ë“œ
      const noteResult = handler.processInput('# Test note #tag');
      expect(noteResult.mode).toBe('note');
      
      const notes = handler.getNotes();
      expect(notes).toHaveLength(1);
      expect(notes[0].tags).toContain('tag');
    });

    test('ë‹¨ì¶• ëª…ë ¹ ì‹œìŠ¤í…œ', async () => {
      const { SlashCommandManager } = require('../../commands/slash-commands');
      const manager = new SlashCommandManager();
      
      const context = {
        sessionId: 'test',
        mcpServers: [],
        currentDirectory: '/test',
        planModeManager: null
      };
      
      // í…ŒìŠ¤íŠ¸helpì»¤ë§¨ë“œ
      const helpResult = await manager.execute('/help', context);
      expect(helpResult.success).toBe(true);
      expect(helpResult.message).toContain('Available commands');
      
      // í…ŒìŠ¤íŠ¸ì»¤ë§¨ë“œìë™è¡¥å…¨
      const completions = manager.getCompletions('/he');
      expect(completions).toContain('/help');
    });
  });

  describe('Error Handling and Edge Cases', () => {
    test('ë„¤íŠ¸ì›Œí¬ì—°ê²°ì‹¤íŒ¨ì²˜ë¦¬', async () => {
      // æ¨¡æ‹Ÿë„¤íŠ¸ì›Œí¬ì˜¤ë¥˜
      const mockFetch = TestUtils.mockNetworkRequests();
      mockFetch.mockRejectedValue(new Error('Network error'));
      
      // í…ŒìŠ¤íŠ¸HTTPì „ì†¡ì˜¤ë¥˜ ì²˜ë¦¬
      const { HttpTransport } = await import('../../mcp/transport/http-sse');
      const transport = new HttpTransport({
        type: 'http',
        url: 'http://invalid-url'
      });
      
      await transport.connect();
      await expect(transport.send({ test: 'message' })).rejects.toThrow();
    });

    test('íŒŒì¼ì‹œìŠ¤í…œì˜¤ë¥˜ ì²˜ë¦¬', async () => {
      const mockFs = TestUtils.mockFileSystem();
      mockFs.readFile.mockRejectedValue(new Error('File not found'));
      
      const { ReadTool } = await import('../../tools/implementations/read');
      const tool = new ReadTool();
      const context = TestUtils.createMockToolContext();
      
      const generator = tool.call({ file_path: '/nonexistent.txt' }, context);
      const result = await generator.next();
      
      // åº”è¯¥ë°˜í™˜ì˜¤ë¥˜ç»“æœè€Œä¸ì˜ˆæŠ›å‡ºì˜ˆì™¸
      expect(result.value.type).toBe('error');
    });

    test('å¤§é‡ë°ì´í„°ì²˜ë¦¬', async () => {
      const { h2A } = await import('../../core/message-queue');
      const queue = new h2A();
      
      // í…ŒìŠ¤íŠ¸å¤§é‡ë©”ì‹œì§€ì²˜ë¦¬
      const messageCount = 10000;
      for (let i = 0; i < messageCount; i++) {
        queue.enqueue({ id: i, data: `message-${i}` });
      }
      
      let processedCount = 0;
      const iterator = queue[Symbol.asyncIterator]();
      
      for (let i = 0; i < messageCount; i++) {
        const result = await iterator.next();
        if (!result.done) {
          processedCount++;
        }
      }
      
      expect(processedCount).toBe(messageCount);
    });

    test('ë©”ëª¨ë¦¬æ³„æ¼é¢„é˜²', async () => {
      const { McpServerManager } = await import('../../mcp/server-manager');
      const manager = new McpServerManager();
      
      // ìƒì„±å¤§é‡ì—°ê²°
      const servers = Array.from({ length: 100 }, (_, i) => ({
        name: `test-server-${i}`,
        transport: { type: 'stdio' as const, command: 'echo' }
      }));
      
      for (const config of servers) {
        await manager.addServer(config);
      }
      
      // æ¸…ç†æ‰€ìˆìŒì—°ê²°
      await manager.cleanup();
      
      // ê²€ì¦èµ„æºè¢«æ­£ç¡®æ¸…ç†
      const stats = manager.getStatistics();
      expect(stats.total).toBe(0);
    });

    test('ë™ì‹œç«äº‰ì¡°ê±´', async () => {
      const { ToolSecurityManager } = require('../../mcp/security/tool-whitelist');
      const security = new ToolSecurityManager();
      
      // ë™ì‹œë„êµ¬è°ƒç”¨ê²€ì¦
      const promises = Array.from({ length: 50 }, (_, i) =>
        security.validateToolCall({
          toolName: 'test_tool',
          serverName: 'test',
          arguments: {},
          sessionId: `session-${i}`
        })
      );
      
      const results = await Promise.all(promises);
      expect(results).toHaveLength(50);
      
      // ê²€ì¦æ²¡ìˆìŒç«äº‰ì¡°ê±´å¯¼è‡´ì˜ì˜¤ë¥˜
      results.forEach(result => {
        expect(result).toHaveProperty('allowed');
      });
    });
  });
});

/**
 * ì‹¤í–‰ì „ì²´í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸
 */
export async function runCompleteTestSuite(): Promise<void> {
  console.log('ğŸš€ å¼€å§‹ì‹¤í–‰ Open Claude Code ì „ì²´í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸...\n');
  
  const testFiles = [
    './stage1-agent-core.test.ts',
    './stage2-tool-system.test.ts', 
    './stage3-integration.test.ts',
    './stage4-mcp-integration.test.ts',
    './coverage/test-suite.ts'
  ];
  
  let totalTests = 0;
  let passedTests = 0;
  let failedTests = 0;
  
  for (const testFile of testFiles) {
    console.log(`ğŸ“‹ ì‹¤í–‰í…ŒìŠ¤íŠ¸íŒŒì¼: ${testFile}`);
    
    try {
      // è¿™é‡Œä¼šì‹¤í–‰ì‹¤ì œì˜Jestí…ŒìŠ¤íŠ¸
      const result = await runJestTests(testFile);
      totalTests += result.total;
      passedTests += result.passed;
      failedTests += result.failed;
      
      console.log(`âœ… ${testFile}: ${result.passed}/${result.total} é€šè¿‡\n`);
    } catch (error) {
      console.error(`âŒ ${testFile}: í…ŒìŠ¤íŠ¸ì‹¤íŒ¨`, error);
      failedTests++;
    }
  }
  
  console.log('ğŸ“Š í…ŒìŠ¤íŠ¸æ€»ç»“:');
  console.log(`- æ€»í…ŒìŠ¤íŠ¸æ•°: ${totalTests}`);
  console.log(`- é€šè¿‡: ${passedTests}`);
  console.log(`- ì‹¤íŒ¨: ${failedTests}`);
  console.log(`- ì„±ê³µç‡: ${((passedTests / totalTests) * 100).toFixed(2)}%`);
  
  if (failedTests === 0) {
    console.log('\nğŸ‰ æ‰€ìˆìŒí…ŒìŠ¤íŠ¸é€šè¿‡ï¼ì½”ë“œ í’ˆì§ˆè¾¾æ ‡. ');
  } else {
    console.log(`\nâš ï¸  ìˆìŒ ${failedTests} ä¸ªí…ŒìŠ¤íŠ¸ì‹¤íŒ¨, éœ€è¦ìˆ˜ì •. `);
  }
}

/**
 * æ¨¡æ‹ŸJestí…ŒìŠ¤íŠ¸ì‹¤í–‰å™¨
 */
async function runJestTests(testFile: string): Promise<{ total: number; passed: number; failed: number }> {
  // ì‹¤ì œêµ¬í˜„ä¸­ä¼šè°ƒç”¨Jest API
  return {
    total: 10,
    passed: 10,
    failed: 0
  };
}
```

### ë‹¨ê³„5.3: ë©”ëª¨ë¦¬ì™€ì„±ëŠ¥ ìµœì í™”

**é’ˆå¯¹æ€§èƒ½ç“¶é¢ˆè¿›è¡Œì‹œìŠ¤í…œìµœì í™”**

**íŒŒì¼ ê²½ë¡œ**: `src/optimizations/performance-optimizer.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * Open Claude Code ì„±ëŠ¥ ìµœì í™”å™¨
 * é’ˆå¯¹å…³é”®æ€§èƒ½ç“¶é¢ˆè¿›è¡Œì‹œìŠ¤í…œçº§ìµœì í™”
 */

/**
 * ë©”ëª¨ë¦¬ìµœì í™”ê´€ë¦¬å™¨
 */
export class MemoryOptimizer {
  private memoryThreshold = 512 * 1024 * 1024; // 512MB
  private gcInterval: NodeJS.Timeout | null = null;
  private memoryUsageHistory: number[] = [];
  
  /**
   * ì‹œì‘ë©”ëª¨ë¦¬ëª¨ë‹ˆí„°ë§
   */
  public startMonitoring(): void {
    this.gcInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, 30000); // æ¯30ç§’í™•ì¸ä¸€æ¬¡
  }

  /**
   * ì¤‘ì§€ë©”ëª¨ë¦¬ëª¨ë‹ˆí„°ë§
   */
  public stopMonitoring(): void {
    if (this.gcInterval) {
      clearInterval(this.gcInterval);
      this.gcInterval = null;
    }
  }

  /**
   * í™•ì¸ë©”ëª¨ë¦¬ ì‚¬ìš©æƒ…å†µ
   */
  private checkMemoryUsage(): void {
    const usage = process.memoryUsage();
    this.memoryUsageHistory.push(usage.heapUsed);
    
    // ä¿ç•™æœ€è¿‘20æ¬¡è®°å½•
    if (this.memoryUsageHistory.length > 20) {
      this.memoryUsageHistory.shift();
    }
    
    // å¦‚æœë©”ëª¨ë¦¬ ì‚¬ìš©è¶…è¿‡é˜ˆå€¼, è§¦å‘ìµœì í™”
    if (usage.heapUsed > this.memoryThreshold) {
      this.optimizeMemory();
    }
    
    // æ£€æµ‹ë©”ëª¨ë¦¬æ³„æ¼
    if (this.detectMemoryLeak()) {
      console.warn('âš ï¸ æ£€æµ‹åˆ°å¯èƒ½ì˜ë©”ëª¨ë¦¬æ³„æ¼');
      this.forceGarbageCollection();
    }
  }

  /**
   * æ£€æµ‹ë©”ëª¨ë¦¬æ³„æ¼
   */
  private detectMemoryLeak(): boolean {
    if (this.memoryUsageHistory.length < 10) return false;
    
    // í™•ì¸ë©”ëª¨ë¦¬ì˜ˆì•„ë‹ˆì˜¤ì§€ì†å¢é•¿
    const recent = this.memoryUsageHistory.slice(-5);
    const earlier = this.memoryUsageHistory.slice(-10, -5);
    
    const recentAvg = recent.reduce((sum, val) => sum + val, 0) / recent.length;
    const earlierAvg = earlier.reduce((sum, val) => sum + val, 0) / earlier.length;
    
    // å¦‚æœæœ€è¿‘5æ¬¡ì˜å¹³å‡å€¼æ¯”ä¹‹å‰5æ¬¡é«˜å‡º20%ë¡œä¸Š, å¯èƒ½å­˜åœ¨ë©”ëª¨ë¦¬æ³„æ¼
    return (recentAvg - earlierAvg) / earlierAvg > 0.2;
  }

  /**
   * æ‰§è¡Œë©”ëª¨ë¦¬ìµœì í™”
   */
  public optimizeMemory(): void {
    console.log('ğŸ”§ æ‰§è¡Œë©”ëª¨ë¦¬ìµœì í™”...');
    
    // 1. æ¸…ç†ë©”ì‹œì§€íìºì‹œ
    this.clearMessageQueueCache();
    
    // 2. æ¸…ç†ë„êµ¬æ‰§è¡Œå†å²
    this.clearToolExecutionHistory();
    
    // 3. æ¸…ç†MCPì—°ê²°ìºì‹œ
    this.clearMcpConnectionCache();
    
    // 4. å¼ºåˆ¶åƒåœ¾å›æ”¶
    this.forceGarbageCollection();
    
    console.log('âœ… ë©”ëª¨ë¦¬ìµœì í™”å®Œæˆ');
  }

  /**
   * æ¸…ç†ë©”ì‹œì§€íìºì‹œ
   */
  private clearMessageQueueCache(): void {
    // êµ¬í˜„ë©”ì‹œì§€íìºì‹œæ¸…ç†
    try {
      const { globalMessageQueue } = require('../core/message-queue');
      if (globalMessageQueue && typeof globalMessageQueue.clearCache === 'function') {
        globalMessageQueue.clearCache();
      }
    } catch (error) {
      console.warn('æ¸…ç†ë©”ì‹œì§€íìºì‹œæ—¶å‡ºé”™:', error);
    }
  }

  /**
   * æ¸…ç†ë„êµ¬æ‰§è¡Œå†å²
   */
  private clearToolExecutionHistory(): void {
    try {
      const { globalToolSecurity } = require('../mcp/security/tool-whitelist');
      if (globalToolSecurity && typeof globalToolSecurity.cleanupViolations === 'function') {
        globalToolSecurity.cleanupViolations();
      }
    } catch (error) {
      console.warn('æ¸…ç†ë„êµ¬æ‰§è¡Œå†å²æ—¶å‡ºé”™:', error);
    }
  }

  /**
   * æ¸…ç†MCPì—°ê²°ìºì‹œ
   */
  private clearMcpConnectionCache(): void {
    try {
      const { globalServerManager } = require('../mcp/server-manager');
      if (globalServerManager && typeof globalServerManager.clearCache === 'function') {
        globalServerManager.clearCache();
      }
    } catch (error) {
      console.warn('æ¸…ç†MCPì—°ê²°ìºì‹œæ—¶å‡ºé”™:', error);
    }
  }

  /**
   * å¼ºåˆ¶åƒåœ¾å›æ”¶
   */
  private forceGarbageCollection(): void {
    if (global.gc) {
      global.gc();
      console.log('ğŸ—‘ï¸ æ‰§è¡Œåƒåœ¾å›æ”¶');
    } else {
      console.warn('åƒåœ¾å›æ”¶ì‚¬ìš© ë¶ˆê°€, éœ€è¦ä½¿ç”¨ --expose-gc í”Œë˜ê·¸ì‹œì‘');
    }
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°ë©”ëª¨ë¦¬ ì‚¬ìš©ë¦¬í¬íŠ¸
   */
  public getMemoryReport(): {
    current: NodeJS.MemoryUsage;
    threshold: number;
    history: number[];
    recommendation: string;
  } {
    const current = process.memoryUsage();
    let recommendation = 'ë©”ëª¨ë¦¬ ì‚¬ìš©æ­£å¸¸';
    
    if (current.heapUsed > this.memoryThreshold) {
      recommendation = 'ë©”ëª¨ë¦¬ ì‚¬ìš©è¿‡é«˜, å»ºè®®ìµœì í™”';
    } else if (this.detectMemoryLeak()) {
      recommendation = 'æ£€æµ‹åˆ°ë©”ëª¨ë¦¬æ³„æ¼, éœ€è¦è°ƒæŸ¥';
    }
    
    return {
      current,
      threshold: this.memoryThreshold,
      history: [...this.memoryUsageHistory],
      recommendation
    };
  }
}

/**
 * ì‘ë‹µæ—¶é—´ìµœì í™”å™¨
 */
export class ResponseTimeOptimizer {
  private responseTimeCache = new Map<string, number>();
  private optimizationStrategies = new Map<string, () => void>();
  
  constructor() {
    this.initializeStrategies();
  }

  /**
   * ì´ˆê¸°í™”ìµœì í™”ì „ëµ
   */
  private initializeStrategies(): void {
    this.optimizationStrategies.set('agent-core', () => {
      // Agentí•µì‹¬ìµœì í™”
      this.optimizeAgentCore();
    });
    
    this.optimizationStrategies.set('tool-execution', () => {
      // ë„êµ¬æ‰§è¡Œìµœì í™”
      this.optimizeToolExecution();
    });
    
    this.optimizationStrategies.set('mcp-connections', () => {
      // MCPì—°ê²°ìµœì í™”
      this.optimizeMcpConnections();
    });
    
    this.optimizationStrategies.set('ui-rendering', () => {
      // UIæ¸²æŸ“ìµœì í™”
      this.optimizeUIRendering();
    });
  }

  /**
   * è®°å½•ì‘ë‹µæ—¶é—´
   */
  public recordResponseTime(operation: string, time: number): void {
    this.responseTimeCache.set(operation, time);
    
    // å¦‚æœì‘ë‹µæ—¶é—´è¶…è¿‡é˜ˆå€¼, è§¦å‘ìµœì í™”
    const threshold = this.getThreshold(operation);
    if (time > threshold) {
      this.triggerOptimization(operation);
    }
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°æ“ä½œì˜ì‘ë‹µæ—¶é—´é˜ˆå€¼
   */
  private getThreshold(operation: string): number {
    const thresholds = {
      'agent-core': 2000,      // 2ç§’
      'tool-execution': 1000,   // 1ç§’
      'mcp-connections': 500,   // 500ms
      'ui-rendering': 100,      // 100ms
      'plan-mode': 200         // 200ms
    };
    
    return thresholds[operation] || 1000;
  }

  /**
   * è§¦å‘ìµœì í™”
   */
  private triggerOptimization(operation: string): void {
    console.log(`ğŸš€ è§¦å‘ ${operation} ìµœì í™”...`);
    
    const strategy = this.optimizationStrategies.get(operation);
    if (strategy) {
      strategy();
    }
  }

  /**
   * ìµœì í™”Agentí•µì‹¬
   */
  private optimizeAgentCore(): void {
    // 1. í™œì„±í™”ë©”ì‹œì§€ì••ì¶•
    this.enableMessageCompression();
    
    // 2. ìµœì í™”Steeringí
    this.optimizeSteeringQueue();
    
    // 3. í™œì„±í™”ì‘ë‹µìºì‹œ
    this.enableResponseCaching();
  }

  /**
   * í™œì„±í™”ë©”ì‹œì§€ì••ì¶•
   */
  private enableMessageCompression(): void {
    try {
      const { AgentCore } = require('../core/agent-core');
      if (AgentCore.prototype.enableCompression) {
        AgentCore.prototype.enableCompression(true);
        console.log('âœ… í™œì„±í™”ë©”ì‹œì§€ì••ì¶•');
      }
    } catch (error) {
      console.warn('í™œì„±í™”ë©”ì‹œì§€ì••ì¶•ì‹¤íŒ¨:', error);
    }
  }

  /**
   * ìµœì í™”Steeringí
   */
  private optimizeSteeringQueue(): void {
    try {
      const { h2A } = require('../core/message-queue');
      if (h2A.prototype.enableBatching) {
        h2A.prototype.enableBatching(true);
        console.log('âœ… í™œì„±í™”Steeringíæ‰¹ì²˜ë¦¬');
      }
    } catch (error) {
      console.warn('ìµœì í™”Steeringíì‹¤íŒ¨:', error);
    }
  }

  /**
   * í™œì„±í™”ì‘ë‹µìºì‹œ
   */
  private enableResponseCaching(): void {
    // êµ¬í˜„ì‘ë‹µìºì‹œë…¼ë¦¬
    console.log('âœ… í™œì„±í™”ì‘ë‹µìºì‹œ');
  }

  /**
   * ìµœì í™”ë„êµ¬æ‰§è¡Œ
   */
  private optimizeToolExecution(): void {
    // 1. í™œì„±í™”ë„êµ¬æ‰§è¡Œæ± 
    this.enableToolExecutionPool();
    
    // 2. ìµœì í™”ë™ì‹œì œì–´
    this.optimizeConcurrencyControl();
  }

  /**
   * í™œì„±í™”ë„êµ¬æ‰§è¡Œæ± 
   */
  private enableToolExecutionPool(): void {
    try {
      const { ToolRegistry } = require('../tools/registry');
      if (ToolRegistry.prototype.enablePool) {
        ToolRegistry.prototype.enablePool(10); // æ± å¤§å°ä¸º10
        console.log('âœ… í™œì„±í™”ë„êµ¬æ‰§è¡Œæ± ');
      }
    } catch (error) {
      console.warn('í™œì„±í™”ë„êµ¬æ‰§è¡Œæ± ì‹¤íŒ¨:', error);
    }
  }

  /**
   * ìµœì í™”ë™ì‹œì œì–´
   */
  private optimizeConcurrencyControl(): void {
    try {
      const { globalToolSecurity } = require('../mcp/security/tool-whitelist');
      if (globalToolSecurity && globalToolSecurity.updatePolicy) {
        globalToolSecurity.updatePolicy({
          maxConcurrentCalls: 15 // å¢åŠ ë™ì‹œé™åˆ¶
        });
        console.log('âœ… ìµœì í™”ë™ì‹œì œì–´');
      }
    } catch (error) {
      console.warn('ìµœì í™”ë™ì‹œì œì–´ì‹¤íŒ¨:', error);
    }
  }

  /**
   * ìµœì í™”MCPì—°ê²°
   */
  private optimizeMcpConnections(): void {
    // 1. í™œì„±í™”ì—°ê²°æ± 
    this.enableConnectionPooling();
    
    // 2. ìµœì í™”å¿ƒè·³ë©”ì»¤ë‹ˆì¦˜
    this.optimizeHeartbeat();
    
    // 3. í™œì„±í™”ìš”ì²­æ‰¹ì²˜ë¦¬
    this.enableRequestBatching();
  }

  /**
   * í™œì„±í™”ì—°ê²°æ± 
   */
  private enableConnectionPooling(): void {
    try {
      const { globalServerManager } = require('../mcp/server-manager');
      if (globalServerManager && globalServerManager.enablePooling) {
        globalServerManager.enablePooling(true);
        console.log('âœ… í™œì„±í™”MCPì—°ê²°æ± ');
      }
    } catch (error) {
      console.warn('í™œì„±í™”ì—°ê²°æ± ì‹¤íŒ¨:', error);
    }
  }

  /**
   * ìµœì í™”å¿ƒè·³ë©”ì»¤ë‹ˆì¦˜
   */
  private optimizeHeartbeat(): void {
    // êµ¬í˜„å¿ƒè·³ìµœì í™”
    console.log('âœ… ìµœì í™”å¿ƒè·³ë©”ì»¤ë‹ˆì¦˜');
  }

  /**
   * í™œì„±í™”ìš”ì²­æ‰¹ì²˜ë¦¬
   */
  private enableRequestBatching(): void {
    // êµ¬í˜„ìš”ì²­æ‰¹ì²˜ë¦¬
    console.log('âœ… í™œì„±í™”ìš”ì²­æ‰¹ì²˜ë¦¬');
  }

  /**
   * ìµœì í™”UIæ¸²æŸ“
   */
  private optimizeUIRendering(): void {
    // 1. í™œì„±í™”ê°€ìƒåŒ–
    this.enableVirtualization();
    
    // 2. ìµœì í™”é‡æ¸²æŸ“
    this.optimizeRerendering();
  }

  /**
   * í™œì„±í™”ê°€ìƒåŒ–
   */
  private enableVirtualization(): void {
    // êµ¬í˜„UIê°€ìƒåŒ–
    console.log('âœ… í™œì„±í™”UIê°€ìƒåŒ–');
  }

  /**
   * ìµœì í™”é‡æ¸²æŸ“
   */
  private optimizeRerendering(): void {
    // êµ¬í˜„é‡æ¸²æŸ“ìµœì í™”
    console.log('âœ… ìµœì í™”UIé‡æ¸²æŸ“');
  }

  /**
   * ç”Ÿæˆæ€§èƒ½ë¦¬í¬íŠ¸
   */
  public generatePerformanceReport(): string {
    const report = ['# ì„±ëŠ¥ ìµœì í™”ë¦¬í¬íŠ¸\n'];
    
    report.push('## ì‘ë‹µæ—¶é—´í†µê³„\n');
    for (const [operation, time] of this.responseTimeCache) {
      const threshold = this.getThreshold(operation);
      const status = time <= threshold ? 'âœ…' : 'âŒ';
      report.push(`- ${operation}: ${time.toFixed(2)}ms (é˜ˆå€¼: ${threshold}ms) ${status}`);
    }
    
    report.push('\n## å·²ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ìµœì í™”ì „ëµ\n');
    for (const strategy of this.optimizationStrategies.keys()) {
      report.push(`- ${strategy}: å·²ìµœì í™”`);
    }
    
    return report.join('\n');
  }
}

/**
 * ë„¤íŠ¸ì›Œí¬ìµœì í™”å™¨
 */
export class NetworkOptimizer {
  private connectionPool = new Map<string, any[]>();
  private maxConnectionsPerHost = 10;
  private requestQueue = new Map<string, any[]>();
  
  /**
   * ìµœì í™”HTTPìš”ì²­
   */
  public optimizeHttpRequests(): void {
    // 1. í™œì„±í™”ì—°ê²°å¤ç”¨
    this.enableConnectionReuse();
    
    // 2. êµ¬í˜„ìš”ì²­ë³‘í•©
    this.enableRequestBatching();
    
    // 3. í™œì„±í™”ì••ì¶•
    this.enableCompression();
  }

  /**
   * í™œì„±í™”ì—°ê²°å¤ç”¨
   */
  private enableConnectionReuse(): void {
    const http = require('http');
    const https = require('https');
    
    // ì„¤ì •Agentë¡œí™œì„±í™”ì—°ê²°å¤ç”¨
    const httpAgent = new http.Agent({
      keepAlive: true,
      maxSockets: this.maxConnectionsPerHost
    });
    
    const httpsAgent = new https.Agent({
      keepAlive: true,
      maxSockets: this.maxConnectionsPerHost
    });
    
    // å°†è¿™äº›Agentì„¤ì •ä¸ºê¸°ë³¸
    http.globalAgent = httpAgent;
    https.globalAgent = httpsAgent;
    
    console.log('âœ… í™œì„±í™”HTTPì—°ê²°å¤ç”¨');
  }

  /**
   * í™œì„±í™”ìš”ì²­ë³‘í•©
   */
  private enableRequestBatching(): void {
    // êµ¬í˜„ìš”ì²­æ‰¹ì²˜ë¦¬ë…¼ë¦¬
    console.log('âœ… í™œì„±í™”ìš”ì²­ë³‘í•©');
  }

  /**
   * í™œì„±í™”ì••ì¶•
   */
  private enableCompression(): void {
    // ä¸ºæ‰€ìˆìŒHTTPìš”ì²­í™œì„±í™”gzipì••ì¶•
    const defaultHeaders = {
      'Accept-Encoding': 'gzip, deflate, br',
      'Connection': 'keep-alive'
    };
    
    // å°†è¿™äº›å¤´éƒ¨ì• í”Œë¦¬ì¼€ì´ì…˜åˆ°æ‰€ìˆìŒìš”ì²­
    console.log('âœ… í™œì„±í™”HTTPì••ì¶•');
  }
}

/**
 * ì „ì—­ì„±ëŠ¥ ìµœì í™”ê´€ë¦¬å™¨
 */
export class GlobalPerformanceOptimizer {
  private memoryOptimizer: MemoryOptimizer;
  private responseTimeOptimizer: ResponseTimeOptimizer;
  private networkOptimizer: NetworkOptimizer;
  private isOptimizationEnabled = false;
  
  constructor() {
    this.memoryOptimizer = new MemoryOptimizer();
    this.responseTimeOptimizer = new ResponseTimeOptimizer();
    this.networkOptimizer = new NetworkOptimizer();
  }

  /**
   * í™œì„±í™”ì „ì—­ì„±ëŠ¥ ìµœì í™”
   */
  public enableOptimizations(): void {
    if (this.isOptimizationEnabled) return;
    
    console.log('ğŸš€ í™œì„±í™” Open Claude Code ì„±ëŠ¥ ìµœì í™”...');
    
    // 1. ì‹œì‘ë©”ëª¨ë¦¬ëª¨ë‹ˆí„°ë§
    this.memoryOptimizer.startMonitoring();
    
    // 2. ìµœì í™”ë„¤íŠ¸ì›Œí¬ìš”ì²­
    this.networkOptimizer.optimizeHttpRequests();
    
    // 3. ì„¤ì •æ€§èƒ½ëª¨ë‹ˆí„°ë§
    this.setupPerformanceMonitoring();
    
    // 4. ì• í”Œë¦¬ì¼€ì´ì…˜ì‹œì‘ìµœì í™”
    this.applyStartupOptimizations();
    
    this.isOptimizationEnabled = true;
    console.log('âœ… ì„±ëŠ¥ ìµœì í™”í™œì„±í™”ë¨');
  }

  /**
   * ë¹„í™œì„±í™”ì„±ëŠ¥ ìµœì í™”
   */
  public disableOptimizations(): void {
    if (!this.isOptimizationEnabled) return;
    
    this.memoryOptimizer.stopMonitoring();
    this.isOptimizationEnabled = false;
    
    console.log('ğŸ›‘ ì„±ëŠ¥ ìµœì í™”ë¹„í™œì„±í™”ë¨');
  }

  /**
   * ì„¤ì •æ€§èƒ½ëª¨ë‹ˆí„°ë§
   */
  private setupPerformanceMonitoring(): void {
    // ëª¨ë‹ˆí„°ë§å…³é”®æ“ä½œì˜æ€§èƒ½
    this.instrumentFunction('AgentCore', 'mainLoop', 'agent-core');
    this.instrumentFunction('ToolRegistry', 'executeTool', 'tool-execution');
    this.instrumentFunction('McpClient', 'callTool', 'mcp-connections');
  }

  /**
   * ä¸ºí•¨ìˆ˜ì¶”ê°€æ€§èƒ½ëª¨ë‹ˆí„°ë§
   */
  private instrumentFunction(className: string, methodName: string, operationName: string): void {
    try {
      const classModule = require(`../core/${className.toLowerCase()}`);
      const originalMethod = classModule[className].prototype[methodName];
      
      if (originalMethod) {
        classModule[className].prototype[methodName] = async function(...args: any[]) {
          const startTime = performance.now();
          const result = await originalMethod.apply(this, args);
          const endTime = performance.now();
          
          this.responseTimeOptimizer.recordResponseTime(operationName, endTime - startTime);
          
          return result;
        };
      }
    } catch (error) {
      console.warn(`ì—†ìŒæ³•ä¸º ${className}.${methodName} ì¶”ê°€æ€§èƒ½ëª¨ë‹ˆí„°ë§:`, error);
    }
  }

  /**
   * ì• í”Œë¦¬ì¼€ì´ì…˜ì‹œì‘ìµœì í™”
   */
  private applyStartupOptimizations(): void {
    // 1. é¢„ë¡œë”©å…³é”®ëª¨ë“ˆ
    this.preloadCriticalModules();
    
    // 2. ì´ˆê¸°í™”ìºì‹œ
    this.initializeCaches();
    
    // 3. ì„¤ì •æ€§èƒ½è°ƒä¼˜ë§¤ê°œë³€ìˆ˜
    this.configurePerformanceTuning();
  }

  /**
   * é¢„ë¡œë”©å…³é”®ëª¨ë“ˆ
   */
  private preloadCriticalModules(): void {
    const criticalModules = [
      '../core/agent-core',
      '../core/message-queue',
      '../tools/registry',
      '../mcp/client'
    ];
    
    for (const module of criticalModules) {
      try {
        require(module);
      } catch (error) {
        console.warn(`é¢„ë¡œë”©ëª¨ë“ˆ ${module} ì‹¤íŒ¨:`, error);
      }
    }
    
    console.log('âœ… å…³é”®ëª¨ë“ˆé¢„ë¡œë”©å®Œæˆ');
  }

  /**
   * ì´ˆê¸°í™”ìºì‹œ
   */
  private initializeCaches(): void {
    // ì´ˆê¸°í™”å„ç§ìºì‹œ
    console.log('âœ… ìºì‹œì´ˆê¸°í™”å®Œæˆ');
  }

  /**
   * ì„¤ì •æ€§èƒ½è°ƒä¼˜ë§¤ê°œë³€ìˆ˜
   */
  private configurePerformanceTuning(): void {
    // è°ƒæ•´Node.jsæ€§èƒ½ë§¤ê°œë³€ìˆ˜
    if (process.env.NODE_ENV === 'production') {
      process.env.UV_THREADPOOL_SIZE = '16'; // å¢åŠ çº¿ç¨‹æ± å¤§å°
    }
    
    console.log('âœ… æ€§èƒ½è°ƒä¼˜ë§¤ê°œë³€ìˆ˜ì„¤ì •å®Œæˆ');
  }

  /**
   * ç”Ÿæˆç»¼åˆæ€§èƒ½ë¦¬í¬íŠ¸
   */
  public generateComprehensiveReport(): string {
    const report = ['# Open Claude Code ç»¼åˆæ€§èƒ½ë¦¬í¬íŠ¸\n'];
    
    // ë©”ëª¨ë¦¬ë¦¬í¬íŠ¸
    const memoryReport = this.memoryOptimizer.getMemoryReport();
    report.push('## ë©”ëª¨ë¦¬ ì‚¬ìš©ë¦¬í¬íŠ¸');
    report.push(`- å½“å‰í™ë©”ëª¨ë¦¬: ${(memoryReport.current.heapUsed / 1024 / 1024).toFixed(2)}MB`);
    report.push(`- ë©”ëª¨ë¦¬é˜ˆå€¼: ${(memoryReport.threshold / 1024 / 1024).toFixed(2)}MB`);
    report.push(`- å»ºè®®: ${memoryReport.recommendation}\n`);
    
    // ì‘ë‹µæ—¶é—´ë¦¬í¬íŠ¸
    report.push(this.responseTimeOptimizer.generatePerformanceReport());
    
    // ìµœì í™”ìƒíƒœ
    report.push('\n## ìµœì í™”ìƒíƒœ');
    report.push(`- ì„±ëŠ¥ ìµœì í™”: ${this.isOptimizationEnabled ? 'âœ… í™œì„±í™”ë¨' : 'âŒ æœªí™œì„±í™”'}`);
    report.push(`- ë©”ëª¨ë¦¬ëª¨ë‹ˆí„°ë§: ${this.memoryOptimizer ? 'âœ… ì‹¤í–‰ ì¤‘' : 'âŒ æœªì‹¤í–‰'}`);
    
    return report.join('\n');
  }
}

/**
 * ì „ì—­ì„±ëŠ¥ ìµœì í™”å™¨ì¸ìŠ¤í„´ìŠ¤
 */
export const globalPerformanceOptimizer = new GlobalPerformanceOptimizer();
```

---

## ğŸ“ 2ì£¼ì°¨: ë¬¸ì„œ ì™„ì„±ì™€ë°°í¬ ì¤€å¤‡

### ë‹¨ê³„5.4: ì‚¬ìš©ìë¬¸ì„œì™€ê°œë°œê°€ì´ë“œ

**ìƒì„±ì „ì²´ì˜ì‚¬ìš©ìì™€ê°œë°œè€…ë¬¸ì„œ**

**íŒŒì¼ ê²½ë¡œ**: `docs/README.md`
**íŒŒì¼ ë‚´ìš©**:
```markdown
# Open Claude Code

ä¸€ä¸ªå®Œå…¨å¼€æºì˜AIç¼–ç¨‹åŠ©æ‰‹, ê¸°ë°˜Claude Codeé€†å‘ë¶„ì„é‡æ–°êµ¬í˜„, æä¾›ä¸åŸç‰ˆç›¸åŒì˜å¼ºå¤§åŠŸèƒ½. 

## ğŸš€ å¿«é€Ÿå¼€å§‹

### ì„¤ì¹˜

```bash
# ä½¿ç”¨ npm ì„¤ì¹˜
npm install -g open-claude-code

# ä½¿ç”¨ yarn ì„¤ì¹˜
yarn global add open-claude-code

# ä½¿ç”¨ pnpm ì„¤ì¹˜
pnpm add -g open-claude-code
```

### ê¸°ë³¸ä½¿ç”¨

```bash
# ì‹œì‘äº¤äº’å¼ëª¨ë“œ
claude

# ç›´æ¥æ‰§è¡Œì»¤ë§¨ë“œ
claude "ìƒì„±ä¸€ä¸ªPython webì• í”Œë¦¬ì¼€ì´ì…˜"

# ë³´ê¸°å¸®åŠ©
claude --help

# ë³´ê¸°ë²„ì „
claude --version
```

## âœ¨ í•µì‹¬ç‰¹æ€§

### ğŸ§  æ™ºèƒ½Agentì‹œìŠ¤í…œ
- **ì‹¤ì‹œê°„ Steeringë©”ì»¤ë‹ˆì¦˜**: åœ¨AIæ‰§è¡Œè¿‡ç¨‹ä¸­ì‹¤ì‹œê°„ê°€ì´ë“œì™€è°ƒæ•´
- **åˆ†å±‚å¤šAgentæ¶æ„**: ì§€ì›ë³‘ë ¬å­ä»»åŠ¡æ‰§è¡Œ
- **ë©”ì‹œì§€ì••ì¶•ì™€ìµœì í™”**: æ™ºèƒ½ê´€ë¦¬é•¿å¯¹è¯å†å²

### ğŸ› ï¸ å¼ºå¤§ì˜ë„êµ¬ì‹œìŠ¤í…œ
- **15+å†…ç½®ë„êµ¬**: íŒŒì¼æ“ä½œ, ì½”ë“œê²€ìƒ‰, ì‹œìŠ¤í…œì»¤ë§¨ë“œç­‰
- **ë™ì‹œæ‰§è¡Œì œì–´**: æ™ºèƒ½ê´€ë¦¬ë„êµ¬æ‰§è¡Œì™€èµ„æºåˆ†é…
- **ë³´ì•ˆê¶Œí•œê²€ì¦**: ç¡®ä¿ë³´ì•ˆì˜ë„êµ¬æ‰§è¡Œí™˜ê²½

### ğŸ“‹ Planëª¨ë“œ
- **ë³´ì•ˆë¶„ì„ëª¨ë“œ**: åœ¨æ‰§è¡Œå‰åˆ¶å®šì™€å®¡æŸ¥è®¡åˆ’
- **4ìƒíƒœìˆœí™˜**: default â†’ acceptEdits â†’ plan â†’ bypassPermissions
- **ì‚¬ìš©ìí™•ì¸ë©”ì»¤ë‹ˆì¦˜**: å®Œå…¨ì œì–´AIì˜æ‰§è¡Œè¿‡ç¨‹

### ğŸ”Œ MCPìƒíƒœê³„ì‹œìŠ¤í…œ
- **å¤ší”„ë¡œí† ì½œì§€ì›**: STDIO, HTTP, SSE, WebSocketå››ç§ì „ì†¡ë°©ì‹
- **IDEæ·±åº¦í†µí•©**: VS Code, Cursor, Windsurfç­‰ä¸»æµIDE
- **í™•ì¥í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ**: ì§€ì›ç¬¬ä¸‰æ–¹ë„êµ¬ì™€ì„œë¹„ìŠ¤í†µí•©

### ğŸ’¬ íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œ
- **!bashëª¨ë“œ**: ç›´æ¥æ‰§è¡Œëª…ë ¹ì¤„æŒ‡ä»¤
- **#ë…¸íŠ¸ëª¨ë“œ**: æ™ºèƒ½ë…¸íŠ¸è®°å½•ì™€ê´€ë¦¬
- **ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥**: ì§€ì›ì½”ë“œå—ì™€ë³µì¡ì…ë ¥
- **15+ë‹¨ì¶• ëª…ë ¹**: /help, /mcp, /statusç­‰ä¾¿æ·ì»¤ë§¨ë“œ

## ğŸ“– ä½¿ç”¨ê°€ì´ë“œ

### ê¸°ë³¸å¯¹è¯

ì‹œì‘Open Claude Codeå, ä½ å¯ë¡œç›´æ¥ä¸AIå¯¹è¯: 

```
ä½ å¥½ï¼æˆ‘ì˜ˆOpen Claude Code, ä¸€ä¸ªå¼ºå¤§ì˜AIç¼–ç¨‹åŠ©æ‰‹. 

ğŸ‘¤ User: å¸®æˆ‘ìƒì„±ä¸€ä¸ªê°„ë‹¨ì˜Node.jsí”„ë¡œì íŠ¸

ğŸ¤– Claude: æˆ‘æ¥å¸®ä½ ìƒì„±ä¸€ä¸ªNode.jsí”„ë¡œì íŠ¸. è®©æˆ‘å…ˆí™•ì¸å½“å‰ë””ë ‰í† ë¦¬êµ¬ì¡°, ç„¶åìƒì„±å¿…è¦ì˜íŒŒì¼. 

[ë„êµ¬æ‰§è¡Œ: LS]
[ë„êµ¬æ‰§è¡Œ: Write package.json]
[ë„êµ¬æ‰§è¡Œ: Write index.js]

í”„ë¡œì íŠ¸ìƒì„±å®Œæˆï¼æˆ‘å·²ç»ä¸ºä½ ìƒì„±äº†: 
- package.json: í”„ë¡œì íŠ¸ì„¤ì •íŒŒì¼
- index.js: ä¸»å…¥å£íŒŒì¼
- ê¸°ë³¸ì˜í”„ë¡œì íŠ¸êµ¬ì¡°

ä½ å¯ë¡œì‹¤í–‰ `npm start` æ¥ì‹œì‘í”„ë¡œì íŠ¸. 
```

### Planëª¨ë“œä½¿ç”¨

Planëª¨ë“œè®©ä½ å¯ë¡œåœ¨AIæ‰§è¡Œå‰å®¡æŸ¥è®¡åˆ’: 

```bash
# ä½¿ç”¨Shift+Tabì „í™˜åˆ°Planëª¨ë“œ
# ë˜ëŠ”ä½¿ç”¨ì»¤ë§¨ë“œ
claude --mode plan
```

åœ¨Planëª¨ë“œä¸‹: 
1. AIä¼šë¶„ì„ä»»åŠ¡å¹¶åˆ¶å®šìƒì„¸è®¡åˆ’
2. í‘œì‹œå°†è¦æ‰§è¡Œì˜æ‰€ìˆìŒæ“ä½œ
3. awaitä½ ì˜í™•ì¸æ‰å¼€å§‹æ‰§è¡Œ
4. å¯ë¡œìˆ˜ì •ë˜ëŠ”æ‹’ç»è®¡åˆ’

### íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œ

#### Bashëª¨ë“œ
ç›´æ¥æ‰§è¡Œì‹œìŠ¤í…œì»¤ë§¨ë“œ: 
```
!ls -la
!git status
!npm install
```

#### ë…¸íŠ¸ëª¨ë“œ
è®°å½•é‡è¦ì •ë³´: 
```
# è¿™ì˜ˆä¸€ä¸ªé‡è¦ì˜APIç«¯ç‚¹ #api #important
# éœ€è¦è®°ä½ì˜ì„¤ì •ì˜µì…˜ #config #todo
```

#### ë‹¨ì¶• ëª…ë ¹
ä½¿ç”¨æ–œæ ì»¤ë§¨ë“œå¿«é€Ÿæ‰§è¡Œæ“ä½œ: 
```
/help          # í‘œì‹œå¸®åŠ©
/status        # ë³´ê¸°ì‹œìŠ¤í…œìƒíƒœ
/mcp list      # ë³´ê¸°MCPì„œë²„
/clear         # æ¸…é™¤å¯¹è¯å†å²
/mode plan     # ì „í™˜åˆ°Planëª¨ë“œ
```

### MCPì„œë²„ì„¤ì •

ìƒì„± `.mcp.json` ì„¤ì •íŒŒì¼: 

```json
{
  "servers": {
    "my-database": {
      "name": "my-database",
      "transport": {
        "type": "stdio",
        "command": "python",
        "args": ["my-db-server.py"]
      }
    },
    "web-service": {
      "name": "web-service", 
      "transport": {
        "type": "http",
        "url": "http://localhost:8080/mcp"
      }
    }
  }
}
```

### IDEí†µí•©

#### VS Code
1. ì„¤ì¹˜Open Claude Codeí™•ì¥
2. ì„¤ì •MCPì—°ê²°: 
```json
{
  "servers": {
    "vscode-integration": {
      "name": "vscode-integration",
      "transport": {
        "type": "sse-ide",
        "url": "http://localhost:3000/sse",
        "ideName": "vscode"
      }
    }
  }
}
```

#### ì§„ë‹¨ì •ë³´ë™ê¸°í™”
Open Claude Codeä¼šìë™: 
- ê°€ì ¸ì˜¤ê¸°LSPì§„ë‹¨ì •ë³´
- ë™ê¸°í™”ì½”ë“œæ‰§è¡Œìƒíƒœ
- æä¾›ì‹¤ì‹œê°„ì˜¤ë¥˜åé¦ˆ

## ğŸ”§ ì„¤ì •ì˜µì…˜

### ì „ì—­ì„¤ì •

í¸ì§‘ `~/.claude-code/config.json`: 

```json
{
  "model": "claude-3-sonnet",
  "fallbackModel": "claude-3-haiku",
  "maxTokens": 4000,
  "timeout": 30000,
  "theme": "dark",
  "autoSave": true,
  "debugMode": false
}
```

### í”„ë¡œì íŠ¸ì„¤ì •

åœ¨í”„ë¡œì íŠ¸æ ¹ë””ë ‰í† ë¦¬ìƒì„± `.claude-code/config.json`: 

```json
{
  "workspaceTools": ["Read", "Write", "Edit", "Bash", "Grep"],
  "allowedDirectories": ["./src", "./docs", "./tests"],
  "excludePatterns": ["node_modules", ".git", "*.log"]
}
```

### í™˜ê²½ë³€ìˆ˜

```bash
# APIí‚¤
export ANTHROPIC_API_KEY="your-api-key"

# æ¨¡å‹ì„¤ì •
export CLAUDE_CODE_MODEL="claude-3-sonnet"
export CLAUDE_CODE_FALLBACK="claude-3-haiku"

# ë””ë²„ê·¸ëª¨ë“œ
export CLAUDE_CODE_DEBUG=true

# ì„±ëŠ¥ ìµœì í™”
export CLAUDE_CODE_OPTIMIZE=true
```

## ğŸ›¡ï¸ ë³´ì•ˆç‰¹æ€§

### ë„êµ¬ê¶Œí•œì œì–´
- ê¸°ë³¸åªå…è®¸ë³´ì•ˆì˜ì½ê¸° ì „ìš©ë„êµ¬
- å±é™©æ“ä½œéœ€è¦æ˜ç¡®ê¶Œí•œ ë¶€ì—¬
- ì§€ì›ë„êµ¬í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ì™€é»‘åå•

### íŒŒì¼è®¿é—®ì œì–´
- é™åˆ¶åœ¨æŒ‡å®šë””ë ‰í† ë¦¬å†…æ“ä½œ
- æ•æ„ŸíŒŒì¼ìë™í•´ê²°
- æ“ä½œå‰å¼ºåˆ¶í™•ì¸

### MCPë³´ì•ˆë©”ì»¤ë‹ˆì¦˜
- ë„êµ¬í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸í•„í„°ë§
- ì—°ê²°ì¸ì¦ê²€ì¦
- ìš”ì²­é¢‘ç‡é™åˆ¶

## ğŸ”Œ æ‰©í¼ì¹˜ê¸°å‘

### ìƒì„±MCPì„œë²„

```python
# my-mcp-server.py
import json
import sys
from mcp import Server, Tool

server = Server("my-server")

@server.tool("hello")
def hello_tool(name: str) -> str:
    return f"Hello, {name}!"

if __name__ == "__main__":
    server.run_stdio()
```

### ê°œë°œí™•ì¥í”ŒëŸ¬ê·¸ì¸

```typescript
// my-extension/src/extension.ts
import { Extension } from 'open-claude-code';

export default class MyExtension extends Extension {
  async activate() {
    this.registerTool({
      name: 'my_custom_tool',
      description: 'My custom tool',
      inputSchema: {
        type: 'object',
        properties: {
          input: { type: 'string' }
        }
      },
      handler: 'handleMyTool'
    }, this.handleMyTool);
  }

  async handleMyTool(input: { input: string }) {
    return { result: `Processed: ${input.input}` };
  }

  async deactivate() {
    // æ¸…ç†èµ„æº
  }
}
```

## ğŸ“Š ì„±ëŠ¥ ìµœì í™”

### ë©”ëª¨ë¦¬ìµœì í™”
- ìë™ë©”ëª¨ë¦¬ëª¨ë‹ˆí„°ë§ì™€æ¸…ç†
- æ™ºèƒ½ìºì‹œê´€ë¦¬
- åƒåœ¾å›æ”¶ìµœì í™”

### ì‘ë‹µé€Ÿåº¦ìµœì í™”
- ë©”ì‹œì§€ì••ì¶•ë©”ì»¤ë‹ˆì¦˜
- ë„êµ¬æ‰§è¡Œæ± åŒ–
- ë„¤íŠ¸ì›Œí¬ì—°ê²°å¤ç”¨

### í™œì„±í™”ì„±ëŠ¥ ìµœì í™”

```bash
# ì‹œì‘æ—¶í™œì„±í™”ìµœì í™”
claude --optimize

# ë˜ëŠ”ì„¤ì •í™˜ê²½ë³€ìˆ˜
export CLAUDE_CODE_OPTIMIZE=true
claude
```

## ğŸš€ ë°°í¬ì™€í”„ë¡œë•ì…˜í™˜ê²½

### Dockerë°°í¬

```dockerfile
FROM node:18-alpine

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
EXPOSE 3000

CMD ["npm", "start"]
```

### Kubernetesë°°í¬

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: open-claude-code
spec:
  replicas: 3
  selector:
    matchLabels:
      app: open-claude-code
  template:
    metadata:
      labels:
        app: open-claude-code
    spec:
      containers:
      - name: open-claude-code
        image: open-claude-code:latest
        ports:
        - containerPort: 3000
        env:
        - name: ANTHROPIC_API_KEY
          valueFrom:
            secretKeyRef:
              name: claude-secrets
              key: api-key
```

### ëª¨ë‹ˆí„°ë§ì™€ë¡œê·¸

```bash
# í™œì„±í™”ìƒì„¸ë¡œê·¸
export CLAUDE_CODE_LOG_LEVEL=debug
claude

# ëª¨ë‹ˆí„°ë§æ€§èƒ½ì§€í‘œ
claude --monitor --metrics-port 9090
```

## ğŸ¤ è´¡çŒ®ê°€ì´ë“œ

æˆ‘ä»¬æ¬¢è¿ç¤¾åŒºè´¡çŒ®ï¼è¯·ë³´ê¸° [CONTRIBUTING.md](CONTRIBUTING.md) äº†è§£ìƒì„¸ì˜è´¡çŒ®ê°€ì´ë“œ. 

### ê°œë°œí™˜ê²½ì„¤ì •

```bash
# í´ë¡ ì €ì¥ì†Œ
git clone https://github.com/open-claude-code/open-claude-code.git
cd open-claude-code

# ì„¤ì¹˜ì˜ì¡´ì„±
npm install

# ì‹¤í–‰ê°œë°œë²„ì „
npm run dev

# ì‹¤í–‰í…ŒìŠ¤íŠ¸
npm test

# ë¹Œë“œí”„ë¡œì íŠ¸
npm run build
```

### í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œç‡

æˆ‘ä»¬è¦æ±‚æ‰€ìˆìŒæ–°åŠŸèƒ½éƒ½ìˆìŒì „ì²´ì˜í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œ: 

```bash
# ì‹¤í–‰í…ŒìŠ¤íŠ¸å¹¶ç”Ÿæˆì˜¤ë²„ë¼ì´ë“œç‡ë¦¬í¬íŠ¸
npm run test:coverage

# ì‹¤í–‰æ€§èƒ½ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸
npm run test:benchmark

# ì‹¤í–‰í†µí•© í…ŒìŠ¤íŠ¸
npm run test:integration
```

## ğŸ“„ è®¸å¯è¯

Open Claude Code ä½¿ç”¨ [MIT è®¸å¯è¯](LICENSE). 

## ğŸ™ è‡´è°¢

æœ¬í”„ë¡œì íŠ¸ê¸°ë°˜å¯¹Claude Codeì˜æ·±åº¦é€†å‘ë¶„ì„êµ¬í˜„, æ„Ÿè°¢Anthropicåˆ›é€ äº†å¦‚æ­¤ä¼˜ç§€ì˜AIç¼–ç¨‹åŠ©æ‰‹. 

## ğŸ“ ì§€ì›ì™€ç¤¾åŒº

- **GitHub Issues**: [ì œì¶œBugì™€åŠŸèƒ½ìš”ì²­](https://github.com/open-claude-code/open-claude-code/issues)
- **è®¨è®ºåŒº**: [GitHub Discussions](https://github.com/open-claude-code/open-claude-code/discussions)
- **ë¬¸ì„œ**: [ì „ì²´ë¬¸ì„œç½‘ç«™](https://docs.open-claude-code.org)
- **ç¤¾åŒº**: [Discordì„œë²„](https://discord.gg/open-claude-code)

---

**Open Claude Code** - è®©AIç¼–ç¨‹åŠ©æ‰‹æ›´å¼€æ”¾, æ›´å¼ºå¤§, æ›´è‡ªç”±ï¼
```

### ë‹¨ê³„5.5: CI/CDì™€ë°°í¬ í”„ë¡œì„¸ìŠ¤

**å»ºç«‹ì „ì²´ì˜ìë™í™”ë¹Œë“œì™€ë°°í¬ í”„ë¡œì„¸ìŠ¤**

**íŒŒì¼ ê²½ë¡œ**: `.github/workflows/ci-cd.yml`
**íŒŒì¼ ë‚´ìš©**:
```yaml
name: Open Claude Code CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  NODE_VERSION: '18'
  REGISTRY_URL: 'registry.npmjs.org'

jobs:
  # ì½”ë“œ í’ˆì§ˆí™•ì¸
  quality-check:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: ESLint check
      run: npm run lint

    - name: Prettier check
      run: npm run format:check

    - name: TypeScript check
      run: npm run type-check

    - name: Security audit
      run: npm audit --audit-level high

  # ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
  unit-tests:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18, 20]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run unit tests
      run: npm run test:unit

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

  # í†µí•© í…ŒìŠ¤íŠ¸
  integration-tests:
    runs-on: ubuntu-latest
    needs: [quality-check, unit-tests]
    
    services:
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Setup test environment
      run: |
        npm run setup:test-env
        npm run migrate:test-db

    - name: Run integration tests
      run: npm run test:integration
      env:
        TEST_REDIS_URL: redis://localhost:6379
        CI: true

    - name: Run end-to-end tests
      run: npm run test:e2e

  # æ€§èƒ½ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸
  performance-tests:
    runs-on: ubuntu-latest
    needs: [unit-tests]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run performance benchmarks
      run: npm run test:benchmark

    - name: Store benchmark results
      uses: benchmark-action/github-action-benchmark@v1
      with:
        name: Open Claude Code Benchmark
        tool: 'benchmarkjs'
        output-file-path: benchmark-results.json
        github-token: ${{ secrets.GITHUB_TOKEN }}
        auto-push: true

  # ë³´ì•ˆæ‰«æ
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run Snyk to check for vulnerabilities
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: javascript

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

  # ë¹Œë“œì™€æ‰“íŒ¨í‚¤ì§€
  build:
    runs-on: ubuntu-latest
    needs: [quality-check, unit-tests, integration-tests]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build project
      run: npm run build

    - name: Create distribution package
      run: npm pack

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: dist-package
        path: |
          dist/
          *.tgz

  # Dockerë¹Œë“œ
  docker-build:
    runs-on: ubuntu-latest
    needs: [build]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Docker Hub
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: openclaudecode/open-claude-code
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # ë¦´ë¦¬ìŠ¤åˆ°NPM
  publish-npm:
    runs-on: ubuntu-latest
    needs: [build, docker-build, security-scan]
    if: github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        registry-url: https://${{ env.REGISTRY_URL }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build project
      run: npm run build

    - name: Publish to NPM
      run: npm publish --access public
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  # ë¦´ë¦¬ìŠ¤GitHub Release
  publish-github:
    runs-on: ubuntu-latest
    needs: [publish-npm]
    if: github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: dist-package

    - name: Generate changelog
      id: changelog
      run: |
        echo "## Changes" > CHANGELOG.md
        git log --pretty=format:"- %s (%h)" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> CHANGELOG.md

    - name: Update release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          *.tgz
          dist/**/*
        body_path: CHANGELOG.md
        generate_release_notes: true

  # ë°°í¬ë¬¸ì„œ
  deploy-docs:
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build documentation
      run: npm run docs:build

    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs/dist

  # ì•Œë¦¼ì™€ë¦¬í¬íŠ¸
  notify:
    runs-on: ubuntu-latest
    needs: [publish-npm, publish-github, deploy-docs]
    if: always()
    
    steps:
    - name: Notify Slack on success
      if: success()
      uses: rtCamp/action-slack-notify@v2
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        SLACK_MESSAGE: 'âœ… Open Claude Code release completed successfully!'

    - name: Notify Slack on failure
      if: failure()
      uses: rtCamp/action-slack-notify@v2
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        SLACK_MESSAGE: 'âŒ Open Claude Code release failed!'
```

**íŒŒì¼ ê²½ë¡œ**: `scripts/release.js`
**íŒŒì¼ ë‚´ìš©**:
```javascript
#!/usr/bin/env node

/**
 * Open Claude Code ë¦´ë¦¬ìŠ¤ìŠ¤í¬ë¦½íŠ¸
 * ìë™í™”ë²„ì „ ê´€ë¦¬, ë¹Œë“œ, í…ŒìŠ¤íŠ¸ì™€ë°°í¬ í”„ë¡œì„¸ìŠ¤
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const semver = require('semver');

class ReleaseManager {
  constructor() {
    this.packagePath = path.join(process.cwd(), 'package.json');
    this.package = JSON.parse(fs.readFileSync(this.packagePath, 'utf8'));
    this.currentVersion = this.package.version;
  }

  /**
   * æ‰§è¡Œì»¤ë§¨ë“œ
   */
  exec(command, options = {}) {
    console.log(`ğŸ”§ æ‰§è¡Œ: ${command}`);
    try {
      const result = execSync(command, { 
        stdio: 'inherit', 
        encoding: 'utf8',
        ...options 
      });
      return result;
    } catch (error) {
      console.error(`âŒ ì»¤ë§¨ë“œæ‰§è¡Œì‹¤íŒ¨: ${command}`);
      console.error(error.message);
      process.exit(1);
    }
  }

  /**
   * í™•ì¸å·¥ä½œë””ë ‰í† ë¦¬ìƒíƒœ
   */
  checkWorkingDirectory() {
    console.log('ğŸ” í™•ì¸å·¥ä½œë””ë ‰í† ë¦¬ìƒíƒœ...');
    
    try {
      const status = execSync('git status --porcelain', { encoding: 'utf8' });
      if (status.trim()) {
        console.error('âŒ å·¥ä½œë””ë ‰í† ë¦¬ä¸å¹²å‡€, è¯·å…ˆì œì¶œæ‰€ìˆìŒæ›´æ”¹');
        console.error(status);
        process.exit(1);
      }
    } catch (error) {
      console.error('âŒ ì—†ìŒæ³•í™•ì¸Gitìƒíƒœ');
      process.exit(1);
    }

    console.log('âœ… å·¥ä½œë””ë ‰í† ë¦¬å¹²å‡€');
  }

  /**
   * ì‹¤í–‰í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸
   */
  runTests() {
    console.log('ğŸ§ª ì‹¤í–‰ì „ì²´í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸...');
    
    const testCommands = [
      'npm run lint',
      'npm run type-check',
      'npm run test:unit',
      'npm run test:integration',
      'npm run test:benchmark'
    ];

    for (const command of testCommands) {
      this.exec(command);
    }

    console.log('âœ… æ‰€ìˆìŒí…ŒìŠ¤íŠ¸é€šè¿‡');
  }

  /**
   * ì—…ë°ì´íŠ¸ë²„ì „å·
   */
  updateVersion(releaseType) {
    console.log(`ğŸ“ˆ ì—…ë°ì´íŠ¸ë²„ì „å· (${releaseType})...`);
    
    const newVersion = semver.inc(this.currentVersion, releaseType);
    if (!newVersion) {
      console.error(`âŒ ì—†ìŒæ•ˆì˜ë¦´ë¦¬ìŠ¤íƒ€ì…: ${releaseType}`);
      process.exit(1);
    }

    // ì—…ë°ì´íŠ¸package.json
    this.package.version = newVersion;
    fs.writeFileSync(this.packagePath, JSON.stringify(this.package, null, 2) + '\n');

    console.log(`âœ… ë²„ì „å·²ì—…ë°ì´íŠ¸: ${this.currentVersion} â†’ ${newVersion}`);
    return newVersion;
  }

  /**
   * ç”Ÿæˆë³€ê²½ë¡œê·¸
   */
  generateChangelog(newVersion) {
    console.log('ğŸ“ ç”Ÿæˆë³€ê²½ë¡œê·¸...');
    
    try {
      const lastTag = execSync('git describe --tags --abbrev=0', { encoding: 'utf8' }).trim();
      const commits = execSync(`git log ${lastTag}..HEAD --pretty=format:"- %s (%h)"`, { encoding: 'utf8' });
      
      const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');
      let changelog = '';
      
      if (fs.existsSync(changelogPath)) {
        changelog = fs.readFileSync(changelogPath, 'utf8');
      }

      const newEntry = `\n## [${newVersion}] - ${new Date().toISOString().split('T')[0]}\n\n${commits}\n`;
      const updatedChangelog = `# Changelog\n${newEntry}${changelog.replace(/^# Changelog\n/, '')}`;
      
      fs.writeFileSync(changelogPath, updatedChangelog);
      console.log('âœ… ë³€ê²½ë¡œê·¸å·²ì—…ë°ì´íŠ¸');
    } catch (error) {
      console.warn('âš ï¸ ì—†ìŒæ³•ç”Ÿæˆë³€ê²½ë¡œê·¸:', error.message);
    }
  }

  /**
   * ë¹Œë“œí”„ë¡œì íŠ¸
   */
  build() {
    console.log('ğŸ—ï¸ ë¹Œë“œí”„ë¡œì íŠ¸...');
    this.exec('npm run build');
    console.log('âœ… ë¹Œë“œå®Œæˆ');
  }

  /**
   * ìƒì„±Gitíƒ­
   */
  createGitTag(version) {
    console.log(`ğŸ·ï¸ ìƒì„±Gitíƒ­ v${version}...`);
    
    this.exec('git add .');
    this.exec(`git commit -m "chore: release v${version}"`);
    this.exec(`git tag -a v${version} -m "Release v${version}"`);
    
    console.log('âœ… Gitíƒ­å·²ìƒì„±');
  }

  /**
   * í‘¸ì‹œåˆ°ì›ê²©ì €ì¥ì†Œ
   */
  pushToRemote() {
    console.log('ğŸš€ í‘¸ì‹œåˆ°ì›ê²©ì €ì¥ì†Œ...');
    
    this.exec('git push origin main');
    this.exec('git push origin --tags');
    
    console.log('âœ… å·²í‘¸ì‹œåˆ°ì›ê²©ì €ì¥ì†Œ');
  }

  /**
   * ë¦´ë¦¬ìŠ¤åˆ°NPM
   */
  publishToNpm(tag = 'latest') {
    console.log(`ğŸ“¦ ë¦´ë¦¬ìŠ¤åˆ°NPM (íƒ­: ${tag})...`);
    
    // í™•ì¸NPMë¡œê·¸ì¸ìƒíƒœ
    try {
      this.exec('npm whoami', { stdio: 'pipe' });
    } catch (error) {
      console.error('âŒ è¯·å…ˆë¡œê·¸ì¸NPM: npm login');
      process.exit(1);
    }

    // æ‰§è¡Œë¦´ë¦¬ìŠ¤
    this.exec(`npm publish --tag ${tag} --access public`);
    
    console.log('âœ… å·²ë¦´ë¦¬ìŠ¤åˆ°NPM');
  }

  /**
   * ìƒì„±GitHub Release
   */
  createGithubRelease(version) {
    console.log('ğŸ™ ìƒì„±GitHub Release...');
    
    try {
      const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');
      let releaseNotes = `Release v${version}`;
      
      if (fs.existsSync(changelogPath)) {
        const changelog = fs.readFileSync(changelogPath, 'utf8');
        const versionSection = changelog.match(new RegExp(`## \\[${version}\\][\\s\\S]*?(?=## \\[|$)`))?.[0];
        if (versionSection) {
          releaseNotes = versionSection.replace(`## [${version}]`, '').trim();
        }
      }

      // ä½¿ç”¨GitHub CLIìƒì„±Release
      this.exec(`gh release create v${version} --title "v${version}" --notes "${releaseNotes}"`);
      
      console.log('âœ… GitHub Releaseå·²ìƒì„±');
    } catch (error) {
      console.warn('âš ï¸ ì—†ìŒæ³•ìƒì„±GitHub Release:', error.message);
      console.warn('è¯·æ‰‹åŠ¨ìƒì„±GitHub Release');
    }
  }

  /**
   * æ‰§è¡Œì „ì²´ë°°í¬ í”„ë¡œì„¸ìŠ¤
   */
  release(releaseType = 'patch', options = {}) {
    console.log(`ğŸš€ å¼€å§‹ë°°í¬ í”„ë¡œì„¸ìŠ¤ (${releaseType})...\n`);

    // 1. í™•ì¸å·¥ä½œë””ë ‰í† ë¦¬
    if (!options.skipChecks) {
      this.checkWorkingDirectory();
    }

    // 2. ì‹¤í–‰í…ŒìŠ¤íŠ¸
    if (!options.skipTests) {
      this.runTests();
    }

    // 3. ì—…ë°ì´íŠ¸ë²„ì „
    const newVersion = this.updateVersion(releaseType);

    // 4. ç”Ÿæˆë³€ê²½ë¡œê·¸
    this.generateChangelog(newVersion);

    // 5. ë¹Œë“œí”„ë¡œì íŠ¸
    this.build();

    // 6. ìƒì„±Gitíƒ­
    this.createGitTag(newVersion);

    // 7. í‘¸ì‹œåˆ°ì›ê²©
    if (!options.dryRun) {
      this.pushToRemote();
    }

    // 8. ë¦´ë¦¬ìŠ¤åˆ°NPM
    if (!options.dryRun && !options.skipNpm) {
      const npmTag = releaseType === 'prerelease' ? 'beta' : 'latest';
      this.publishToNpm(npmTag);
    }

    // 9. ìƒì„±GitHub Release
    if (!options.dryRun && !options.skipGithub) {
      this.createGithubRelease(newVersion);
    }

    console.log(`\nğŸ‰ ë¦´ë¦¬ìŠ¤å®Œæˆï¼ë²„ì „ v${newVersion} å·²ì„±ê³µë¦´ë¦¬ìŠ¤`);
    console.log(`ğŸ“¦ NPM: https://www.npmjs.com/package/open-claude-code`);
    console.log(`ğŸ™ GitHub: https://github.com/open-claude-code/open-claude-code/releases/tag/v${newVersion}`);

    return newVersion;
  }

  /**
   * í‘œì‹œå¸®åŠ©ì •ë³´
   */
  showHelp() {
    console.log(`
Open Claude Code ë¦´ë¦¬ìŠ¤ë„êµ¬

ç”¨æ³•:
  node scripts/release.js [ì˜µì…˜] <ë¦´ë¦¬ìŠ¤íƒ€ì…>

ë¦´ë¦¬ìŠ¤íƒ€ì…:
  patch     íŒ¨ì¹˜ë²„ì „ (1.0.0 â†’ 1.0.1)
  minor     æ¬¡è¦ë²„ì „ (1.0.0 â†’ 1.1.0)  
  major     ä¸»è¦ë²„ì „ (1.0.0 â†’ 2.0.0)
  prerelease é¢„ë¦´ë¦¬ìŠ¤ë²„ì „ (1.0.0 â†’ 1.0.1-0)

ì˜µì…˜:
  --dry-run       æ¨¡æ‹Ÿë¦´ë¦¬ìŠ¤, ä¸ì‹¤ì œí‘¸ì‹œì™€ë¦´ë¦¬ìŠ¤
  --skip-tests    è·³è¿‡í…ŒìŠ¤íŠ¸
  --skip-checks   è·³è¿‡å·¥ä½œë””ë ‰í† ë¦¬í™•ì¸
  --skip-npm      è·³è¿‡NPMë¦´ë¦¬ìŠ¤
  --skip-github   è·³è¿‡GitHub Releaseìƒì„±
  --help          í‘œì‹œæ­¤å¸®åŠ©ì •ë³´

ç¤ºä¾‹:
  node scripts/release.js patch
  node scripts/release.js minor --dry-run
  node scripts/release.js major --skip-tests
`);
  }
}

// ä¸»í”„ë¡œê·¸ë¨
function main() {
  const args = process.argv.slice(2);
  const releaseManager = new ReleaseManager();

  // è§£æëª…ë ¹ì¤„ë§¤ê°œë³€ìˆ˜
  const options = {
    dryRun: args.includes('--dry-run'),
    skipTests: args.includes('--skip-tests'),
    skipChecks: args.includes('--skip-checks'),
    skipNpm: args.includes('--skip-npm'),
    skipGithub: args.includes('--skip-github'),
    help: args.includes('--help')
  };

  const releaseType = args.find(arg => !arg.startsWith('--')) || 'patch';

  // í‘œì‹œå¸®åŠ©
  if (options.help) {
    releaseManager.showHelp();
    return;
  }

  // ê²€ì¦ë¦´ë¦¬ìŠ¤íƒ€ì…
  const validTypes = ['patch', 'minor', 'major', 'prerelease'];
  if (!validTypes.includes(releaseType)) {
    console.error(`âŒ ì—†ìŒæ•ˆì˜ë¦´ë¦¬ìŠ¤íƒ€ì…: ${releaseType}`);
    console.error(`ìˆìŒæ•ˆíƒ€ì…: ${validTypes.join(', ')}`);
    process.exit(1);
  }

  // æ‰§è¡Œë¦´ë¦¬ìŠ¤
  try {
    releaseManager.release(releaseType, options);
  } catch (error) {
    console.error('âŒ ë¦´ë¦¬ìŠ¤ì‹¤íŒ¨:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = ReleaseManager;
```

---

## ğŸ“‹ ë‹¨ê³„5ì™„ë£Œ í™•ì¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ëŠ¥ ê²€ì¦ í•­ëª©

**ì„±ëŠ¥ ìµœì í™”** âœ…
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ìµœì í™” < 512MB
- [ ] ì‘ë‹µæ—¶é—´ìµœì í™” < 2s
- [ ] ë„¤íŠ¸ì›Œí¬ì—°ê²°ìµœì í™”å®Œæˆ
- [ ] ì‹œì‘æ—¶é—´ìµœì í™” < 3s
- [ ] ë™ì‹œ ì²˜ë¦¬ê¸°ëŠ¥æå‡

**í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œ** âœ…
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œç‡ > 90%
- [ ] í†µí•© í…ŒìŠ¤íŠ¸é€šè¿‡ç‡ 100%
- [ ] ì—”ë“œíˆ¬ì—”ë“œ í…ŒìŠ¤íŠ¸ì „ì²´
- [ ] æ€§èƒ½ë²¤ì¹˜ë§ˆí¬í…ŒìŠ¤íŠ¸å»ºç«‹
- [ ] ë³´ì•ˆ í…ŒìŠ¤íŠ¸é€šè¿‡

**ë¬¸ì„œ ì™„ì„±** âœ…
- [ ] ì‚¬ìš©ìê°€ì´ë“œì „ì²´
- [ ] APIë¬¸ì„œìƒì„¸
- [ ] ê°œë°œè€…ê°€ì´ë“œæ¸…æ™°
- [ ] ì¥ì• í•´ê²°ë§¤ë‰´ì–¼
- [ ] ì„¤ì •è¯´æ˜ì „ì²´

**CI/CDí”„ë¡œì„¸ìŠ¤** âœ…
- [ ] ìë™í™”ë¹Œë“œì„±ê³µ
- [ ] å¤ší”Œë«í¼í…ŒìŠ¤íŠ¸é€šè¿‡
- [ ] ìë™í™”ë°°í¬ì„¤ì •
- [ ] ë²„ì „ ê´€ë¦¬ìë™í™”
- [ ] ë°°í¬ í”„ë¡œì„¸ìŠ¤ì „ì²´

**í”„ë¡œë•ì…˜ìµœì í™”** âœ…
- [ ] Dockeré•œåƒìµœì í™”
- [ ] ë³´ì•ˆæ‰«æé€šè¿‡
- [ ] ëª¨ë‹ˆí„°ë§ì‹œìŠ¤í…œì„¤ì •
- [ ] ë¡œê·¸ì‹œìŠ¤í…œå®Œå–„
- [ ] ì˜¤ë¥˜ ì²˜ë¦¬åŠ å¼º

### í’ˆì§ˆ ê²€ì¦ í•­ëª©

**ì½”ë“œ í’ˆì§ˆ** âœ…
- [ ] ESLintê·œì¹™é€šè¿‡
- [ ] TypeScriptíƒ€ì…ë³´ì•ˆ
- [ ] ì½”ë“œí˜•ì‹ç»Ÿä¸€
- [ ] ë³´ì•ˆæ¼æ´æ‰«æé€šè¿‡
- [ ] ì˜ì¡´ì„±å®¡è®¡æ¸…æ´

**æ€§èƒ½ë²¤ì¹˜ë§ˆí¬** âœ…
- [ ] ë©”ëª¨ë¦¬ë²¤ì¹˜ë§ˆí¬è¾¾æ ‡
- [ ] ì‘ë‹µæ—¶é—´ë²¤ì¹˜ë§ˆí¬è¾¾æ ‡
- [ ] ååé‡ë²¤ì¹˜ë§ˆí¬è¾¾æ ‡
- [ ] ë™ì‹œê¸°ëŠ¥ë²¤ì¹˜ë§ˆí¬è¾¾æ ‡
- [ ] ì‹œì‘æ—¶é—´ë²¤ì¹˜ë§ˆí¬è¾¾æ ‡

**ì‚¬ìš©ì ê²½í—˜** âœ…
- [ ] ç•Œé¢ì‘ë‹µæµç•…
- [ ] ì˜¤ë¥˜íŒíŠ¸å‹å¥½
- [ ] å¸®åŠ©ë¬¸ì„œæ˜“æ‡‚
- [ ] ì„¤ì •è¿‡ç¨‹ê°„ë‹¨
- [ ] åŠŸèƒ½å‘ç°æ€§å¥½

### ë°°í¬ ì¤€å¤‡í”„ë¡œì íŠ¸

**íŒ¨í‚¤ì§€ê´€ë¦¬** âœ…
- [ ] NPMíŒ¨í‚¤ì§€ì„¤ì •æ­£ç¡®
- [ ] ì˜ì¡´ì„±ê´€ê³„æ¸…æ™°
- [ ] ë²„ì „å·ê´€ë¦¬ì‚¬ì–‘
- [ ] ë¦´ë¦¬ìŠ¤ìŠ¤í¬ë¦½íŠ¸å®Œå–„
- [ ] åˆ†å‘æ¸ é“ì„¤ì •

**ë°°í¬ì„¤ì •** âœ…
- [ ] Dockeré•œåƒë¹Œë“œ
- [ ] Kubernetesì„¤ì •
- [ ] í™˜ê²½ë³€ìˆ˜ê´€ë¦¬
- [ ] ì„¤ì •íŒŒì¼í…œí”Œë¦¿
- [ ] ë°°í¬ë¬¸ì„œì „ì²´

**ëª¨ë‹ˆí„°ë§ì™€ç»´æŠ¤** âœ…
- [ ] æ€§èƒ½ëª¨ë‹ˆí„°ë§ì„¤ì •
- [ ] ì˜¤ë¥˜è¿½è¸ªì‹œìŠ¤í…œ
- [ ] ë¡œê·¸æ”¶é›†ì„¤ì •
- [ ] å¥åº·í™•ì¸ì¸í„°í˜ì´ìŠ¤
- [ ] ç»´æŠ¤ë¬¸ì„œì „ì²´

---

## ğŸ¯ í”„ë¡œì íŠ¸æ€»ç»“

ç»è¿‡5ä¸ªë‹¨ê³„ì˜ì „ì²´ê°œë°œ, Open Claude Codeç°å·²å…·å¤‡: 

### ğŸ—ï¸ ì „ì²´ì˜æŠ€æœ¯æ¶æ„
1. **Agentí•µì‹¬å¼•æ“**: h2Aë¹„ë™ê¸°ë©”ì‹œì§€í, nOä¸»ìˆœí™˜, ì‹¤ì‹œê°„ Steeringë©”ì»¤ë‹ˆì¦˜
2. **ë„êµ¬æ‰§è¡Œì‹œìŠ¤í…œ**: 15+å†…ç½®ë„êµ¬, ë™ì‹œì œì–´, ë³´ì•ˆê¶Œí•œê²€ì¦
3. **Planëª¨ë“œë©”ì»¤ë‹ˆì¦˜**: 4ìƒíƒœìˆœí™˜, exit_plan_modeë„êµ¬, ë³´ì•ˆë¶„ì„
4. **MCPìƒíƒœê³„ì‹œìŠ¤í…œ**: 4ç§ì „ì†¡í”„ë¡œí† ì½œ, ë‹¤ì¤‘ ì„œë²„ ê´€ë¦¬, í™•ì¥í”„ë ˆì„ì›Œí¬
5. **IDEæ·±åº¦í†µí•©**: LSPì§„ë‹¨, ì½”ë“œæ‰§è¡Œ, ì‹¤ì‹œê°„ë™ê¸°í™”

### ğŸš€ å¼ºå¤§ì˜åŠŸèƒ½ç‰¹æ€§
1. **ì‹¤ì‹œê°„äº¤äº’ê¸°ëŠ¥**: ì‚¬ìš©ìå¯åœ¨AIæ‰§è¡Œè¿‡ç¨‹ä¸­ì‹¤ì‹œê°„ê°€ì´ë“œ
2. **å¤šAgentåä½œ**: Taskë„êµ¬ì§€ì›ë³‘ë ¬å­ä»»åŠ¡æ‰§è¡Œ
3. **ë³´ì•ˆì œì–´ë©”ì»¤ë‹ˆì¦˜**: Planëª¨ë“œ, ë„êµ¬í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸, ê¶Œí•œê²€ì¦
4. **í™•ì¥ìƒíƒœê³„ì‹œìŠ¤í…œ**: MCPí”„ë¡œí† ì½œ, ç¬¬ä¸‰æ–¹í”ŒëŸ¬ê·¸ì¸, í‘œì¤€åŒ–API
5. **ä¼˜ç§€ì‚¬ìš©ì ê²½í—˜**: íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œ, ë‹¨ì¶• ëª…ë ¹, IDEí†µí•©

### ğŸ“Š å“è¶Šì˜æŠ€æœ¯ì§€í‘œ
1. **æ€§èƒ½è¡¨ç°**: ì‘ë‹µæ—¶é—´ < 2s, ë©”ëª¨ë¦¬ ì‚¬ìš© < 512MB
2. **ì½”ë“œ í’ˆì§ˆ**: í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œç‡ > 90%, TypeScriptíƒ€ì…ë³´ì•ˆ
3. **í”„ë¡œë•ì…˜å°±ç»ª**: ì „ì²´CI/CDí”„ë¡œì„¸ìŠ¤, Dockerë°°í¬, ëª¨ë‹ˆí„°ë§ì„¤ì •
4. **ë¬¸ì„œ ì™„ì„±**: ì‚¬ìš©ìê°€ì´ë“œ, APIë¬¸ì„œ, ê°œë°œê°€ì´ë“œ, ì¥ì• í•´ê²°
5. **å¼€æºìƒíƒœê³„**: MITè®¸å¯è¯, è´¡çŒ®ê°€ì´ë“œ, ç¤¾åŒºì§€ì›

### ğŸ’¡ åˆ›æ–°æŠ€æœ¯ëŒíŒŒ
1. **ì‹¤ì‹œê°„ Steeringë©”ì»¤ë‹ˆì¦˜**: å¼€åˆ›AIåŠ©æ‰‹ì‹¤ì‹œê°„äº¤äº’æ–°èŒƒå¼
2. **åˆ†å±‚å¤šAgentæ¶æ„**: êµ¬í˜„trueæ­£ì˜å¤šAgentë³‘ë ¬åä½œ
3. **Planëª¨ë“œë³´ì•ˆì œì–´**: ç¡®ä¿AIåœ¨ë³´ì•ˆí”„ë ˆì„ì›Œí¬å†…æ‰§è¡Œ
4. **MCPí”„ë¡œí† ì½œæ·±åº¦í†µí•©**: í‘œì¤€åŒ–ì˜í™•ì¥ì™€í†µí•©ë©”ì»¤ë‹ˆì¦˜
5. **IDEë„¤ì´í‹°ë¸Œí†µí•©**: ä¸ç°ä»£IDEì˜æ·±åº¦åŒå‘í†µí•©

Open Claude Codeå·²æˆä¸ºä¸€ä¸ªì „ì²´, å¼ºå¤§, å¯í™•ì¥ì˜å¼€æºAIç¼–ç¨‹åŠ©æ‰‹, ä¸ºê°œë°œè€…ç¤¾åŒºæä¾›äº†ä¸Claude Codeç›¸åŒæ°´å¹³ì˜AIç¼–ç¨‹ä½“éªŒ, åŒæ—¶ä¿æŒäº†å®Œå…¨ì˜å¼€æ”¾æ€§ì™€å¯í™•ì¥æ€§. 

è¿™ì€/ëŠ” ë‚˜íƒ€ëƒ„ê¸°ë°˜é€†å‘ë¶„ì„ì˜å¼€æºé‡å»ºí”„ë¡œì íŠ¸ì˜åœ†æ»¡ì„±ê³µ, ä¸ºAIç¼–ç¨‹ë„êµ¬ì˜å‘å±•íŠ¸ë¦¬ç«‹äº†æ–°ì˜æ ‡æ†. 