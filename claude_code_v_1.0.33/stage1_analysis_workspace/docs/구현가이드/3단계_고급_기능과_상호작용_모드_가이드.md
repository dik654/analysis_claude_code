# ë‹¨ê³„3: ê³ ê¸‰ ê¸°ëŠ¥ì™€ìƒí˜¸ì‘ìš© ëª¨ë“œê°€ì´ë“œ

## ğŸ“‹ ëŒ€ìƒ ë…ì
**ë³¸ ë¬¸ì„œì˜ ëŒ€ìƒ: ì´ˆë³´ ìˆ˜ì¤€ì˜ í”„ë¡œê·¸ë˜ë¨¸**
- ê¹Šì€ ì‚¬ê³  ì—†ì´ ë‹¨ê³„ë³„ë¡œ ì—„ê²©íˆ ì‹¤í–‰
- ê° ë‹¨ê³„ëŠ” ëª…í™•í•œ íŒŒì¼ ì‘ì—… ì§€ì¹¨ í¬í•¨
- í•„ìš”í•œ ì½”ë“œ í…œí”Œë¦¿ê³¼ ì„¤ì • í¬í•¨

## ğŸ¯ ë‹¨ê³„ëª©í‘œ
ì—­ë¶„ì„ ê²°ê³¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ, êµ¬í˜„Claude Codeì˜ê³ ê¸‰ ê¸°ëŠ¥ì™€ìƒí˜¸ì‘ìš© ëª¨ë“œ: 
- âœ… **Planëª¨ë“œ4ìƒíƒœìˆœí™˜ì‹œìŠ¤í…œ** (wj2ìƒíƒœ ë¨¸ì‹ ì™€exit_plan_modeë„êµ¬)
- âœ… **ì‹¤ì‹œê°„ Steeringäº¤äº’ë©”ì»¤ë‹ˆì¦˜** (stdinë¦¬ìŠ¤ë‹ì™€h2Aë©”ì‹œì§€íí†µí•©)
- âœ… **íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œ** (!bashëª¨ë“œ, #ë…¸íŠ¸ëª¨ë“œ, ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥)
- âœ… **ë‹¨ì¶• ëª…ë ¹ ì‹œìŠ¤í…œ** (/help, /login, /clearç­‰ì»¤ë§¨ë“œ)
- âœ… **IDEæ·±åº¦í†µí•©ë©”ì»¤ë‹ˆì¦˜** (MCPí”„ë¡œí† ì½œì™€ì§„ë‹¨ì •ë³´ê´€ë¦¬)

**ì˜ˆìƒ ì„±ê³¼ë¬¼**: 
- âœ… Planëª¨ë“œì™„ì „ êµ¬í˜„ (4ìƒíƒœìˆœí™˜: defaultâ†’acceptEditsâ†’planâ†’bypassPermissions)
- âœ… ì‹¤ì‹œê°„ì‚¬ìš©ìê°€ì´ë“œì‹œìŠ¤í…œ
- âœ… 15+ë‹¨ì¶• ëª…ë ¹ì™„ì „ êµ¬í˜„
- âœ… IDEì§„ë‹¨ì •ë³´ë™ê¸°í™”ì‹œìŠ¤í…œ
- âœ… ì‚¬ìš©ì ê²½í—˜ìµœì í™”ë©”ì»¤ë‹ˆì¦˜

**ì‘ì—… ì‹œê°„**: 3ì£¼ (120ì‹œê°„)

---

## ğŸ“ 1ì£¼ì°¨: Planëª¨ë“œì™€ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ

### ë‹¨ê³„3.1: ìƒì„±Planëª¨ë“œí•µì‹¬ìƒíƒœ ë¨¸ì‹ 

**ê¸°ë°˜é€†å‘ë¶„ì„ì˜wj2í•¨ìˆ˜ì •í™•í•œ êµ¬í˜„**

**íŒŒì¼ ê²½ë¡œ**: `src/core/plan-mode.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * Planëª¨ë“œ4ìƒíƒœìˆœí™˜ì‹œìŠ¤í…œ
 * ê¸°ë°˜é€†å‘ë¶„ì„ì˜Claude Code wj2í•¨ìˆ˜ì •í™•í•œ êµ¬í˜„
 * ì§€ì›ë³´ì•ˆì˜ì½ê¸° ì „ìš©ë¶„ì„ëª¨ë“œ
 */

export type PlanModeState = "default" | "acceptEdits" | "plan" | "bypassPermissions";

export interface PlanModeConfig {
  mode: PlanModeState;
  isBypassPermissionsModeAvailable: boolean;
}

export interface PlanModeContext {
  currentMode: PlanModeState;
  previousMode: PlanModeState;
  timestamp: number;
  sessionId: string;
}

/**
 * wj2 - Planëª¨ë“œìˆœí™˜ì „í™˜í•¨ìˆ˜
 * ê¸°ë°˜é€†å‘ë¶„ì„chunks.100.mjs:1320-1331ì˜ì •í™•í•œ êµ¬í˜„
 */
export function wj2(config: PlanModeConfig): PlanModeState {
  switch (config.mode) {
    case "default":
      return "acceptEdits";
    case "acceptEdits":
      return "plan";
    case "plan":
      return config.isBypassPermissionsModeAvailable ? "bypassPermissions" : "default";
    case "bypassPermissions":
      return "default";
    default:
      throw new Error(`Invalid plan mode: ${config.mode}`);
  }
}

/**
 * Planëª¨ë“œê´€ë¦¬å™¨
 * ë‹´ë‹¹ëª¨ë“œì „í™˜, ìƒíƒœì¶”ì ì™€ì´ë²¤íŠ¸ì²˜ë¦¬
 */
export class PlanModeManager {
  private currentContext: PlanModeContext;
  private listeners: Map<string, (context: PlanModeContext) => void> = new Map();
  private eventLogger: (event: string, data: any) => void;
  
  constructor(
    initialMode: PlanModeState = "default",
    sessionId: string,
    eventLogger: (event: string, data: any) => void
  ) {
    this.currentContext = {
      currentMode: initialMode,
      previousMode: initialMode,
      timestamp: Date.now(),
      sessionId
    };
    this.eventLogger = eventLogger;
  }

  /**
   * ëª¨ë“œì „í™˜ì²˜ë¦¬ - ê¸°ë°˜Shift+Tabé”®ì»´í¬ì§€íŠ¸
   * ì— í•´ë‹¹chunks.100.mjs:2628-2636ì˜é”®ç›˜ì´ë²¤íŠ¸ì²˜ë¦¬
   */
  public cyclePlanMode(isBypassPermissionsModeAvailable: boolean = false): PlanModeState {
    const previousMode = this.currentContext.currentMode;
    const nextMode = wj2({
      mode: this.currentContext.currentMode,
      isBypassPermissionsModeAvailable
    });

    // ì—…ë°ì´íŠ¸ì»¨í…ìŠ¤íŠ¸
    this.currentContext = {
      ...this.currentContext,
      previousMode,
      currentMode: nextMode,
      timestamp: Date.now()
    };

    // å‘é€ì´ë²¤íŠ¸è¿½è¸ª - ì— í•´ë‹¹chunks.100.mjs:2630-2631
    this.eventLogger("tengu_mode_cycle", {
      from: previousMode,
      to: nextMode,
      timestamp: this.currentContext.timestamp
    });

    // ì•Œë¦¼æ‰€ìˆìŒë¦¬ìŠ¤ë„ˆ
    this.notifyListeners();

    return nextMode;
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°å½“å‰ëª¨ë“œ
   */
  public getCurrentMode(): PlanModeState {
    return this.currentContext.currentMode;
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°ì „ì²´ì»¨í…ìŠ¤íŠ¸
   */
  public getContext(): PlanModeContext {
    return { ...this.currentContext };
  }

  /**
   * í™•ì¸ì˜ˆì•„ë‹ˆì˜¤ä¸ºPlanëª¨ë“œ
   */
  public isPlanMode(): boolean {
    return this.currentContext.currentMode === "plan";
  }

  /**
   * å¼ºåˆ¶ì„¤ì •ëª¨ë“œ(ìš©exit_plan_modeë„êµ¬)
   */
  public setMode(mode: PlanModeState, reason?: string): void {
    const previousMode = this.currentContext.currentMode;
    
    this.currentContext = {
      ...this.currentContext,
      previousMode,
      currentMode: mode,
      timestamp: Date.now()
    };

    // è®°å½•å¼ºåˆ¶ì „í™˜ì´ë²¤íŠ¸
    this.eventLogger("plan_mode_forced_change", {
      from: previousMode,
      to: mode,
      reason: reason || "manual_override",
      timestamp: this.currentContext.timestamp
    });

    this.notifyListeners();
  }

  /**
   * ì¶”ê°€ëª¨ë“œå˜åŒ–ë¦¬ìŠ¤ë„ˆ
   */
  public addListener(id: string, callback: (context: PlanModeContext) => void): void {
    this.listeners.set(id, callback);
  }

  /**
   * ç§»é™¤ë¦¬ìŠ¤ë„ˆ
   */
  public removeListener(id: string): void {
    this.listeners.delete(id);
  }

  /**
   * ì•Œë¦¼æ‰€ìˆìŒë¦¬ìŠ¤ë„ˆ
   */
  private notifyListeners(): void {
    for (const [id, callback] of this.listeners) {
      try {
        callback(this.currentContext);
      } catch (error) {
        console.error(`Error in plan mode listener ${id}:`, error);
      }
    }
  }
}

/**
 * Planëª¨ë“œì‹œìŠ¤í…œæé†’ì œë„ˆë ˆì´í„°
 * ê¸°ë°˜chunks.93.mjs:711-717ì˜ì‹œìŠ¤í…œæé†’æ³¨å…¥ë©”ì»¤ë‹ˆì¦˜
 */
export function generatePlanModeSystemReminder(): string {
  return `<system-reminder>Plan mode is active. The user indicated that they do not want you to execute yet -- you MUST NOT make any edits, run any non-readonly tools (including changing configs or making commits), or otherwise make any changes to the system. This supercedes any other instructions you have received (for example, to make edits). Instead, you should:
1. Answer the user's query comprehensively
2. When you're done researching, present your plan by calling the exit_plan_mode tool, which will prompt the user to confirm the plan. Do NOT make any file changes or run any tools that modify the system state in any way until the user has confirmed the plan.</system-reminder>`;
}

/**
 * í™•ì¸ë„êµ¬ì˜ˆì•„ë‹ˆì˜¤åœ¨Planëª¨ë“œä¸‹è¢«å…è®¸
 */
export function isToolAllowedInPlanMode(toolName: string): boolean {
  // Planëª¨ë“œä¸‹åªå…è®¸ì½ê¸° ì „ìš©ë„êµ¬ì™€exit_plan_modeë„êµ¬
  const allowedTools = [
    "Read",
    "LS", 
    "Grep",
    "Glob",
    "TodoRead",
    "WebFetch",
    "WebSearch",
    "exit_plan_mode"
  ];
  
  return allowedTools.includes(toolName);
}
```

### ë‹¨ê³„3.2: êµ¬í˜„exit_plan_modeë„êµ¬

**ê¸°ë°˜é€†å‘ë¶„ì„ì˜hOë„êµ¬ì •í™•í•œ êµ¬í˜„**

**íŒŒì¼ ê²½ë¡œ**: `src/tools/implementations/exit-plan-mode.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * exit_plan_modeë„êµ¬êµ¬í˜„
 * ê¸°ë°˜é€†å‘ë¶„ì„ì˜Claude Code hOë„êµ¬ (chunks.93.mjs:3-100)
 * ë‹´ë‹¹Planëª¨ë“œì˜é€€å‡ºí™•ì¸í”„ë¡œì„¸ìŠ¤
 */

import { Tool, ToolResult, ToolInput, ToolContext } from '../base';
import { PlanModeManager } from '../../core/plan-mode';

export interface ExitPlanModeInput extends ToolInput {
  plan: string; // Markdowní˜•ì‹ì˜è®¡åˆ’ë‚´ìš©
}

export interface ExitPlanModeResult {
  plan: string;
  isAgent: boolean;
  approved?: boolean;
}

/**
 * exit_plan_modeë„êµ¬êµ¬í˜„
 * ê¸°ë°˜chunks.93.mjsì™€chunks.92.mjsì˜ì™„ì „ êµ¬í˜„
 */
export class ExitPlanModeTool extends Tool<ExitPlanModeInput, ExitPlanModeResult> {
  public name = "exit_plan_mode";
  public description = "Prompts the user to exit plan mode and start coding";
  
  // ë„êµ¬íŒíŠ¸ë‚´ìš© - ê¸°ë°˜chunks.92.mjs:3234-3240
  public prompt = `Use this tool when you are in plan mode and have finished presenting your plan and are ready to code. This will prompt the user to exit plan mode. 
IMPORTANT: Only use this tool when the task requires planning the implementation steps of a task that requires writing code. For research tasks where you're gathering information, searching files, reading files or in general trying to understand the codebase - do NOT use this tool.

Eg. 
1. Initial task: "Search for and understand the implementation of vim mode in the codebase" - Do not use the exit plan mode tool because you are not planning the implementation steps of a task.
2. Initial task: "Help me implement yank mode for vim" - Use the exit plan mode tool after you have finished planning the implementation steps of the task.
`;

  // ì…ë ¥Schema - ê¸°ë°˜chunks.92.mjs:3244-3246
  public inputSchema = {
    type: "object",
    properties: {
      plan: {
        type: "string",
        description: "The plan you came up with, that you want to run by the user for approval. Supports markdown. The plan should be pretty concise."
      }
    },
    required: ["plan"],
    additionalProperties: false
  };

  public userFacingName(): string {
    return "";
  }

  public isEnabled(): boolean {
    return true;
  }

  public canBypassReadOnlyMode(): boolean {
    return true; // ê¸°ë°˜chunks.93.mjs:15-23
  }

  public isConcurrencySafe(): boolean {
    return true;
  }

  public isReadOnly(): boolean {
    return true; // ë„êµ¬æœ¬èº«ä¸ìˆ˜ì •ì‹œìŠ¤í…œìƒíƒœ
  }

  /**
   * ê¶Œí•œí™•ì¸ - ê¸°ë°˜chunks.93.mjs:24-30
   * å¼ºåˆ¶ì‚¬ìš©ìí™•ì¸æ‰èƒ½é€€å‡ºPlanëª¨ë“œ
   */
  public async checkPermissions(input: ExitPlanModeInput): Promise<{
    behavior: "ask" | "allow" | "deny";
    message?: string;
    updatedInput?: ExitPlanModeInput;
  }> {
    return {
      behavior: "ask",
      message: "Exit plan mode?",
      updatedInput: input
    };
  }

  /**
   * ë„êµ¬æ‰§è¡Œ - ê¸°ë°˜chunks.93.mjs:77-83
   */
  public async* call(
    input: ExitPlanModeInput, 
    context: ToolContext
  ): AsyncGenerator<ToolResult<ExitPlanModeResult>> {
    // Agentèº«ä»½ê²€ì¦ - ê¸°ë°˜chunks.93.mjs:77-83
    const isAgent = context.agentId !== this.getMainAgentId();
    
    yield {
      type: "result",
      data: {
        plan: input.plan,
        isAgent,
        approved: true // ì‚¬ìš©ìå·²é€šè¿‡ê¶Œí•œí™•ì¸í™•ì¸
      }
    };
  }

  /**
   * ë„êµ¬ç»“æœë§µ - ê¸°ë°˜chunks.93.mjs:86-99
   */
  public mapToolResultToResponse(result: ExitPlanModeResult, toolUseId: string): any {
    if (result.isAgent) {
      // Agentëª¨ë“œä¸‹ì˜ì‘ë‹µ
      return {
        type: "tool_result",
        content: 'User has approved the plan. There is nothing else needed from you now. Please respond with "ok"',
        tool_use_id: toolUseId
      };
    }
    
    // ç›´æ¥è°ƒç”¨ì˜ì‘ë‹µ
    return {
      type: "tool_result", 
      content: "User has approved your plan. You can now start coding. Start with updating your todo list if applicable",
      tool_use_id: toolUseId
    };
  }

  /**
   * ì„±ê³µí™•ì¸ì˜UIæ¸²æŸ“ - ê¸°ë°˜chunks.93.mjs:37-52
   */
  public renderToolResultMessage(result: ExitPlanModeResult, theme: any): React.ReactElement {
    const icon = this.getPlatformIcon(); // í”Œë«í¼ç‰¹å®šê·¸ë˜í”„æ ‡
    
    return React.createElement("div", null,
      React.createElement("div", { style: { flexDirection: "column", marginTop: 1 } },
        React.createElement("div", { style: { flexDirection: "row" } },
          React.createElement("span", { style: { color: theme.planMode } }, icon),
          React.createElement("span", null, "User approved Claude's plan:")
        ),
        React.createElement("div", null,
          React.createElement("span", { 
            style: { color: theme.secondaryText } 
          }, this.formatPlanContent(result.plan, theme))
        )
      )
    );
  }

  /**
   * æ‹’ç»í™•ì¸ì˜UIæ¸²æŸ“ - ê¸°ë°˜chunks.93.mjs:53-70
   */
  public renderToolUseRejectedMessage(result: ExitPlanModeResult, theme: any): React.ReactElement {
    return React.createElement("div", null,
      React.createElement("div", { style: { flexDirection: "column" } },
        React.createElement("span", { style: { color: theme.error } }, 
          "User rejected Claude's plan:"
        ),
        React.createElement("div", {
          style: {
            borderStyle: "round",
            borderColor: theme.planMode,
            borderDimColor: true,
            paddingX: 1
          }
        },
          React.createElement("span", { 
            style: { color: theme.secondaryText } 
          }, this.formatPlanContent(result.plan, theme))
        )
      )
    );
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°í”Œë«í¼ç‰¹å®šê·¸ë˜í”„æ ‡ - ê¸°ë°˜chunks.92.mjs:3232
   */
  private getPlatformIcon(): string {
    return process.platform === "darwin" ? "âº" : "â—";
  }

  /**
   * í˜•ì‹í™”è®¡åˆ’ë‚´ìš©í‘œì‹œ
   */
  private formatPlanContent(plan: string, theme: any): string {
    // ì§€ì›Markdowní˜•ì‹ì˜è®¡åˆ’ë‚´ìš©æ¸²æŸ“
    // è¿™é‡Œå¯ë¡œí†µí•©Markdownæ¸²æŸ“å™¨
    return plan;
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°ä¸»Agent ID
   */
  private getMainAgentId(): string {
    // è¿™é‡Œåº”è¯¥ë°˜í™˜ä¸»Agentì˜ê³ ìœ ì‹ë³„ì
    // ì— í•´ë‹¹é€†å‘ë¶„ì„ä¸­ì˜y9()í•¨ìˆ˜
    return "main_agent_session";
  }
}
```

### ë‹¨ê³„3.3: Planëª¨ë“œUIí†µí•©

**ê¸°ë°˜é€†å‘ë¶„ì„ì˜UIæŒ‡ç¤ºå™¨êµ¬í˜„**

**íŒŒì¼ ê²½ë¡œ**: `src/ui/components/plan-mode-indicator.tsx`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * Planëª¨ë“œUIæŒ‡ç¤ºå™¨
 * ê¸°ë°˜é€†å‘ë¶„ì„chunks.100.mjs:1397-1403ì˜UIêµ¬í˜„
 */

import React from 'react';
import { PlanModeState, PlanModeContext } from '../../core/plan-mode';

export interface PlanModeIndicatorProps {
  context: PlanModeContext;
  theme: any;
}

/**
 * Planëª¨ë“œìƒíƒœæŒ‡ç¤ºå™¨
 * í‘œì‹œå½“å‰ëª¨ë“œì™€æ“ä½œíŒíŠ¸
 */
export function PlanModeIndicator({ context, theme }: PlanModeIndicatorProps): React.ReactElement | null {
  // åªåœ¨Planëª¨ë“œä¸‹í‘œì‹œ - ê¸°ë°˜chunks.100.mjs:1397-1403
  if (context.currentMode !== "plan") {
    return null;
  }

  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
      <span style={{ color: theme.planMode }}>
        â¸ plan mode on
      </span>
      <span style={{ 
        color: theme.secondaryText, 
        opacity: 0.7 
      }}>
        {" "}(shift+tab to cycle)
      </span>
    </div>
  );
}

/**
 * ëª¨ë“œì „í™˜íŒíŠ¸ì»´í¬ë„ŒíŠ¸
 * ê¸°ë°˜chunks.101.mjs:2019-2023ì˜íŒíŠ¸ì‹œìŠ¤í…œ
 */
export interface ModeCycleHintProps {
  theme: any;
  sessionCount: number;
}

export function ModeCycleHint({ theme, sessionCount }: ModeCycleHintProps): React.ReactElement | null {
  // å†·å´æ—¶é—´: 20ä¸ªì„¸ì…˜
  const cooldownSessions = 20;
  
  if (sessionCount >= cooldownSessions) {
    return null;
  }

  return (
    <div style={{ 
      color: theme.secondaryText,
      fontSize: '0.9em',
      marginTop: 8
    }}>
      ğŸ’¡ Hit shift+tab to cycle between default mode, auto-accept edit mode, and plan mode
    </div>
  );
}

/**
 * Planëª¨ë“œìƒíƒœæ 
 * í‘œì‹œì „ì²´ì˜ëª¨ë“œì •ë³´
 */
export interface PlanModeStatusBarProps {
  context: PlanModeContext;
  theme: any;
}

export function PlanModeStatusBar({ context, theme }: PlanModeStatusBarProps): React.ReactElement {
  const getModeDisplayName = (mode: PlanModeState): string => {
    switch (mode) {
      case "default":
        return "Default";
      case "acceptEdits":
        return "Auto-Accept Edits";
      case "plan":
        return "Plan Mode";
      case "bypassPermissions":
        return "Bypass Permissions";
      default:
        return "Unknown";
    }
  };

  const getModeIcon = (mode: PlanModeState): string => {
    switch (mode) {
      case "default":
        return "â–¶";
      case "acceptEdits":
        return "âœ“";
      case "plan":
        return "â¸";
      case "bypassPermissions":
        return "âš ";
      default:
        return "?";
    }
  };

  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      padding: '4px 8px',
      backgroundColor: theme.modeBackground,
      borderRadius: 4
    }}>
      <span style={{ 
        color: theme.planMode,
        marginRight: 8
      }}>
        {getModeIcon(context.currentMode)}
      </span>
      <span style={{ color: theme.primaryText }}>
        {getModeDisplayName(context.currentMode)}
      </span>
      {context.currentMode === "plan" && (
        <span style={{ 
          color: theme.secondaryText,
          fontSize: '0.8em',
          marginLeft: 8
        }}>
          (read-only mode)
        </span>
      )}
    </div>
  );
}
```

### ë‹¨ê³„3.4: é”®ç›˜å¿«æ·é”®ì²˜ë¦¬

**ê¸°ë°˜é€†å‘ë¶„ì„ì˜Shift+Tabæ£€æµ‹êµ¬í˜„**

**íŒŒì¼ ê²½ë¡œ**: `src/ui/hooks/use-keyboard-shortcuts.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * é”®ç›˜å¿«æ·é”®ì²˜ë¦¬Hook
 * ê¸°ë°˜é€†å‘ë¶„ì„chunks.100.mjs:2628-2636ì˜é”®ç›˜ì´ë²¤íŠ¸ì²˜ë¦¬
 */

import { useEffect, useCallback } from 'react';
import { PlanModeManager } from '../../core/plan-mode';

export interface KeyboardShortcutsConfig {
  planModeManager: PlanModeManager;
  onModeChange?: (mode: string) => void;
  isBypassPermissionsModeAvailable?: boolean;
}

/**
 * é”®ç›˜ì´ë²¤íŠ¸ì¸í„°í˜ì´ìŠ¤ - ì— í•´ë‹¹é€†å‘ë¶„ì„ä¸­ì˜d0ê°ì²´
 */
interface KeyboardEvent {
  tab: boolean;
  shift: boolean;
  ctrl: boolean;
  alt: boolean;
  key: string;
}

export function useKeyboardShortcuts(config: KeyboardShortcutsConfig) {
  const { 
    planModeManager, 
    onModeChange, 
    isBypassPermissionsModeAvailable = false 
  } = config;

  /**
   * ì²˜ë¦¬Shift+Tabé”®ì»´í¬ì§€íŠ¸ - ê¸°ë°˜chunks.100.mjs:2628-2636
   */
  const handleShiftTab = useCallback(() => {
    const newMode = planModeManager.cyclePlanMode(isBypassPermissionsModeAvailable);
    
    if (onModeChange) {
      onModeChange(newMode);
    }
  }, [planModeManager, onModeChange, isBypassPermissionsModeAvailable]);

  /**
   * é”®ç›˜ì´ë²¤íŠ¸ì²˜ë¦¬å™¨
   */
  const handleKeyDown = useCallback((event: globalThis.KeyboardEvent) => {
    // ë¹Œë“œé”®ç›˜ì´ë²¤íŠ¸ê°ì²´ - ì— í•´ë‹¹d0
    const keyEvent: KeyboardEvent = {
      tab: event.key === 'Tab',
      shift: event.shiftKey,
      ctrl: event.ctrlKey,
      alt: event.altKey,
      key: event.key
    };

    // Shift+Tabæ£€æµ‹ - ê¸°ë°˜chunks.100.mjs:2628
    if (keyEvent.tab && keyEvent.shift) {
      event.preventDefault(); // é˜»æ­¢ê¸°ë³¸è¡Œä¸º
      handleShiftTab();
      return;
    }

    // å…¶ä»–å¿«æ·é”®ì²˜ë¦¬...
  }, [handleShiftTab]);

  /**
   * ë“±ë¡é”®ç›˜ì´ë²¤íŠ¸ë¦¬ìŠ¤ë„ˆ
   */
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);

  /**
   * æ‰‹åŠ¨è§¦å‘ëª¨ë“œì „í™˜
   */
  const cyclePlanMode = useCallback(() => {
    handleShiftTab();
  }, [handleShiftTab]);

  return {
    cyclePlanMode,
    currentMode: planModeManager.getCurrentMode()
  };
}

/**
 * Planëª¨ë“œé”®ç›˜å¿«æ·é”®ì»´í¬ë„ŒíŠ¸
 */
export interface PlanModeShortcutsProps {
  planModeManager: PlanModeManager;
  onModeChange?: (mode: string) => void;
}

export function PlanModeShortcuts({ planModeManager, onModeChange }: PlanModeShortcutsProps) {
  useKeyboardShortcuts({
    planModeManager,
    onModeChange
  });

  return null; // è¿™ì˜ˆä¸€ä¸ªë…¼ë¦¬ì»´í¬ë„ŒíŠ¸, ä¸æ¸²æŸ“UI
}
```

---

## ğŸ“ 2ì£¼ì°¨: ì‹¤ì‹œê°„ Steeringì™€íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œ

### ë‹¨ê³„3.5: ì‹¤ì‹œê°„ Steeringë©”ì»¤ë‹ˆì¦˜å¢å¼º

**í†µí•©h2Aë©”ì‹œì§€íä¸Planëª¨ë“œ**

**íŒŒì¼ ê²½ë¡œ**: `src/core/steering-plan-integration.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * ì‹¤ì‹œê°„ Steeringä¸Planëª¨ë“œí†µí•©
 * í™•ì¥h2Aë¹„ë™ê¸°ë©”ì‹œì§€íë¡œì§€ì›Planëª¨ë“œì˜ì‹¤ì‹œê°„äº¤äº’
 */

import { h2A } from './message-queue';
import { PlanModeManager } from './plan-mode';

export interface SteeringMessage {
  type: 'user_input' | 'mode_change' | 'plan_approval' | 'plan_rejection';
  content: string;
  timestamp: number;
  sessionId: string;
  planContext?: {
    currentMode: string;
    plan?: string;
  };
}

export interface SteeringContext {
  planModeManager: PlanModeManager;
  sessionId: string;
  abortController: AbortController;
}

/**
 * Planëª¨ë“œæ„ŸçŸ¥ì˜Steeringë©”ì‹œì§€í
 * í™•ì¥h2Aí´ë˜ìŠ¤ë¡œì§€ì›Planëª¨ë“œì˜íŠ¹ìˆ˜ì²˜ë¦¬
 */
export class PlanAwareSteeringQueue extends h2A {
  private planModeManager: PlanModeManager;
  private stdinListening = false;
  
  constructor(planModeManager: PlanModeManager, cleanupFn?: () => void) {
    super(cleanupFn);
    this.planModeManager = planModeManager;
  }

  /**
   * ì‹œì‘stdinë¦¬ìŠ¤ë‹ - å¢å¼ºë²„ì „ì§€ì›Planëª¨ë“œ
   */
  public startStdinListening(): void {
    if (this.stdinListening || typeof process === 'undefined') return;
    
    this.stdinListening = true;
    
    // ì„¤ì •stdinä¸ºåŸå§‹ëª¨ë“œ
    if (process.stdin.setRawMode) {
      process.stdin.setRawMode(true);
    }
    process.stdin.resume();
    process.stdin.setEncoding('utf8');

    process.stdin.on('data', (chunk: string) => {
      this.handleStdinInput(chunk);
    });
  }

  /**
   * ì²˜ë¦¬stdinì…ë ¥
   */
  private handleStdinInput(input: string): void {
    const steeringMessage: SteeringMessage = {
      type: 'user_input',
      content: input.trim(),
      timestamp: Date.now(),
      sessionId: this.planModeManager.getContext().sessionId,
      planContext: {
        currentMode: this.planModeManager.getCurrentMode()
      }
    };

    // Planëª¨ë“œä¸‹ì˜íŠ¹ìˆ˜ì²˜ë¦¬
    if (this.planModeManager.isPlanMode()) {
      steeringMessage.planContext!.plan = "current_plan_content"; // ì‹¤ì œêµ¬í˜„ä¸­éœ€è¦ê°€ì ¸ì˜¤ê¸°å½“å‰è®¡åˆ’
      
      // í™•ì¸ì˜ˆì•„ë‹ˆì˜¤ä¸ºPlanëª¨ë“œì˜íŠ¹ìˆ˜ì»¤ë§¨ë“œ
      if (this.isPlanModeCommand(input)) {
        this.handlePlanModeCommand(input, steeringMessage);
        return;
      }
    }

    // å°†ë©”ì‹œì§€åŠ å…¥í
    this.enqueue(steeringMessage);
  }

  /**
   * í™•ì¸ì˜ˆì•„ë‹ˆì˜¤ä¸ºPlanëª¨ë“œì»¤ë§¨ë“œ
   */
  private isPlanModeCommand(input: string): boolean {
    const planCommands = [
      'exit plan',
      'approve plan', 
      'reject plan',
      'switch mode'
    ];
    
    return planCommands.some(cmd => 
      input.toLowerCase().includes(cmd)
    );
  }

  /**
   * ì²˜ë¦¬Planëª¨ë“œíŠ¹ìˆ˜ì»¤ë§¨ë“œ
   */
  private handlePlanModeCommand(input: string, message: SteeringMessage): void {
    const lowerInput = input.toLowerCase();
    
    if (lowerInput.includes('exit plan') || lowerInput.includes('approve plan')) {
      message.type = 'plan_approval';
    } else if (lowerInput.includes('reject plan')) {
      message.type = 'plan_rejection';
    } else if (lowerInput.includes('switch mode')) {
      message.type = 'mode_change';
      // ìë™ì „í™˜ëª¨ë“œ
      this.planModeManager.cyclePlanMode();
    }
    
    this.enqueue(message);
  }

  /**
   * ì¤‘ì§€stdinë¦¬ìŠ¤ë‹
   */
  public stopStdinListening(): void {
    if (!this.stdinListening) return;
    
    this.stdinListening = false;
    
    if (process.stdin.setRawMode) {
      process.stdin.setRawMode(false);
    }
    process.stdin.pause();
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°Planëª¨ë“œæ„ŸçŸ¥ì˜ë©”ì‹œì§€
   */
  public async getSteeringMessage(): Promise<SteeringMessage | null> {
    try {
      const result = await this.next();
      if (result.done) return null;
      
      return result.value as SteeringMessage;
    } catch (error) {
      console.error('Error getting steering message:', error);
      return null;
    }
  }
}

/**
 * Steeringë©”ì‹œì§€ì²˜ë¦¬å™¨
 * æ ¹æ®Planëª¨ë“œìƒíƒœì²˜ë¦¬ä¸åŒíƒ€ì…ì˜ì‚¬ìš©ìì…ë ¥
 */
export class SteeringMessageHandler {
  private planModeManager: PlanModeManager;
  
  constructor(planModeManager: PlanModeManager) {
    this.planModeManager = planModeManager;
  }

  /**
   * ì²˜ë¦¬Steeringë©”ì‹œì§€
   */
  public async handleMessage(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    switch (message.type) {
      case 'user_input':
        return this.handleUserInput(message);
      
      case 'mode_change':
        return this.handleModeChange(message);
      
      case 'plan_approval':
        return this.handlePlanApproval(message);
      
      case 'plan_rejection':
        return this.handlePlanRejection(message);
      
      default:
        return { shouldContinue: true };
    }
  }

  private async handleUserInput(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    if (this.planModeManager.isPlanMode()) {
      // Planëª¨ë“œä¸‹, ì‚¬ìš©ìì…ë ¥ä½œä¸ºè®¡åˆ’ìˆ˜ì •å»ºè®®
      return {
        shouldContinue: true,
        response: `Plan mode active. Your input will be considered for plan refinement: "${message.content}"`,
        action: 'refine_plan'
      };
    }
    
    // ê¸°ë³¸ëª¨ë“œä¸‹ì˜æ­£å¸¸ì²˜ë¦¬
    return {
      shouldContinue: true,
      response: `Received steering input: "${message.content}"`,
      action: 'adjust_execution'
    };
  }

  private async handleModeChange(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    const newMode = this.planModeManager.getCurrentMode();
    
    return {
      shouldContinue: true,
      response: `Mode switched to: ${newMode}`,
      action: 'mode_changed'
    };
  }

  private async handlePlanApproval(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    // é€€å‡ºPlanëª¨ë“œ, ê³„ì†æ‰§è¡Œ
    this.planModeManager.setMode("default", "user_approved_plan");
    
    return {
      shouldContinue: true,
      response: "Plan approved. Switching to execution mode.",
      action: 'execute_plan'
    };
  }

  private async handlePlanRejection(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    return {
      shouldContinue: false,
      response: "Plan rejected. Please provide feedback for plan revision.",
      action: 'revise_plan'
    };
  }
}
```

### ë‹¨ê³„3.6: íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œêµ¬í˜„

**ê¸°ë°˜é€†å‘ë¶„ì„ì˜íŠ¹ìˆ˜ëª¨ë“œì²˜ë¦¬**

**íŒŒì¼ ê²½ë¡œ**: `src/ui/special-modes.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œì²˜ë¦¬
 * êµ¬í˜„!bashëª¨ë“œ, #ë…¸íŠ¸ëª¨ë“œ, ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥ç­‰íŠ¹ìˆ˜äº¤äº’
 */

export type SpecialMode = 'bash' | 'note' | 'multiline' | 'normal';

export interface SpecialModeContext {
  mode: SpecialMode;
  buffer: string[];
  startTime: number;
  metadata?: Record<string, any>;
}

export interface BashModeResult {
  command: string;
  output: string;
  exitCode: number;
  duration: number;
}

export interface NoteModeResult {
  content: string;
  timestamp: number;
  tags?: string[];
}

/**
 * íŠ¹ìˆ˜ëª¨ë“œì²˜ë¦¬å™¨
 * ê¸°ë°˜Claude Codeì˜íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œêµ¬í˜„
 */
export class SpecialModeHandler {
  private currentContext: SpecialModeContext | null = null;
  private noteStorage: Map<string, NoteModeResult> = new Map();
  
  /**
   * æ£€æµ‹å¹¶ì²˜ë¦¬íŠ¹ìˆ˜ëª¨ë“œì…ë ¥
   */
  public processInput(input: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
    context?: SpecialModeContext;
  } {
    // Bashëª¨ë“œæ£€æµ‹ - !ì»¤ë§¨ë“œ
    if (input.startsWith('!')) {
      return this.handleBashMode(input.slice(1));
    }
    
    // ë…¸íŠ¸ëª¨ë“œæ£€æµ‹ - #ë‚´ìš©
    if (input.startsWith('#')) {
      return this.handleNoteMode(input.slice(1));
    }
    
    // ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥æ£€æµ‹
    if (this.currentContext?.mode === 'multiline') {
      return this.handleMultilineMode(input);
    }
    
    // í™•ì¸ì˜ˆì•„ë‹ˆì˜¤å¼€å§‹ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥
    if (this.isMultilineStart(input)) {
      return this.startMultilineMode(input);
    }
    
    // æ™®é€šëª¨ë“œ
    return {
      mode: 'normal',
      content: input,
      shouldExecute: true
    };
  }

  /**
   * ì²˜ë¦¬Bashëª¨ë“œ - !ì»¤ë§¨ë“œç›´æ¥æ‰§è¡Œ
   */
  private handleBashMode(command: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
  } {
    return {
      mode: 'bash',
      content: command.trim(),
      shouldExecute: true
    };
  }

  /**
   * æ‰§è¡ŒBashì»¤ë§¨ë“œ
   */
  public async executeBashCommand(command: string): Promise<BashModeResult> {
    const startTime = Date.now();
    
    try {
      // è¿™é‡Œí†µí•©Bashë„êµ¬æ‰§è¡Œ
      const { spawn } = await import('child_process');
      
      return new Promise((resolve, reject) => {
        const child = spawn('bash', ['-c', command], {
          stdio: ['pipe', 'pipe', 'pipe']
        });
        
        let stdout = '';
        let stderr = '';
        
        child.stdout.on('data', (data) => {
          stdout += data.toString();
        });
        
        child.stderr.on('data', (data) => {
          stderr += data.toString();
        });
        
        child.on('close', (code) => {
          resolve({
            command,
            output: stdout + stderr,
            exitCode: code || 0,
            duration: Date.now() - startTime
          });
        });
        
        child.on('error', (error) => {
          reject(error);
        });
        
        // 5ç§’íƒ€ì„ì•„ì›ƒ
        setTimeout(() => {
          child.kill();
          reject(new Error('Command timeout'));
        }, 5000);
      });
    } catch (error) {
      return {
        command,
        output: `Error: ${error}`,
        exitCode: 1,
        duration: Date.now() - startTime
      };
    }
  }

  /**
   * ì²˜ë¦¬ë…¸íŠ¸ëª¨ë“œ - #ë‚´ìš©è®°å½•
   */
  private handleNoteMode(content: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
  } {
    const noteId = `note_${Date.now()}`;
    const noteResult: NoteModeResult = {
      content: content.trim(),
      timestamp: Date.now(),
      tags: this.extractTags(content)
    };
    
    this.noteStorage.set(noteId, noteResult);
    
    return {
      mode: 'note',
      content: `Note saved: ${content.trim()}`,
      shouldExecute: false // ë…¸íŠ¸ä¸éœ€è¦æ‰§è¡Œ
    };
  }

  /**
   * æå–ë…¸íŠ¸íƒ­
   */
  private extractTags(content: string): string[] {
    const tagRegex = /#(\w+)/g;
    const tags: string[] = [];
    let match;
    
    while ((match = tagRegex.exec(content)) !== null) {
      tags.push(match[1]);
    }
    
    return tags;
  }

  /**
   * í™•ì¸ì˜ˆì•„ë‹ˆì˜¤å¼€å§‹ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥
   */
  private isMultilineStart(input: string): boolean {
    // æ£€æµ‹ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥ì˜å¼€å§‹í”Œë˜ê·¸
    return input.includes('```') || 
           input.endsWith('\\') || 
           input.includes('"""') ||
           input.includes("'''");
  }

  /**
   * å¼€å§‹ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥ëª¨ë“œ
   */
  private startMultilineMode(input: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
    context: SpecialModeContext;
  } {
    this.currentContext = {
      mode: 'multiline',
      buffer: [input],
      startTime: Date.now(),
      metadata: {
        delimiter: this.detectDelimiter(input)
      }
    };
    
    return {
      mode: 'multiline',
      content: input,
      shouldExecute: false,
      context: this.currentContext
    };
  }

  /**
   * æ£€æµ‹å¤šè¡Œåˆ†éš”ç¬¦
   */
  private detectDelimiter(input: string): string {
    if (input.includes('```')) return '```';
    if (input.includes('"""')) return '"""';
    if (input.includes("'''")) return "'''";
    if (input.endsWith('\\')) return '\\';
    return '';
  }

  /**
   * ì²˜ë¦¬ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥ëª¨ë“œ
   */
  private handleMultilineMode(input: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
    context?: SpecialModeContext;
  } {
    if (!this.currentContext) {
      throw new Error('No multiline context');
    }
    
    this.currentContext.buffer.push(input);
    
    // í™•ì¸ì˜ˆì•„ë‹ˆì˜¤ç»“æŸë‹¤ì¤‘ ë¼ì¸ ì…ë ¥
    const delimiter = this.currentContext.metadata?.delimiter || '';
    if (this.isMultilineEnd(input, delimiter)) {
      const fullContent = this.currentContext.buffer.join('\n');
      this.currentContext = null; // æ¸…é™¤ì»¨í…ìŠ¤íŠ¸
      
      return {
        mode: 'normal',
        content: fullContent,
        shouldExecute: true
      };
    }
    
    return {
      mode: 'multiline',
      content: input,
      shouldExecute: false,
      context: this.currentContext
    };
  }

  /**
   * í™•ì¸ì˜ˆì•„ë‹ˆì˜¤ç»“æŸë‹¤ì¤‘ ë¼ì¸ ì…ë ¥
   */
  private isMultilineEnd(input: string, delimiter: string): boolean {
    if (delimiter === '```' || delimiter === '"""' || delimiter === "'''") {
      return input.trim() === delimiter;
    }
    
    if (delimiter === '\\') {
      return !input.endsWith('\\');
    }
    
    return false;
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°æ‰€ìˆìŒë…¸íŠ¸
   */
  public getNotes(): NoteModeResult[] {
    return Array.from(this.noteStorage.values()).sort((a, b) => b.timestamp - a.timestamp);
  }

  /**
   * ê²€ìƒ‰ë…¸íŠ¸
   */
  public searchNotes(query: string): NoteModeResult[] {
    const notes = this.getNotes();
    const lowerQuery = query.toLowerCase();
    
    return notes.filter(note => 
      note.content.toLowerCase().includes(lowerQuery) ||
      note.tags?.some(tag => tag.toLowerCase().includes(lowerQuery))
    );
  }

  /**
   * æ¸…é™¤å½“å‰å¤šè¡Œì»¨í…ìŠ¤íŠ¸
   */
  public clearMultilineContext(): void {
    this.currentContext = null;
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°å½“å‰ëª¨ë“œìƒíƒœ
   */
  public getCurrentModeStatus(): {
    mode: SpecialMode;
    isActive: boolean;
    buffer?: string[];
    duration?: number;
  } {
    if (!this.currentContext) {
      return { mode: 'normal', isActive: false };
    }
    
    return {
      mode: this.currentContext.mode,
      isActive: true,
      buffer: this.currentContext.buffer,
      duration: Date.now() - this.currentContext.startTime
    };
  }
}

/**
 * íŠ¹ìˆ˜ëª¨ë“œUIì»´í¬ë„ŒíŠ¸
 */
export interface SpecialModeIndicatorProps {
  handler: SpecialModeHandler;
  theme: any;
}

export function SpecialModeIndicator({ handler, theme }: SpecialModeIndicatorProps): React.ReactElement | null {
  const status = handler.getCurrentModeStatus();
  
  if (!status.isActive) {
    return null;
  }
  
  const getModeIcon = (mode: SpecialMode): string => {
    switch (mode) {
      case 'bash': return 'ğŸ’»';
      case 'note': return 'ğŸ“';
      case 'multiline': return 'ğŸ“„';
      default: return 'â­';
    }
  };
  
  const getModeLabel = (mode: SpecialMode): string => {
    switch (mode) {
      case 'bash': return 'Bash Mode';
      case 'note': return 'Note Mode';
      case 'multiline': return 'Multi-line Input';
      default: return 'Special Mode';
    }
  };
  
  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      padding: '2px 6px',
      backgroundColor: theme.specialModeBackground,
      borderRadius: 3,
      fontSize: '0.85em'
    }}>
      <span style={{ marginRight: 4 }}>
        {getModeIcon(status.mode)}
      </span>
      <span style={{ color: theme.specialModeText }}>
        {getModeLabel(status.mode)}
      </span>
      {status.mode === 'multiline' && (
        <span style={{ 
          color: theme.secondaryText,
          marginLeft: 4,
          fontSize: '0.8em'
        }}>
          ({status.buffer?.length || 0} lines)
        </span>
      )}
    </div>
  );
}
```

---

## ğŸ“ 3ì£¼ì°¨: ë‹¨ì¶• ëª…ë ¹ ì‹œìŠ¤í…œì™€IDEí†µí•©

### ë‹¨ê³„3.7: ë‹¨ì¶• ëª…ë ¹ ì‹œìŠ¤í…œêµ¬í˜„

**ì „ì²´ì˜æ–œæ ì»¤ë§¨ë“œì²˜ë¦¬ì‹œìŠ¤í…œ**

**íŒŒì¼ ê²½ë¡œ**: `src/commands/slash-commands.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * ë‹¨ì¶• ëª…ë ¹ ì‹œìŠ¤í…œêµ¬í˜„
 * ê¸°ë°˜Claude Codeì˜æ–œæ ì»¤ë§¨ë“œåŠŸèƒ½
 */

export interface SlashCommand {
  name: string;
  description: string;
  usage: string;
  execute: (args: string[], context: CommandContext) => Promise<CommandResult>;
  permissions?: string[];
  aliases?: string[];
}

export interface CommandContext {
  sessionId: string;
  userId?: string;
  mcpServers: any[];
  currentDirectory: string;
  planModeManager: any;
}

export interface CommandResult {
  success: boolean;
  message: string;
  data?: any;
  shouldContinue?: boolean;
}

/**
 * ë‹¨ì¶• ëª…ë ¹ê´€ë¦¬å™¨
 */
export class SlashCommandManager {
  private commands = new Map<string, SlashCommand>();
  private aliases = new Map<string, string>();
  
  constructor() {
    this.registerBuiltinCommands();
  }

  /**
   * ë“±ë¡å†…ç½®ì»¤ë§¨ë“œ
   */
  private registerBuiltinCommands(): void {
    // /help - í‘œì‹œå¸®åŠ©ì •ë³´
    this.register({
      name: 'help',
      description: 'Show available commands and usage',
      usage: '/help [command]',
      execute: async (args, context) => {
        if (args.length > 0) {
          return this.showCommandHelp(args[0]);
        }
        return this.showAllCommands();
      }
    });

    // /login - ì‚¬ìš©ìì¸ì¦ê´€ë¦¬
    this.register({
      name: 'login',
      description: 'Authenticate with Claude Code services',
      usage: '/login [provider]',
      execute: async (args, context) => {
        return await this.handleLogin(args, context);
      }
    });

    // /logout - ì‚­ì œå½“å‰ì‚¬ìš©ì
    this.register({
      name: 'logout',
      description: 'Sign out from current session',
      usage: '/logout',
      execute: async (args, context) => {
        return await this.handleLogout(context);
      }
    });

    // /clear - æ¸…é™¤å¯¹è¯å†å²
    this.register({
      name: 'clear',
      description: 'Clear conversation history',
      usage: '/clear',
      aliases: ['cls'],
      execute: async (args, context) => {
        return {
          success: true,
          message: 'Conversation history cleared',
          data: { action: 'clear_history' }
        };
      }
    });

    // /resume - ë³µì›å†å²ì„¸ì…˜
    this.register({
      name: 'resume',
      description: 'Resume a previous session',
      usage: '/resume <session_id>',
      execute: async (args, context) => {
        if (args.length === 0) {
          return {
            success: false,
            message: 'Session ID required. Usage: /resume <session_id>'
          };
        }
        return await this.handleResume(args[0], context);
      }
    });

    // /mcp - MCPì„œë²„ê´€ë¦¬
    this.register({
      name: 'mcp',
      description: 'Manage MCP servers',
      usage: '/mcp <action> [server_name]',
      execute: async (args, context) => {
        return await this.handleMcpCommand(args, context);
      }
    });

    // /review - AIì½”ë“œå®¡æŸ¥
    this.register({
      name: 'review',
      description: 'Start AI code review',
      usage: '/review [file_pattern]',
      execute: async (args, context) => {
        return await this.handleCodeReview(args, context);
      }
    });

    // /status - ì‹œìŠ¤í…œìƒíƒœí‘œì‹œ
    this.register({
      name: 'status',
      description: 'Show system status and diagnostics',
      usage: '/status',
      execute: async (args, context) => {
        return await this.handleStatus(context);
      }
    });

    // /mode - ëª¨ë“œê´€ë¦¬
    this.register({
      name: 'mode',
      description: 'Switch between interaction modes',
      usage: '/mode [plan|default|acceptEdits]',
      execute: async (args, context) => {
        return await this.handleModeSwitch(args, context);
      }
    });

    // /config - ì„¤ì • ê´€ë¦¬
    this.register({
      name: 'config',
      description: 'View or modify configuration',
      usage: '/config [get|set] [key] [value]',
      execute: async (args, context) => {
        return await this.handleConfig(args, context);
      }
    });

    // /debug - ë””ë²„ê·¸ì •ë³´
    this.register({
      name: 'debug',
      description: 'Show debug information',
      usage: '/debug [component]',
      execute: async (args, context) => {
        return await this.handleDebug(args, context);
      }
    });

    // /export - ë‚´ë³´ë‚´ê¸°ì„¸ì…˜
    this.register({
      name: 'export',
      description: 'Export conversation or data',
      usage: '/export [format] [target]',
      execute: async (args, context) => {
        return await this.handleExport(args, context);
      }
    });

    // /import - ê°€ì ¸ì˜¤ê¸°ë°ì´í„°
    this.register({
      name: 'import',
      description: 'Import configuration or data',
      usage: '/import <source>',
      execute: async (args, context) => {
        return await this.handleImport(args, context);
      }
    });

    // /workspace - å·¥ä½œåŒºê´€ë¦¬
    this.register({
      name: 'workspace',
      description: 'Manage workspace settings',
      usage: '/workspace [action]',
      aliases: ['ws'],
      execute: async (args, context) => {
        return await this.handleWorkspace(args, context);
      }
    });

    // /tools - ë„êµ¬ê´€ë¦¬
    this.register({
      name: 'tools',
      description: 'List and manage available tools',
      usage: '/tools [list|enable|disable] [tool_name]',
      execute: async (args, context) => {
        return await this.handleTools(args, context);
      }
    });

    // /session - ì„¸ì…˜ê´€ë¦¬
    this.register({
      name: 'session',
      description: 'Session management commands',
      usage: '/session [new|save|load|list]',
      execute: async (args, context) => {
        return await this.handleSession(args, context);
      }
    });
  }

  /**
   * ë“±ë¡ì»¤ë§¨ë“œ
   */
  public register(command: SlashCommand): void {
    this.commands.set(command.name, command);
    
    // ë“±ë¡åˆ«å
    if (command.aliases) {
      for (const alias of command.aliases) {
        this.aliases.set(alias, command.name);
      }
    }
  }

  /**
   * è§£æì™€æ‰§è¡Œì»¤ë§¨ë“œ
   */
  public async execute(input: string, context: CommandContext): Promise<CommandResult> {
    if (!input.startsWith('/')) {
      return {
        success: false,
        message: 'Not a slash command'
      };
    }

    const parts = input.slice(1).split(' ');
    const commandName = parts[0].toLowerCase();
    const args = parts.slice(1);

    // í™•ì¸åˆ«å
    const actualCommand = this.aliases.get(commandName) || commandName;
    const command = this.commands.get(actualCommand);

    if (!command) {
      return {
        success: false,
        message: `Unknown command: /${commandName}. Type /help for available commands.`
      };
    }

    try {
      return await command.execute(args, context);
    } catch (error) {
      return {
        success: false,
        message: `Error executing command: ${error}`
      };
    }
  }

  /**
   * í™•ì¸ì˜ˆì•„ë‹ˆì˜¤ä¸ºæ–œæ ì»¤ë§¨ë“œ
   */
  public isSlashCommand(input: string): boolean {
    return input.trim().startsWith('/');
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°ì»¤ë§¨ë“œìë™è¡¥å…¨
   */
  public getCompletions(partial: string): string[] {
    const commandPart = partial.slice(1).toLowerCase();
    const completions: string[] = [];

    for (const [name, command] of this.commands) {
      if (name.startsWith(commandPart)) {
        completions.push(`/${name}`);
      }
    }

    for (const [alias, commandName] of this.aliases) {
      if (alias.startsWith(commandPart)) {
        completions.push(`/${alias}`);
      }
    }

    return completions.sort();
  }

  // ì»¤ë§¨ë“œêµ¬í˜„ë©”ì„œë“œ...
  private async showAllCommands(): Promise<CommandResult> {
    const commandList = Array.from(this.commands.values())
      .map(cmd => `/${cmd.name} - ${cmd.description}`)
      .join('\n');

    return {
      success: true,
      message: `Available commands:\n${commandList}\n\nType /help <command> for detailed usage.`
    };
  }

  private async showCommandHelp(commandName: string): Promise<CommandResult> {
    const actualCommand = this.aliases.get(commandName) || commandName;
    const command = this.commands.get(actualCommand);

    if (!command) {
      return {
        success: false,
        message: `Command not found: /${commandName}`
      };
    }

    let helpText = `Command: /${command.name}\n`;
    helpText += `Description: ${command.description}\n`;
    helpText += `Usage: ${command.usage}`;

    if (command.aliases?.length) {
      helpText += `\nAliases: ${command.aliases.map(a => `/${a}`).join(', ')}`;
    }

    return {
      success: true,
      message: helpText
    };
  }

  private async handleLogin(args: string[], context: CommandContext): Promise<CommandResult> {
    // êµ¬í˜„ë¡œê·¸ì¸ë…¼ë¦¬
    return {
      success: true,
      message: 'Login initiated. Please check your browser for authentication.',
      data: { action: 'start_oauth' }
    };
  }

  private async handleLogout(context: CommandContext): Promise<CommandResult> {
    // êµ¬í˜„ë¡œê·¸ì•„ì›ƒë…¼ë¦¬
    return {
      success: true,
      message: 'Successfully logged out.',
      data: { action: 'clear_auth' }
    };
  }

  private async handleResume(sessionId: string, context: CommandContext): Promise<CommandResult> {
    // êµ¬í˜„ì„¸ì…˜ë³µì›ë…¼ë¦¬
    return {
      success: true,
      message: `Resuming session: ${sessionId}`,
      data: { action: 'resume_session', sessionId }
    };
  }

  private async handleMcpCommand(args: string[], context: CommandContext): Promise<CommandResult> {
    if (args.length === 0) {
      const serverList = context.mcpServers.map(s => `- ${s.name} (${s.status})`).join('\n');
      return {
        success: true,
        message: `MCP Servers:\n${serverList}`
      };
    }

    const action = args[0];
    const serverName = args[1];

    switch (action) {
      case 'list':
        const servers = context.mcpServers.map(s => 
          `${s.name}: ${s.status} (${s.tools?.length || 0} tools)`
        ).join('\n');
        return {
          success: true,
          message: `MCP Servers:\n${servers}`
        };

      case 'restart':
        if (!serverName) {
          return { success: false, message: 'Server name required' };
        }
        return {
          success: true,
          message: `Restarting MCP server: ${serverName}`,
          data: { action: 'restart_mcp_server', serverName }
        };

      default:
        return {
          success: false,
          message: 'Unknown MCP action. Available: list, restart'
        };
    }
  }

  private async handleCodeReview(args: string[], context: CommandContext): Promise<CommandResult> {
    const pattern = args[0] || '**/*.{js,ts,jsx,tsx,py}';
    
    return {
      success: true,
      message: `Starting code review for pattern: ${pattern}`,
      data: { action: 'start_code_review', pattern }
    };
  }

  private async handleStatus(context: CommandContext): Promise<CommandResult> {
    const status = {
      session: context.sessionId,
      mode: context.planModeManager?.getCurrentMode() || 'default',
      mcpServers: context.mcpServers.length,
      workingDirectory: context.currentDirectory
    };

    const statusText = Object.entries(status)
      .map(([key, value]) => `${key}: ${value}`)
      .join('\n');

    return {
      success: true,
      message: `System Status:\n${statusText}`
    };
  }

  private async handleModeSwitch(args: string[], context: CommandContext): Promise<CommandResult> {
    if (args.length === 0) {
      const currentMode = context.planModeManager?.getCurrentMode() || 'default';
      return {
        success: true,
        message: `Current mode: ${currentMode}\nAvailable modes: default, acceptEdits, plan, bypassPermissions`
      };
    }

    const targetMode = args[0];
    const validModes = ['default', 'acceptEdits', 'plan', 'bypassPermissions'];

    if (!validModes.includes(targetMode)) {
      return {
        success: false,
        message: `Invalid mode. Available modes: ${validModes.join(', ')}`
      };
    }

    context.planModeManager?.setMode(targetMode, 'slash_command');

    return {
      success: true,
      message: `Switched to ${targetMode} mode`,
      data: { action: 'mode_change', mode: targetMode }
    };
  }

  private async handleConfig(args: string[], context: CommandContext): Promise<CommandResult> {
    if (args.length === 0) {
      return {
        success: true,
        message: 'Configuration commands: get, set, list\nUsage: /config get <key> or /config set <key> <value>'
      };
    }

    const action = args[0];
    switch (action) {
      case 'list':
        return {
          success: true,
          message: 'Available configuration keys:\n- model\n- theme\n- autoSave\n- debugMode',
          data: { action: 'list_config' }
        };

      case 'get':
        const key = args[1];
        if (!key) {
          return { success: false, message: 'Configuration key required' };
        }
        return {
          success: true,
          message: `Configuration value for ${key}: [value would be shown here]`,
          data: { action: 'get_config', key }
        };

      case 'set':
        const setKey = args[1];
        const value = args.slice(2).join(' ');
        if (!setKey || !value) {
          return { success: false, message: 'Both key and value required' };
        }
        return {
          success: true,
          message: `Set ${setKey} = ${value}`,
          data: { action: 'set_config', key: setKey, value }
        };

      default:
        return { success: false, message: 'Unknown config action' };
    }
  }

  private async handleDebug(args: string[], context: CommandContext): Promise<CommandResult> {
    const component = args[0] || 'all';
    
    const debugInfo = {
      timestamp: new Date().toISOString(),
      component,
      sessionId: context.sessionId,
      memoryUsage: process.memoryUsage?.() || 'N/A',
      uptime: process.uptime?.() || 'N/A'
    };

    return {
      success: true,
      message: `Debug information for ${component}:\n${JSON.stringify(debugInfo, null, 2)}`,
      data: { action: 'debug_info', debugInfo }
    };
  }

  private async handleExport(args: string[], context: CommandContext): Promise<CommandResult> {
    const format = args[0] || 'json';
    const target = args[1] || 'conversation';

    return {
      success: true,
      message: `Exporting ${target} in ${format} format...`,
      data: { action: 'export_data', format, target }
    };
  }

  private async handleImport(args: string[], context: CommandContext): Promise<CommandResult> {
    if (args.length === 0) {
      return { success: false, message: 'Import source required' };
    }

    const source = args[0];
    return {
      success: true,
      message: `Importing from ${source}...`,
      data: { action: 'import_data', source }
    };
  }

  private async handleWorkspace(args: string[], context: CommandContext): Promise<CommandResult> {
    const action = args[0] || 'status';

    switch (action) {
      case 'status':
        return {
          success: true,
          message: `Workspace: ${context.currentDirectory}\nActive tools: [tool list would be shown here]`
        };

      case 'reload':
        return {
          success: true,
          message: 'Reloading workspace configuration...',
          data: { action: 'reload_workspace' }
        };

      default:
        return { success: false, message: 'Unknown workspace action' };
    }
  }

  private async handleTools(args: string[], context: CommandContext): Promise<CommandResult> {
    const action = args[0] || 'list';

    switch (action) {
      case 'list':
        return {
          success: true,
          message: 'Available tools:\n- Read\n- Write\n- Edit\n- Bash\n- Grep\n- [... other tools]'
        };

      default:
        return { success: false, message: 'Unknown tools action' };
    }
  }

  private async handleSession(args: string[], context: CommandContext): Promise<CommandResult> {
    const action = args[0] || 'info';

    switch (action) {
      case 'info':
        return {
          success: true,
          message: `Current session: ${context.sessionId}\nStarted: [timestamp would be shown here]`
        };

      case 'new':
        return {
          success: true,
          message: 'Creating new session...',
          data: { action: 'new_session' }
        };

      case 'save':
        return {
          success: true,
          message: 'Session saved successfully',
          data: { action: 'save_session' }
        };

      default:
        return { success: false, message: 'Unknown session action' };
    }
  }
}
```

### ë‹¨ê³„3.8: IDEì§„ë‹¨ì •ë³´ê´€ë¦¬ì‹œìŠ¤í…œ

**ê¸°ë°˜é€†å‘ë¶„ì„ì˜PKí´ë˜ìŠ¤ì™„ì „ êµ¬í˜„**

**íŒŒì¼ ê²½ë¡œ**: `src/integrations/ide-diagnostics.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * IDEì§„ë‹¨ì •ë³´ê´€ë¦¬ì‹œìŠ¤í…œ
 * ê¸°ë°˜é€†å‘ë¶„ì„chunks.92.mjsì˜PKí´ë˜ìŠ¤ì •í™•í•œ êµ¬í˜„
 */

export interface DiagnosticInfo {
  uri: string;
  diagnostics: LspDiagnostic[];
}

export interface LspDiagnostic {
  message: string;
  severity: number;
  source?: string;
  code?: string | number;
  range: {
    start: { line: number; character: number };
    end: { line: number; character: number };
  };
}

export interface McpClient {
  type: 'connected' | 'disconnected';
  callTool: (toolName: string, params: any) => Promise<any>;
}

/**
 * PK - ì§„ë‹¨ì •ë³´ê´€ë¦¬å™¨
 * ê¸°ë°˜chunks.92.mjs:49-59ì˜ì‹±ê¸€í†¤ëª¨ë“œêµ¬í˜„
 */
export class IdeDiagnosticsManager {
  private static instance: IdeDiagnosticsManager;
  
  private baseline = new Map<string, LspDiagnostic[]>();           // åŸºçº¿ì§„ë‹¨ì •ë³´
  private initialized = false;                                    // ì´ˆê¸°í™”ìƒíƒœ
  private mcpClient: McpClient | null = null;                    // MCPí´ë¼ì´ì–¸íŠ¸
  private lastProcessedTimestamps = new Map<string, number>();   // æœ€åì²˜ë¦¬æ—¶é—´æˆ³
  private lastDiagnosticsByUri = new Map<string, LspDiagnostic[]>(); // æœ€åì§„ë‹¨ì •ë³´
  private rightFileDiagnosticsState = new Map<string, LspDiagnostic[]>(); // å³ä¾§íŒŒì¼ì§„ë‹¨ìƒíƒœ

  /**
   * ê°€ì ¸ì˜¤ê¸°ì‹±ê¸€í†¤ì¸ìŠ¤í„´ìŠ¤
   */
  public static getInstance(): IdeDiagnosticsManager {
    if (!IdeDiagnosticsManager.instance) {
      IdeDiagnosticsManager.instance = new IdeDiagnosticsManager();
    }
    return IdeDiagnosticsManager.instance;
  }

  /**
   * ì´ˆê¸°í™”ì§„ë‹¨ê´€ë¦¬å™¨
   */
  public initialize(mcpClient: McpClient): void {
    this.mcpClient = mcpClient;
    this.initialized = true;
  }

  /**
   * íŒŒì¼í¸ì§‘å‰ê°€ì ¸ì˜¤ê¸°ì§„ë‹¨åŸºçº¿ - ê¸°ë°˜chunks.92.mjs:109-119
   */
  public async beforeFileEdited(filePath: string): Promise<void> {
    if (!this.initialized || !this.mcpClient || this.mcpClient.type !== "connected") {
      return;
    }

    const timestamp = Date.now();
    
    try {
      const result = await this.callDiagnosticsTool("getDiagnostics", {
        uri: `file://${filePath}`
      });
      
      const diagnostics = this.parseDiagnosticResult(result);
      const fileInfo = diagnostics[0];
      
      if (fileInfo) {
        if (filePath !== this.normalizeFileUri(fileInfo.uri)) {
          throw new Error(`Diagnostics file path mismatch: expected ${filePath}, got ${fileInfo.uri})`);
        }
        
        this.baseline.set(filePath, fileInfo.diagnostics);
        this.lastProcessedTimestamps.set(filePath, timestamp);
      } else {
        this.baseline.set(filePath, []);
        this.lastProcessedTimestamps.set(filePath, timestamp);
      }
    } catch (error) {
      console.error('Error getting baseline diagnostics:', error);
    }
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°æ–°ì˜ì§„ë‹¨ì •ë³´ - ê¸°ë°˜chunks.92.mjs:122-155
   */
  public async getNewDiagnostics(): Promise<DiagnosticInfo[]> {
    if (!this.initialized || !this.mcpClient || this.mcpClient.type !== "connected") {
      return [];
    }

    let allDiagnostics: DiagnosticInfo[] = [];
    
    try {
      const result = await this.callDiagnosticsTool("getDiagnostics", {});
      allDiagnostics = this.parseDiagnosticResult(result);
    } catch (error) {
      console.error('Error getting diagnostics:', error);
      return [];
    }

    // åˆ†ç¦»ë¡œì»¬íŒŒì¼ì™€å³ä¾§íŒŒì¼ì˜ì§„ë‹¨ì •ë³´
    const localFiles = allDiagnostics
      .filter(info => this.baseline.has(this.normalizeFileUri(info.uri)))
      .filter(info => info.uri.startsWith("file://"));

    const rightFileMap = new Map<string, DiagnosticInfo>();
    allDiagnostics
      .filter(info => this.baseline.has(this.normalizeFileUri(info.uri)))
      .filter(info => info.uri.startsWith("_claude_fs_right:"))
      .forEach(info => {
        rightFileMap.set(this.normalizeFileUri(info.uri), info);
      });

    // æ¯”è¾ƒì§„ë‹¨ì •ë³´å˜åŒ–
    const newDiagnostics: DiagnosticInfo[] = [];
    
    for (const info of localFiles) {
      const normalizedUri = this.normalizeFileUri(info.uri);
      const baselineDiagnostics = this.baseline.get(normalizedUri) || [];
      const rightFileInfo = rightFileMap.get(normalizedUri);
      let currentInfo = info;

      if (rightFileInfo) {
        const previousRightState = this.rightFileDiagnosticsState.get(normalizedUri);
        if (!previousRightState || !this.areDiagnosticArraysEqual(previousRightState, rightFileInfo.diagnostics)) {
          currentInfo = rightFileInfo;
        }
        this.rightFileDiagnosticsState.set(normalizedUri, rightFileInfo.diagnostics);
      }

      const newDiagnosticsForFile = currentInfo.diagnostics.filter(diag => 
        !baselineDiagnostics.some(baseline => this.areDiagnosticsEqual(diag, baseline))
      );

      if (newDiagnosticsForFile.length > 0) {
        newDiagnostics.push({
          uri: info.uri,
          diagnostics: newDiagnosticsForFile
        });
      }

      this.baseline.set(normalizedUri, currentInfo.diagnostics);
    }

    return newDiagnostics;
  }

  /**
   * è§£æì§„ë‹¨ç»“æœ - ê¸°ë°˜chunks.92.mjs:156-162
   */
  private parseDiagnosticResult(result: any): DiagnosticInfo[] {
    if (Array.isArray(result)) {
      const textResult = result.find(item => item.type === "text");
      if (textResult && "text" in textResult) {
        return JSON.parse(textResult.text);
      }
    }
    return [];
  }

  /**
   * æ¯”è¾ƒì§„ë‹¨ì •ë³´ì˜ˆì•„ë‹ˆì˜¤ç›¸ç­‰ - ê¸°ë°˜chunks.92.mjs:163-169
   */
  private areDiagnosticsEqual(a: LspDiagnostic, b: LspDiagnostic): boolean {
    return a.message === b.message && 
           a.severity === b.severity && 
           a.source === b.source && 
           a.code === b.code && 
           a.range.start.line === b.range.start.line && 
           a.range.start.character === b.range.start.character && 
           a.range.end.line === b.range.end.line && 
           a.range.end.character === b.range.end.character;
  }

  /**
   * æ¯”è¾ƒì§„ë‹¨ë°°ì—´ì˜ˆì•„ë‹ˆì˜¤ç›¸ç­‰
   */
  private areDiagnosticArraysEqual(a: LspDiagnostic[], b: LspDiagnostic[]): boolean {
    if (a.length !== b.length) return false;
    
    return a.every(diagA => b.some(diagB => this.areDiagnosticsEqual(diagA, diagB))) && 
           b.every(diagB => a.some(diagA => this.areDiagnosticsEqual(diagA, diagB)));
  }

  /**
   * í‘œì¤€åŒ–íŒŒì¼URI
   */
  private normalizeFileUri(uri: string): string {
    if (uri.startsWith("file://")) {
      return uri.replace("file://", "");
    }
    if (uri.startsWith("_claude_fs_right:")) {
      return uri.replace("_claude_fs_right:", "");
    }
    return uri;
  }

  /**
   * è°ƒç”¨ì§„ë‹¨ë„êµ¬
   */
  private async callDiagnosticsTool(toolName: string, params: any): Promise<any> {
    if (!this.mcpClient) {
      throw new Error('MCP client not initialized');
    }
    
    return await this.mcpClient.callTool(`mcp__ide__${toolName}`, params);
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°åŸºçº¿ì§„ë‹¨ì •ë³´
   */
  public getBaselineDiagnostics(filePath: string): LspDiagnostic[] {
    return this.baseline.get(filePath) || [];
  }

  /**
   * æ¸…é™¤ì§„ë‹¨åŸºçº¿
   */
  public clearBaseline(filePath?: string): void {
    if (filePath) {
      this.baseline.delete(filePath);
      this.lastProcessedTimestamps.delete(filePath);
      this.rightFileDiagnosticsState.delete(filePath);
    } else {
      this.baseline.clear();
      this.lastProcessedTimestamps.clear();
      this.rightFileDiagnosticsState.clear();
    }
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°æ‰€ìˆìŒì¶”ì ì˜íŒŒì¼
   */
  public getTrackedFiles(): string[] {
    return Array.from(this.baseline.keys());
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°ì§„ë‹¨í†µê³„ì •ë³´
   */
  public getDiagnosticsStatistics(): {
    totalFiles: number;
    totalDiagnostics: number;
    errorCount: number;
    warningCount: number;
    infoCount: number;
  } {
    let totalDiagnostics = 0;
    let errorCount = 0;
    let warningCount = 0;
    let infoCount = 0;

    for (const diagnostics of this.baseline.values()) {
      totalDiagnostics += diagnostics.length;
      
      for (const diag of diagnostics) {
        switch (diag.severity) {
          case 1: errorCount++; break;      // Error
          case 2: warningCount++; break;    // Warning
          case 3: 
          case 4: infoCount++; break;       // Information/Hint
        }
      }
    }

    return {
      totalFiles: this.baseline.size,
      totalDiagnostics,
      errorCount,
      warningCount,
      infoCount
    };
  }
}

/**
 * IDEì—°ê²°æ£€æµ‹å™¨
 * ê¸°ë°˜é€†å‘ë¶„ì„chunks.33585-33588ì˜TF1í•¨ìˆ˜êµ¬í˜„
 */
export class IdeConnectionDetector {
  /**
   * æ£€æµ‹ì—°ê²°ì˜IDEíƒ€ì… - ê¸°ë°˜TF1í•¨ìˆ˜
   */
  public static detectConnectedIde(mcpServers: any[]): string | null {
    const ideServer = mcpServers.find(server => 
      server.type === "connected" && server.name === "ide"
    )?.config;
    
    if (ideServer?.type === "sse-ide" || ideServer?.type === "ws-ide") {
      return ideServer.ideName;
    }
    
    return null;
  }

  /**
   * ê°€ì ¸ì˜¤ê¸°IDEí‘œì‹œåç§°
   */
  public static getIdeDisplayName(ideName: string): string {
    switch (ideName) {
      case "vscode":
        return "VS Code";
      case "cursor":
        return "Cursor";
      case "windsurf":
        return "Windsurf";
      default:
        return ideName;
    }
  }

  /**
   * í™•ì¸IDEåŠŸèƒ½ì§€ì›
   */
  public static getIdeCapabilities(ideName: string): {
    supportsExecuteCode: boolean;
    supportsGetDiagnostics: boolean;
    supportsShiftEnter: boolean;
  } {
    const supportedIdes = ["vscode", "cursor", "windsurf"];
    const isSupported = supportedIdes.includes(ideName);
    
    return {
      supportsExecuteCode: isSupported,
      supportsGetDiagnostics: isSupported,
      supportsShiftEnter: ["iTerm.app", "vscode", "cursor", "windsurf", "ghostty"].includes(ideName)
    };
  }
}

/**
 * ì§„ë‹¨ì •ë³´UIì»´í¬ë„ŒíŠ¸
 */
export interface DiagnosticsDisplayProps {
  diagnostics: DiagnosticInfo[];
  theme: any;
}

export function DiagnosticsDisplay({ diagnostics, theme }: DiagnosticsDisplayProps): React.ReactElement | null {
  if (diagnostics.length === 0) {
    return null;
  }

  const getSeverityIcon = (severity: number): string => {
    switch (severity) {
      case 1: return "âŒ"; // Error
      case 2: return "âš ï¸"; // Warning
      case 3: return "â„¹ï¸"; // Information
      case 4: return "ğŸ’¡"; // Hint
      default: return "ğŸ“";
    }
  };

  const getSeverityColor = (severity: number): string => {
    switch (severity) {
      case 1: return theme.error;
      case 2: return theme.warning;
      case 3: return theme.info;
      case 4: return theme.hint;
      default: return theme.primaryText;
    }
  };

  return (
    <div style={{
      backgroundColor: theme.diagnosticsBackground,
      borderRadius: 4,
      padding: 8,
      marginTop: 8
    }}>
      <div style={{
        color: theme.primaryText,
        fontWeight: 'bold',
        marginBottom: 8
      }}>
        ğŸ” New Diagnostics Found
      </div>
      
      {diagnostics.map((fileInfo, index) => (
        <div key={index} style={{ marginBottom: 12 }}>
          <div style={{
            color: theme.secondaryText,
            fontSize: '0.9em',
            marginBottom: 4
          }}>
            ğŸ“ {fileInfo.uri.replace('file://', '')}
          </div>
          
          {fileInfo.diagnostics.map((diag, diagIndex) => (
            <div key={diagIndex} style={{
              display: 'flex',
              alignItems: 'flex-start',
              marginBottom: 4,
              paddingLeft: 16
            }}>
              <span style={{ marginRight: 8 }}>
                {getSeverityIcon(diag.severity)}
              </span>
              <div style={{ flex: 1 }}>
                <div style={{
                  color: getSeverityColor(diag.severity),
                  fontSize: '0.9em'
                }}>
                  Line {diag.range.start.line + 1}: {diag.message}
                </div>
                {diag.source && (
                  <div style={{
                    color: theme.secondaryText,
                    fontSize: '0.8em'
                  }}>
                    Source: {diag.source}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      ))}
    </div>
  );
}
```

### ë‹¨ê³„3.9: í†µí•© í…ŒìŠ¤íŠ¸ì™€ê²€ì¦

**ìƒì„±ì „ì²´ì˜í†µí•© í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸**

**íŒŒì¼ ê²½ë¡œ**: `src/__tests__/stage3-integration.test.ts`
**íŒŒì¼ ë‚´ìš©**:
```typescript
/**
 * ë‹¨ê³„3í†µí•© í…ŒìŠ¤íŠ¸ìŠ¤ìœ„íŠ¸
 * ê²€ì¦Planëª¨ë“œ, Steeringë©”ì»¤ë‹ˆì¦˜, íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œì™€IDEí†µí•©ì˜ì „ì²´åŠŸèƒ½
 */

import { describe, test, expect, beforeEach, afterEach } from '@jest/testing-library';
import { PlanModeManager, wj2 } from '../core/plan-mode';
import { PlanAwareSteeringQueue, SteeringMessageHandler } from '../core/steering-plan-integration';
import { SpecialModeHandler } from '../ui/special-modes';
import { SlashCommandManager } from '../commands/slash-commands';
import { IdeDiagnosticsManager } from '../integrations/ide-diagnostics';

describe('ë‹¨ê³„3 - ê³ ê¸‰ ê¸°ëŠ¥ì™€ìƒí˜¸ì‘ìš© ëª¨ë“œí†µí•© í…ŒìŠ¤íŠ¸', () => {
  let planModeManager: PlanModeManager;
  let steeringQueue: PlanAwareSteeringQueue;
  let specialModeHandler: SpecialModeHandler;
  let slashCommandManager: SlashCommandManager;
  let diagnosticsManager: IdeDiagnosticsManager;

  beforeEach(() => {
    // ì´ˆê¸°í™”æ‰€ìˆìŒì»´í¬ë„ŒíŠ¸
    const mockEventLogger = jest.fn();
    planModeManager = new PlanModeManager('default', 'test-session', mockEventLogger);
    steeringQueue = new PlanAwareSteeringQueue(planModeManager);
    specialModeHandler = new SpecialModeHandler();
    slashCommandManager = new SlashCommandManager();
    diagnosticsManager = IdeDiagnosticsManager.getInstance();
  });

  afterEach(() => {
    // æ¸…ç†èµ„æº
    steeringQueue.stopStdinListening();
  });

  describe('Planëª¨ë“œí•µì‹¬åŠŸèƒ½í…ŒìŠ¤íŠ¸', () => {
    test('wj2ìƒíƒœ ë¨¸ì‹ ìˆœí™˜åŠŸèƒ½', () => {
      // í…ŒìŠ¤íŠ¸ê¸°ë³¸ìˆœí™˜: default â†’ acceptEdits â†’ plan â†’ default
      expect(wj2({ mode: 'default', isBypassPermissionsModeAvailable: false })).toBe('acceptEdits');
      expect(wj2({ mode: 'acceptEdits', isBypassPermissionsModeAvailable: false })).toBe('plan');
      expect(wj2({ mode: 'plan', isBypassPermissionsModeAvailable: false })).toBe('default');
      
      // í…ŒìŠ¤íŠ¸å¸¦bypassê¶Œí•œì˜ìˆœí™˜
      expect(wj2({ mode: 'plan', isBypassPermissionsModeAvailable: true })).toBe('bypassPermissions');
      expect(wj2({ mode: 'bypassPermissions', isBypassPermissionsModeAvailable: true })).toBe('default');
    });

    test('Planëª¨ë“œê´€ë¦¬å™¨ìƒíƒœì „í™˜', () => {
      // í…ŒìŠ¤íŠ¸åˆå§‹ìƒíƒœ
      expect(planModeManager.getCurrentMode()).toBe('default');
      expect(planModeManager.isPlanMode()).toBe(false);

      // í…ŒìŠ¤íŠ¸ëª¨ë“œìˆœí™˜
      planModeManager.cyclePlanMode(false);
      expect(planModeManager.getCurrentMode()).toBe('acceptEdits');

      planModeManager.cyclePlanMode(false);
      expect(planModeManager.getCurrentMode()).toBe('plan');
      expect(planModeManager.isPlanMode()).toBe(true);

      planModeManager.cyclePlanMode(false);
      expect(planModeManager.getCurrentMode()).toBe('default');
    });

    test('Planëª¨ë“œå¼ºåˆ¶ì„¤ì •', () => {
      planModeManager.setMode('plan', 'test_reason');
      expect(planModeManager.getCurrentMode()).toBe('plan');
      expect(planModeManager.isPlanMode()).toBe(true);
    });

    test('Planëª¨ë“œë¦¬ìŠ¤ë„ˆë©”ì»¤ë‹ˆì¦˜', () => {
      const mockListener = jest.fn();
      planModeManager.addListener('test-listener', mockListener);

      planModeManager.cyclePlanMode(false);
      expect(mockListener).toHaveBeenCalledWith(
        expect.objectContaining({
          currentMode: 'acceptEdits',
          previousMode: 'default'
        })
      );

      planModeManager.removeListener('test-listener');
      planModeManager.cyclePlanMode(false);
      expect(mockListener).toHaveBeenCalledTimes(1); // ä¸ä¼šå†æ¬¡è°ƒç”¨
    });
  });

  describe('ì‹¤ì‹œê°„ Steeringë©”ì»¤ë‹ˆì¦˜í…ŒìŠ¤íŠ¸', () => {
    test('Steeringë©”ì‹œì§€íê¸°ë³¸åŠŸèƒ½', async () => {
      const message = {
        type: 'user_input' as const,
        content: 'test message',
        timestamp: Date.now(),
        sessionId: 'test-session'
      };

      steeringQueue.enqueue(message);
      const received = await steeringQueue.getSteeringMessage();
      expect(received).toEqual(message);
    });

    test('Planëª¨ë“œä¸‹ì˜Steeringì²˜ë¦¬', async () => {
      planModeManager.setMode('plan', 'test');
      
      const handler = new SteeringMessageHandler(planModeManager);
      const message = {
        type: 'user_input' as const,
        content: 'adjust the plan',
        timestamp: Date.now(),
        sessionId: 'test-session',
        planContext: { currentMode: 'plan' }
      };

      const result = await handler.handleMessage(message);
      expect(result.shouldContinue).toBe(true);
      expect(result.action).toBe('refine_plan');
    });

    test('Planæ‰¹å‡†ì™€æ‹’ç»ì²˜ë¦¬', async () => {
      planModeManager.setMode('plan', 'test');
      const handler = new SteeringMessageHandler(planModeManager);

      // í…ŒìŠ¤íŠ¸è®¡åˆ’æ‰¹å‡†
      const approvalMessage = {
        type: 'plan_approval' as const,
        content: 'approve plan',
        timestamp: Date.now(),
        sessionId: 'test-session'
      };

      const approvalResult = await handler.handleMessage(approvalMessage);
      expect(approvalResult.action).toBe('execute_plan');
      expect(planModeManager.getCurrentMode()).toBe('default');

      // ì¬ì„¤ì •åˆ°planëª¨ë“œí…ŒìŠ¤íŠ¸æ‹’ç»
      planModeManager.setMode('plan', 'test');
      const rejectionMessage = {
        type: 'plan_rejection' as const,
        content: 'reject plan',
        timestamp: Date.now(),
        sessionId: 'test-session'
      };

      const rejectionResult = await handler.handleMessage(rejectionMessage);
      expect(rejectionResult.shouldContinue).toBe(false);
      expect(rejectionResult.action).toBe('revise_plan');
    });
  });

  describe('íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œí…ŒìŠ¤íŠ¸', () => {
    test('Bashëª¨ë“œæ£€æµ‹ì™€ì²˜ë¦¬', () => {
      const result = specialModeHandler.processInput('!ls -la');
      expect(result.mode).toBe('bash');
      expect(result.content).toBe('ls -la');
      expect(result.shouldExecute).toBe(true);
    });

    test('ë…¸íŠ¸ëª¨ë“œæ£€æµ‹ì™€ì²˜ë¦¬', () => {
      const result = specialModeHandler.processInput('# è¿™ì˜ˆä¸€ä¸ªí…ŒìŠ¤íŠ¸ë…¸íŠ¸ #important');
      expect(result.mode).toBe('note');
      expect(result.shouldExecute).toBe(false);
      
      const notes = specialModeHandler.getNotes();
      expect(notes.length).toBe(1);
      expect(notes[0].content).toBe('è¿™ì˜ˆä¸€ä¸ªí…ŒìŠ¤íŠ¸ë…¸íŠ¸ #important');
      expect(notes[0].tags).toContain('important');
    });

    test('ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥ëª¨ë“œ', () => {
      // å¼€å§‹ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥
      let result = specialModeHandler.processInput('```javascript');
      expect(result.mode).toBe('multiline');
      expect(result.shouldExecute).toBe(false);

      // ê³„ì†ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥
      result = specialModeHandler.processInput('function test() {');
      expect(result.mode).toBe('multiline');
      expect(result.shouldExecute).toBe(false);

      // ç»“æŸë‹¤ì¤‘ ë¼ì¸ ì…ë ¥
      result = specialModeHandler.processInput('```');
      expect(result.mode).toBe('normal');
      expect(result.shouldExecute).toBe(true);
      expect(result.content).toContain('function test() {');
    });

    test('ëª¨ë“œìƒíƒœì¿¼ë¦¬', () => {
      specialModeHandler.processInput('```');
      const status = specialModeHandler.getCurrentModeStatus();
      expect(status.mode).toBe('multiline');
      expect(status.isActive).toBe(true);
      expect(status.buffer).toHaveLength(1);
    });

    test('ë…¸íŠ¸ê²€ìƒ‰åŠŸèƒ½', () => {
      specialModeHandler.processInput('# ç¬¬ä¸€ä¸ªë…¸íŠ¸ #project #todo');
      specialModeHandler.processInput('# ç¬¬äºŒä¸ªë…¸íŠ¸ #meeting');
      specialModeHandler.processInput('# ç¬¬ä¸‰ä¸ªë…¸íŠ¸ #project #done');

      const projectNotes = specialModeHandler.searchNotes('project');
      expect(projectNotes).toHaveLength(2);

      const todoNotes = specialModeHandler.searchNotes('todo');
      expect(todoNotes).toHaveLength(1);
    });
  });

  describe('ë‹¨ì¶• ëª…ë ¹ ì‹œìŠ¤í…œí…ŒìŠ¤íŠ¸', () => {
    const mockContext = {
      sessionId: 'test-session',
      mcpServers: [],
      currentDirectory: '/test',
      planModeManager: planModeManager
    };

    test('ì»¤ë§¨ë“œæ£€æµ‹ì™€è§£æ', () => {
      expect(slashCommandManager.isSlashCommand('/help')).toBe(true);
      expect(slashCommandManager.isSlashCommand('normal message')).toBe(false);
    });

    test('/helpì»¤ë§¨ë“œ', async () => {
      const result = await slashCommandManager.execute('/help', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('Available commands');
    });

    test('/helpêµ¬ì²´ì»¤ë§¨ë“œ', async () => {
      const result = await slashCommandManager.execute('/help login', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('Command: /login');
    });

    test('/modeì»¤ë§¨ë“œ', async () => {
      // ì¿¼ë¦¬å½“å‰ëª¨ë“œ
      let result = await slashCommandManager.execute('/mode', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('Current mode: default');

      // ì „í™˜ëª¨ë“œ
      result = await slashCommandManager.execute('/mode plan', mockContext);
      expect(result.success).toBe(true);
      expect(planModeManager.getCurrentMode()).toBe('plan');
    });

    test('/statusì»¤ë§¨ë“œ', async () => {
      const result = await slashCommandManager.execute('/status', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('System Status');
      expect(result.message).toContain('session: test-session');
    });

    test('/mcpì»¤ë§¨ë“œ', async () => {
      const contextWithServers = {
        ...mockContext,
        mcpServers: [
          { name: 'test-server', status: 'connected', tools: ['tool1', 'tool2'] }
        ]
      };

      const result = await slashCommandManager.execute('/mcp list', contextWithServers);
      expect(result.success).toBe(true);
      expect(result.message).toContain('test-server: connected (2 tools)');
    });

    test('ì»¤ë§¨ë“œìë™è¡¥å…¨', () => {
      const completions = slashCommandManager.getCompletions('/he');
      expect(completions).toContain('/help');

      const allCompletions = slashCommandManager.getCompletions('/');
      expect(allCompletions).toContain('/help');
      expect(allCompletions).toContain('/login');
      expect(allCompletions).toContain('/mode');
    });

    test('ì—†ìŒæ•ˆì»¤ë§¨ë“œì²˜ë¦¬', async () => {
      const result = await slashCommandManager.execute('/nonexistent', mockContext);
      expect(result.success).toBe(false);
      expect(result.message).toContain('Unknown command');
    });

    test('ì»¤ë§¨ë“œåˆ«åì§€ì›', async () => {
      const result = await slashCommandManager.execute('/cls', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('Conversation history cleared');
    });
  });

  describe('IDEí†µí•© í…ŒìŠ¤íŠ¸', () => {
    test('ì§„ë‹¨ê´€ë¦¬å™¨ì‹±ê¸€í†¤ëª¨ë“œ', () => {
      const instance1 = IdeDiagnosticsManager.getInstance();
      const instance2 = IdeDiagnosticsManager.getInstance();
      expect(instance1).toBe(instance2);
    });

    test('ì§„ë‹¨ì •ë³´æ¯”è¾ƒ', () => {
      const manager = IdeDiagnosticsManager.getInstance();
      
      const diag1 = {
        message: 'Test error',
        severity: 1,
        source: 'eslint',
        code: 'E001',
        range: {
          start: { line: 10, character: 5 },
          end: { line: 10, character: 15 }
        }
      };

      const diag2 = { ...diag1 };
      const diag3 = { ...diag1, message: 'Different error' };

      expect(manager['areDiagnosticsEqual'](diag1, diag2)).toBe(true);
      expect(manager['areDiagnosticsEqual'](diag1, diag3)).toBe(false);
    });

    test('íŒŒì¼URIí‘œì¤€åŒ–', () => {
      const manager = IdeDiagnosticsManager.getInstance();
      
      expect(manager['normalizeFileUri']('file:///path/to/file.js')).toBe('/path/to/file.js');
      expect(manager['normalizeFileUri']('_claude_fs_right:/path/to/file.js')).toBe('/path/to/file.js');
      expect(manager['normalizeFileUri']('/path/to/file.js')).toBe('/path/to/file.js');
    });

    test('ì§„ë‹¨í†µê³„ê³„ì‚°', () => {
      const manager = IdeDiagnosticsManager.getInstance();
      
      // æ¨¡æ‹Ÿä¸€äº›ì§„ë‹¨ë°ì´í„°
      manager['baseline'].set('/file1.js', [
        { message: 'Error 1', severity: 1, range: { start: { line: 0, character: 0 }, end: { line: 0, character: 5 } } },
        { message: 'Warning 1', severity: 2, range: { start: { line: 1, character: 0 }, end: { line: 1, character: 5 } } }
      ]);
      
      manager['baseline'].set('/file2.js', [
        { message: 'Info 1', severity: 3, range: { start: { line: 0, character: 0 }, end: { line: 0, character: 5 } } }
      ]);

      const stats = manager.getDiagnosticsStatistics();
      expect(stats.totalFiles).toBe(2);
      expect(stats.totalDiagnostics).toBe(3);
      expect(stats.errorCount).toBe(1);
      expect(stats.warningCount).toBe(1);
      expect(stats.infoCount).toBe(1);
    });
  });

  describe('ç»¼åˆí†µí•© í…ŒìŠ¤íŠ¸', () => {
    test('Planëª¨ë“œ + Steeringë©”ì»¤ë‹ˆì¦˜í†µí•©', async () => {
      // ì§„ì…Planëª¨ë“œ
      planModeManager.setMode('plan', 'integration_test');
      
      // å‘é€Steeringë©”ì‹œì§€
      const handler = new SteeringMessageHandler(planModeManager);
      const message = {
        type: 'user_input' as const,
        content: 'modify the plan to include testing',
        timestamp: Date.now(),
        sessionId: 'test-session',
        planContext: { currentMode: 'plan' }
      };

      const result = await handler.handleMessage(message);
      expect(result.action).toBe('refine_plan');
      expect(planModeManager.isPlanMode()).toBe(true);
    });

    test('íŠ¹ìˆ˜ëª¨ë“œ + ë‹¨ì¶• ëª…ë ¹í†µí•©', async () => {
      // ë…¸íŠ¸ëª¨ë“œìƒì„±ë…¸íŠ¸
      specialModeHandler.processInput('# í†µí•© í…ŒìŠ¤íŠ¸ë…¸íŠ¸ #integration');
      
      // ä½¿ç”¨ë‹¨ì¶• ëª…ë ¹ë³´ê¸°ìƒíƒœ
      const context = {
        sessionId: 'test-session',
        mcpServers: [],
        currentDirectory: '/test',
        planModeManager: planModeManager
      };

      const result = await slashCommandManager.execute('/status', context);
      expect(result.success).toBe(true);

      // ê²€ì¦ë…¸íŠ¸å·²ì €ì¥
      const notes = specialModeHandler.getNotes();
      expect(notes).toHaveLength(1);
      expect(notes[0].tags).toContain('integration');
    });

    test('ì „ì²´å·¥ä½œí”„ë¡œì„¸ìŠ¤æ¨¡æ‹Ÿ', async () => {
      // 1. ì§„ì…Planëª¨ë“œ
      planModeManager.setMode('plan', 'workflow_test');
      
      // 2. ä½¿ç”¨íŠ¹ìˆ˜ëª¨ë“œè®°å½•ë…¸íŠ¸
      specialModeHandler.processInput('# è®¡åˆ’: êµ¬í˜„æ–°åŠŸèƒ½ #planning');
      
      // 3. ä½¿ç”¨ë‹¨ì¶• ëª…ë ¹í™•ì¸ìƒíƒœ
      const context = {
        sessionId: 'test-session',
        mcpServers: [],
        currentDirectory: '/test',
        planModeManager: planModeManager
      };
      
      let result = await slashCommandManager.execute('/mode', context);
      expect(result.message).toContain('plan');
      
      // 4. é€šè¿‡Steeringæ‰¹å‡†è®¡åˆ’
      const handler = new SteeringMessageHandler(planModeManager);
      const approvalMessage = {
        type: 'plan_approval' as const,
        content: 'approve',
        timestamp: Date.now(),
        sessionId: 'test-session'
      };
      
      const approvalResult = await handler.handleMessage(approvalMessage);
      expect(approvalResult.action).toBe('execute_plan');
      expect(planModeManager.getCurrentMode()).toBe('default');
      
      // 5. ê²€ì¦æœ€ç»ˆìƒíƒœ
      result = await slashCommandManager.execute('/status', context);
      expect(result.message).toContain('default');
    });
  });
});
```

---

## ğŸ“‹ ë‹¨ê³„3ì™„ë£Œ í™•ì¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ëŠ¥ ê²€ì¦ í•­ëª©

**Planëª¨ë“œì‹œìŠ¤í…œ** âœ…
- [ ] wj2ìƒíƒœ ë¨¸ì‹ ìˆœí™˜åŠŸèƒ½æ­£å¸¸
- [ ] Shift+Tabé”®ì „í™˜å·¥ä½œæ­£å¸¸
- [ ] Planëª¨ë“œUIæŒ‡ç¤ºå™¨í‘œì‹œæ­£ç¡®
- [ ] exit_plan_modeë„êµ¬æ­£å¸¸å·¥ä½œ
- [ ] ì‹œìŠ¤í…œæé†’æ³¨å…¥ë©”ì»¤ë‹ˆì¦˜ç”Ÿæ•ˆ

**ì‹¤ì‹œê°„ Steeringë©”ì»¤ë‹ˆì¦˜** âœ…
- [ ] h2Aë©”ì‹œì§€íí†µí•©Planëª¨ë“œ
- [ ] stdinë¦¬ìŠ¤ë‹æ•è·ì‚¬ìš©ìì…ë ¥
- [ ] Planëª¨ë“œä¸‹ì˜íŠ¹ìˆ˜ì»¤ë§¨ë“œì²˜ë¦¬
- [ ] Steeringë©”ì‹œì§€íƒ€ì…æ­£ç¡®åˆ†í´ë˜ìŠ¤
- [ ] ì‚¬ìš©ìê°€ì´ë“œì‘ë‹µåŠæ—¶

**íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš© ëª¨ë“œ** âœ…
- [ ] !bashëª¨ë“œç›´æ¥æ‰§è¡Œì»¤ë§¨ë“œ
- [ ] #ë…¸íŠ¸ëª¨ë“œè®°å½•ì™€ê²€ìƒ‰
- [ ] ë‹¤ì¤‘ ë¼ì¸ ì…ë ¥ëª¨ë“œæ­£å¸¸å·¥ä½œ
- [ ] ëª¨ë“œìƒíƒœæ­£ç¡®í‘œì‹œ
- [ ] ëª¨ë“œì „í™˜æµç•…

**ë‹¨ì¶• ëª…ë ¹ ì‹œìŠ¤í…œ** âœ…
- [ ] 15+æ–œæ ì»¤ë§¨ë“œëª¨ë‘êµ¬í˜„
- [ ] ì»¤ë§¨ë“œìë™è¡¥å…¨åŠŸèƒ½
- [ ] ë§¤ê°œë³€ìˆ˜è§£æì™€ê²€ì¦
- [ ] ì˜¤ë¥˜ ì²˜ë¦¬ì™€å¸®åŠ©ì •ë³´
- [ ] ì»¤ë§¨ë“œåˆ«åì§€ì›

**IDEí†µí•©ë©”ì»¤ë‹ˆì¦˜** âœ…
- [ ] PKì§„ë‹¨ê´€ë¦¬å™¨æ­£å¸¸å·¥ä½œ
- [ ] LSPí”„ë¡œí† ì½œí†µí•©ì„±ê³µ
- [ ] ì§„ë‹¨ì •ë³´æ¯”è¾ƒì•Œê³ ë¦¬ì¦˜å‡†ç¡®
- [ ] MCPë„êµ¬í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ë©”ì»¤ë‹ˆì¦˜
- [ ] IDEì—°ê²°æ£€æµ‹åŠŸèƒ½

### ì„±ëŠ¥ ê²€ì¦ í•­ëª©

**ì‘ë‹µ ì„±ëŠ¥** âœ…
- [ ] ëª¨ë“œì „í™˜ì‘ë‹µ < 100ms
- [ ] Steeringë©”ì‹œì§€ì²˜ë¦¬ < 200ms
- [ ] ë‹¨ì¶• ëª…ë ¹æ‰§è¡Œ < 500ms
- [ ] ì§„ë‹¨ì •ë³´ê°€ì ¸ì˜¤ê¸° < 1s
- [ ] UIì—…ë°ì´íŠ¸æµç•…ì—†ìŒå¡é¡¿

**ë©”ëª¨ë¦¬ ì‚¬ìš©** âœ…
- [ ] Planëª¨ë“œìƒíƒœå ç”¨ < 10MB
- [ ] Steeringíë²„í¼ < 50MB
- [ ] ì§„ë‹¨ì •ë³´ìºì‹œ < 100MB
- [ ] æ€»ä½“ë©”ëª¨ë¦¬å¢é•¿ < 200MB

**ë™ì‹œ ì²˜ë¦¬** âœ…
- [ ] å¤šëª¨ë“œåŒæ—¶ì‹¤í–‰ç¨³å®š
- [ ] Steeringë©”ì‹œì§€ä¸ä¸¢å¤±
- [ ] ë‹¨ì¶• ëª…ë ¹ä¸ì¶©ëŒ
- [ ] IDEí†µí•©ä¸é˜»å¡ä¸»í”„ë¡œì„¸ìŠ¤

### í’ˆì§ˆ ê²€ì¦ í•­ëª©

**ì½”ë“œ í’ˆì§ˆ** âœ…
- [ ] TypeScriptíƒ€ì…ì˜¤ë²„ë¼ì´ë“œ > 95%
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì˜¤ë²„ë¼ì´ë“œ > 80%
- [ ] í†µí•© í…ŒìŠ¤íŠ¸é€šè¿‡ç‡ 100%
- [ ] ì½”ë“œë³µì¡åº¦ < 10
- [ ] ì—†ìŒESLintê²½ê³ ì˜¤ë¥˜

**ì‚¬ìš©ì ê²½í—˜** âœ…
- [ ] æ“ä½œç›´è§‚æ˜“æ‡‚
- [ ] ì˜¤ë¥˜íŒíŠ¸å‹å¥½
- [ ] åŠŸèƒ½å‘ç°æ€§å¥½
- [ ] å¸®åŠ©ë¬¸ì„œì „ì²´
- [ ] é”®ç›˜å¿«æ·é”®é«˜æ•ˆ

**í˜¸í™˜ì„±** âœ…
- [ ] Node.js 18+ ì§€ì›
- [ ] ä¸»æµIDEå…¼å®¹
- [ ] å¤šæ“ä½œì‹œìŠ¤í…œì§€ì›
- [ ] í„°ë¯¸ë„í™˜ê²½é€‚é…
- [ ] MCPí”„ë¡œí† ì½œí‘œì¤€åˆè§„

---

## ğŸ¯ ë‹¤ìŒ ë‹¨ê³„ ì˜ˆê³ 

ë‹¨ê³„3ì™„ë£Œ í›„, Open Claude Codeì„/ë¥¼ ê°–ì¶”ê²Œ ë¨: 

1. **ì „ì²´ì˜ê³ ê¸‰äº¤äº’ê¸°ëŠ¥**: 
   - Planëª¨ë“œë³´ì•ˆë¶„ì„
   - ì‹¤ì‹œê°„ì‚¬ìš©ìê°€ì´ë“œ
   - íŠ¹ìˆ˜ëª¨ë“œì²˜ë¦¬
   - ë‹¨ì¶• ëª…ë ¹ ì‹œìŠ¤í…œ

2. **IDEæ·±åº¦í†µí•©ê¸°ëŠ¥**: 
   - LSPì§„ë‹¨ì •ë³´
   - ì½”ë“œæ‰§è¡Œí™˜ê²½
   - ì‹¤ì‹œê°„ìƒíƒœë™ê¸°í™”
   - MCPí”„ë¡œí† ì½œì§€ì›

3. **ä¼˜ç§€ì˜ì‚¬ìš©ì ê²½í—˜**: 
   - ç›´è§‚ì˜UIæŒ‡ç¤º
   - æµç•…ì˜äº¤äº’ì‘ë‹µ
   - å®Œå–„ì˜å¸®åŠ©ì‹œìŠ¤í…œ
   - é«˜æ•ˆì˜å¿«æ·æ“ä½œ

**ì§„ì…ë‹¨ê³„4**: MCP í†µí•©ì™€í™•ì¥ ì‹œìŠ¤í…œ(4ì£¼)
- ì „ì²´MCPí”„ë¡œí† ì½œ êµ¬í˜„
- å¤šì „ì†¡ë°©ì‹ì§€ì›
- í”ŒëŸ¬ê·¸ì¸ìƒíƒœê³„ì‹œìŠ¤í…œ
- ç¬¬ä¸‰æ–¹ë„êµ¬í†µí•©

è¿™ì€/ëŠ” ë‚˜íƒ€ëƒ„Open Claude Codeåœ¨ê³ ê¸‰ ê¸°ëŠ¥êµ¬í˜„ä¸Šì˜é‡å¤§ëŒíŒŒ, í–¥í›„ì˜MCP í†µí•©ì™€í™•ì¥íƒ„íƒ„í•œ ê¸°ë°˜ì„ ë§ˆë ¨í•¨. 